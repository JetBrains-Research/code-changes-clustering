mmm a / src / spade / storage / SQL . java <nl> ppp b / src / spade / storage / SQL . java <nl> - try { <nl> dbConnection . commit ( ) ; <nl> - String query = " SELECT dstVertexHash FROM edge WHERE srcVertexHash = " + getVertexFromId ( vertexId ) . hashCode ( ) ; <nl> + String query = " SELECT vertexId FROM vertex WHERE hash IN ( SELECT dstVertexHash FROM edge WHERE " + <nl> + " srcVertexHash = " + getVertexFromId ( vertexId ) . getAnnotation ( " hash " ) + " ) " ; <nl> Statement statement = dbConnection . createStatement ( ) ; <nl> ResultSet result = statement . executeQuery ( query ) ; <nl> - while ( result . next ( ) ) { <nl> + while ( result . next ( ) ) <nl> 
mmm a / src / test / java / net / openhft / chronicle / queue / impl / single / SingleChronicleQueueTest . java <nl> ppp b / src / test / java / net / openhft / chronicle / queue / impl / single / SingleChronicleQueueTest . java <nl> + @ Ignore ( " Long running " ) <nl> public void testCountExceptsBetweenCycles ( ) throws Exception { <nl>  <nl> - final SingleChronicleQueueBuilder builder = <nl> - binary ( getTmpDir ( ) ) <nl> - . testBlockSize ( ) <nl> - . rollCycle ( RollCycles . TEST_SECONDLY ) ; <nl> + final SingleChronicleQueueBuilder builder = binary ( getTmpDir ( ) ) <nl> + . rollCycle ( RollCycles . TEST_SECONDLY ) ; <nl> final RollingChronicleQueue queue = builder . build ( ) ; <nl> final ExcerptAppender appender = queue . createAppender ( ) ; <nl> 
mmm a / src / main / java / org / springframework / integration / kafka / inbound / KafkaMessageDrivenChannelAdapter . java <nl> ppp b / src / main / java / org / springframework / integration / kafka / inbound / KafkaMessageDrivenChannelAdapter . java <nl> - . withKeyValue ( KafkaHeaders . MESSAGE_KEY , key ) <nl> - . withKeyValue ( KafkaHeaders . TOPIC , metadata . getPartition ( ) . getTopic ( ) ) <nl> - . withKeyValue ( KafkaHeaders . PARTITION_ID , metadata . getPartition ( ) . getId ( ) ) <nl> - . withKeyValue ( KafkaHeaders . OFFSET , metadata . getOffset ( ) ) <nl> - . withKeyValue ( KafkaHeaders . NEXT_OFFSET , metadata . getNextOffset ( ) ) ; <nl> + headers . put ( KafkaHeaders . MESSAGE_KEY , key ) ; <nl> + headers . put ( KafkaHeaders . TOPIC , metadata . getPartition ( ) . getTopic ( ) ) ; <nl> + headers . put ( KafkaHeaders . PARTITION_ID , metadata . getPartition ( ) . getId ( ) ) ; <nl> + headers . put ( KafkaHeaders . OFFSET , metadata . getOffset ( ) ) ; <nl> + headers . put ( KafkaHeaders . NEXT_OFFSET , metadata . getNextOffset ( ) ) ; <nl>  <nl> - if ( ! this . generateMessageId ) { <nl> 
mmm a / src / main / java / org / jooq / lambda / Seq . java <nl> ppp b / src / main / java / org / jooq / lambda / Seq . java <nl> * & lt ; / pre & gt ; & lt ; / code & gt ; <nl> * / <nl> - default Seq & lt ; Window & lt ; T , ? & gt ; & gt ; window ( Comparator & lt ; ? super T & gt ; orderBy , long lower , long upper ) { <nl> - return ( Seq ) window ( t - & gt ; SeqImpl . NULL , orderBy , lower , upper ) ; <nl> + default Seq & lt ; Window & lt ; T & gt ; & gt ; window ( Comparator & lt ; ? super T & gt ; orderBy , long lower , long upper ) { <nl> + return window ( t - & gt ; SeqImpl . NULL , orderBy , lower , upper ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / src / test / java / com / elopteryx / paint / upload / UploadParserTest . java <nl> ppp b / src / test / java / com / elopteryx / paint / upload / UploadParserTest . java <nl> . onError ( this ) <nl> . sizeThreshold ( ( ) - & gt ; random . nextInt ( 1024 * 1024 * 10 ) ) <nl> . maxPartSize ( ( ) - & gt ; random . nextInt ( 1024 * 1024 * 50 ) ) <nl> - . maxRequestSize ( ( ) - & gt ; random . nextInt ( 1024 * 1024 * 50 ) ) <nl> - . setup ( ) ; <nl> + . maxRequestSize ( ( ) - & gt ; random . nextInt ( 1024 * 1024 * 50 ) ) ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / core / src / test / java / org / codice / imaging / nitf / core / Nitf21HeaderTest . java <nl> ppp b / core / src / test / java / org / codice / imaging / nitf / core / Nitf21HeaderTest . java <nl> final String testfile = " / JitcNitf21Samples / ns3321a . nsf " ; <nl> assertNotNull ( " Test file missing " , getClass ( ) . getResource ( testfile ) ) ; <nl>  <nl> - File resourceFile = new File ( getClass ( ) . getResource ( testfile ) . getFile ( ) ) ; <nl> + File resourceFile = new File ( getClass ( ) . getResource ( testfile ) . toURI ( ) . getPath ( ) ) ; <nl> SlottedParseStrategy parseStrategy = new SlottedParseStrategy ( SlottedParseStrategy . HEADERS_ONLY ) ; <nl> NitfReader reader = new FileReader ( resourceFile ) ; <nl> NitfParser . parse ( reader , parseStrategy ) ; <nl> 
mmm a / testData / generator / UpperRules . expected . java <nl> ppp b / testData / generator / UpperRules . expected . java <nl> - static boolean file ( PsiBuilder builder_ , int level_ ) { <nl> - return root ( builder_ , level_ + 1 ) ; <nl> + if ( ! recursion_guard_ ( builder_ , level_ , " file " ) ) return false ; <nl> + boolean result_ ; <nl> + Marker marker_ = enter_section_ ( builder_ ) ; <nl> + result_ = root ( builder_ , level_ + 1 ) ; <nl> + result_ = result_ & & file_1 ( builder_ , level_ + 1 ) ; <nl> + exit_section_ ( builder_ , marker_ , null , result_ ) ; <nl> + return result_ ; <nl> } <nl>  <nl> 
mmm a / src / test / java / net / imagej / ops / topology / eulerCharacteristic / EulerCharacteristic26NTest . java <nl> ppp b / src / test / java / net / imagej / ops / topology / eulerCharacteristic / EulerCharacteristic26NTest . java <nl> public void testEdgeCube ( ) throws Exception { <nl> final Img & lt ; BitType & gt ; img = drawCube ( 1 , 1 , 1 , 0 ) ; <nl>  <nl> - final Double result = ops . topology ( ) . eulerCharacteristic26N ( img ) ; <nl> + final double result = ops . topology ( ) . eulerCharacteristic26N ( img ) . get ( ) ; <nl>  <nl> assertEquals ( " Euler characteristic ( Ï ) is incorrect " , 0 . 0 , result , 1e - 12 ) ; <nl> } <nl> 
mmm a / app / src / main / java / de / Maxr1998 / xposed / maxlock / ui / SettingsActivity . java <nl> ppp b / app / src / main / java / de / Maxr1998 / xposed / maxlock / ui / SettingsActivity . java <nl> - if ( mSettingsFragment == null ) { <nl> - mSettingsFragment = MaxLockPreferenceFragment . Screen . MAIN . getScreen ( ) ; <nl> - FragmentTransaction ft = getSupportFragmentManager ( ) . beginTransaction ( ) ; <nl> - ft . setCustomAnimations ( R . anim . fragment_in , R . anim . fragment_out ) ; <nl> - ft . replace ( R . id . fragment_container , mSettingsFragment , TAG_PREFERENCE_FRAGMENT ) . commit ( ) ; <nl> + mSettingsFragment = getIntent ( ) . getAction ( ) . equals ( BuildConfig . APPLICATION_ID + " . VIEW_APPS " ) ? <nl> + new AppListFragment ( ) : MaxLockPreferenceFragment . Screen . MAIN . getScreen ( ) ; <nl> + getSupportFragmentManager ( ) . beginTransaction ( ) <nl> + . setCustomAnimations ( R . anim . fragment_in , R . anim . fragment_out ) <nl> + . replace ( R . id . fragment_container , mSettingsFragment , TAG_PREFERENCE_FRAGMENT ) <nl> + . commit ( ) ; <nl> if ( getSupportActionBar ( ) ! = null ) { <nl> getSupportActionBar ( ) . show ( ) ; <nl> 
mmm a / butterknife - compiler / src / main / java / butterknife / compiler / BindingClass . java <nl> ppp b / butterknife - compiler / src / main / java / butterknife / compiler / BindingClass . java <nl> - } else { <nl> - constructor . addStatement ( " super ( target , context ) " ) ; <nl> + } else { <nl> + constructor . addStatement ( " super ( target , context ) " ) ; <nl> + } <nl> + constructor . addCode ( " \ n " ) ; <nl> + } <nl> + if ( needsTargetField ( ) ) { <nl> + constructor . addStatement ( " this . target = target " ) ; <nl> + constructor . addCode ( " \ n " ) ; <nl> } <nl> - constructor . addCode ( " \ n " ) ; <nl>  <nl> if ( hasUnqualifiedResourceBindings ( ) ) { <nl> 
mmm a / grobid - core / src / test / java / org / grobid / core / GrobidModelsTest . java <nl> ppp b / grobid - core / src / test / java / org / grobid / core / GrobidModelsTest . java <nl> - assertThat ( model . getFolderName ( ) , is ( " dictionaries - senses " ) ) ; <nl> assertThat ( model . getModelName ( ) , is ( " dictionaries - senses " ) ) ; <nl> assertThat ( model . getTemplateName ( ) , is ( " dictionaries - senses . template " ) ) ; <nl> - assertThat ( model . getModelPath ( ) , endsWith ( " / grobid / grobid - home / models / dictionaries - senses / model . wapiti " ) ) ; <nl>  <nl> - GrobidModel model2 = GrobidModels . modelFor ( " dictionaries - lemma " ) ; <nl> - assertFalse ( model2 . equals ( model ) ) ; <nl> + String [ ] splittedPath = model . getModelPath ( ) . split ( " [ /  \  \  \  \ ] " ) ; <nl> + assertThat ( splittedPath [ splittedPath . length - 1 ] , is ( " model . wapiti " ) ) ; <nl> + assertThat ( splittedPath [ splittedPath . length - 2 ] , is ( " dictionaries - senses " ) ) ; <nl> + assertThat ( splittedPath [ splittedPath . length - 3 ] , is ( " models " ) ) ; <nl> 
mmm a / src / main / java / org / jdc / template / model / database / main / individual / IndividualBaseRecord . java <nl> ppp b / src / main / java / org / jdc / template / model / database / main / individual / IndividualBaseRecord . java <nl> - statement . bindString ( 11 , email ) ; <nl> - statement . bindLong ( 12 , available ? 1 : 0 ) ; <nl> - statement . bindDouble ( 13 , amount1 ) ; <nl> - statement . bindDouble ( 14 , amount2 ) ; <nl> - statement . bindLong ( 15 , enabled ? 1 : 0 ) ; <nl> + statement . bindString ( 11 , phone ) ; <nl> + statement . bindString ( 12 , email ) ; <nl> + statement . bindLong ( 13 , available ? 1 : 0 ) ; <nl> + statement . bindDouble ( 14 , amount1 ) ; <nl> + statement . bindDouble ( 15 , amount2 ) ; <nl> + statement . bindLong ( 16 , enabled ? 1 : 0 ) ; <nl> if ( spouseIndividualId ! = null ) { <nl> - statement . bindLong ( 16 , spouseIndividualId ) ; <nl> 
mmm a / guava / src / com / google / common / collect / AbstractRangeSet . java <nl> ppp b / guava / src / com / google / common / collect / AbstractRangeSet . java <nl> @ Override <nl> public void removeAll ( RangeSet & lt ; C & gt ; other ) { <nl> - for ( Range & lt ; C & gt ; range : other . asRanges ( ) ) { <nl> - remove ( range ) ; <nl> - } <nl> + removeAll ( other . asRanges ( ) ) ; <nl> } <nl> + <nl> + @ Override <nl> 
mmm a / assignments / assignment2 / app / src / androidTest / java / edu / vandy / view / PalantiriActivityTest . java <nl> ppp b / assignments / assignment2 / app / src / androidTest / java / edu / vandy / view / PalantiriActivityTest . java <nl> - startButton . perform ( click ( ) ) ; <nl> + p . second . toString ( ) ) ) ) ) ; <nl>  <nl> - setOrientationLandscape ( 2000 ) ; <nl> + setOrientationLandscape ( CONFIG_TIMEOUT ) ; <nl>  <nl> - SystemClock . sleep ( 4000 ) ; <nl> + pairs . stream ( ) . forEach ( <nl> 
mmm a / ij / io / FileOpener . java <nl> ppp b / ij / io / FileOpener . java <nl> - if ( fi . url ! =null & & ! fi . url . equals ( " " ) & & ( fi . directory==null||fi . directory . equals ( " " ) ) ) <nl> - path = fi . url ; <nl> IJ . showStatus ( " Loading : " + path ) ; <nl> - ImagePlus imp2 = IJ . openImage ( path ) ; <nl> + ImagePlus imp2 = null ; <nl> + if ( ! path . endsWith ( " . raw " ) ) <nl> + imp2 = IJ . openImage ( path ) ; <nl> if ( imp2 ! =null ) <nl> imp . setImage ( imp2 ) ; <nl> - } <nl> + else { <nl> 
mmm a / src / main / java / io / hgraphdb / HBaseGraphUtils . java <nl> ppp b / src / main / java / io / hgraphdb / HBaseGraphUtils . java <nl> - . setTimeToLive ( ttl ) ; <nl> tableDescriptor . addFamily ( columnDescriptor ) ; <nl> int regionCount = config . getRegionCount ( ) ; <nl> - admin . createTable ( tableDescriptor , getStartKey ( regionCount ) , getEndKey ( regionCount ) , regionCount ) ; <nl> + if ( regionCount & lt ; = 1 ) { <nl> + admin . createTable ( tableDescriptor ) ; <nl> + } else { <nl> + admin . createTable ( tableDescriptor , getStartKey ( regionCount ) , getEndKey ( regionCount ) , regionCount ) ; <nl> + } <nl> } <nl> - <nl> - public static void dropTables ( HBaseGraphConfiguration config , Connection conn ) { <nl> 
mmm a / spring - test / src / test / java / org / springframework / test / web / reactive / server / samples / ResponseEntityTests . java <nl> ppp b / spring - test / src / test / java / org / springframework / test / web / reactive / server / samples / ResponseEntityTests . java <nl> + this . client . get ( ) . uri ( " / persons " ) <nl> . exchange ( ) <nl> - . decodeAndCollect ( Person . class ) <nl> - . assertThat ( ) <nl> - . status ( ) . isOk ( ) <nl> - . header ( ) . contentTypeEquals ( MediaType . APPLICATION_JSON_UTF8 ) <nl> - . bodyEquals ( Arrays . asList ( new Person ( " Jane " ) , new Person ( " Jason " ) , new Person ( " John " ) ) ) ; <nl> + . expectStatus ( ) . isOk ( ) <nl> + . expectHeader ( ) . contentTypeEquals ( MediaType . APPLICATION_JSON_UTF8 ) <nl> + . expectBody ( Person . class ) . list ( ) . isEqualTo ( expected ) ; <nl> } <nl> 
mmm a / Android / LuaViewSDK / src / com / taobao / luaview / fun / mapper / ui / UITextViewMethodMapper . java <nl> ppp b / Android / LuaViewSDK / src / com / taobao / luaview / fun / mapper / ui / UITextViewMethodMapper . java <nl> } <nl>  <nl> public LuaValue getTextColor ( U view , Varargs varargs ) { <nl> - return valueOf ( view . getTextColor ( ) ) ; <nl> + return valueOf ( ColorUtil . getHexColor ( view . getTextColor ( ) ) ) ; <nl> } <nl> 
mmm a / test / integration - tests / src / test / java / org / springframework / ldap / itest / LdapTemplateModifyITest . java <nl> ppp b / test / integration - tests / src / test / java / org / springframework / ldap / itest / LdapTemplateModifyITest . java <nl> tested . modifyAttributes ( PERSON4_DN , mods ) ; <nl>  <nl> DirContextAdapter result = ( DirContextAdapter ) tested . lookup ( PERSON4_DN ) ; <nl> - String [ ] attributes = result . getStringAttributes ( " description " ) ; <nl> - assertEquals ( 2 , attributes . length ) ; <nl> - assertEquals ( " Some other description " , attributes [ 0 ] ) ; <nl> - assertEquals ( " Another description " , attributes [ 1 ] ) ; <nl> + List & lt ; String & gt ; attributes = Arrays . asList ( result . getStringAttributes ( " description " ) ) ; <nl> + assertEquals ( 2 , attributes . size ( ) ) ; <nl> + assertTrue ( attributes . contains ( " Some other description " ) ) ; <nl> + assertTrue ( attributes . contains ( " Another description " ) ) ; <nl> 
mmm a / src / org / rascalmpl / library / experiments / Compiler / RVM / Interpreter / RVMonJVM . java <nl> ppp b / src / org / rascalmpl / library / experiments / Compiler / RVM / Interpreter / RVMonJVM . java <nl> - @ Override <nl> public IValue executeRVMFunctionInVisit ( Frame root ) { <nl> root . sp = root . function . getNlocals ( ) ; /  / TODO : should be done at frame creation . <nl> - dynRun ( root . function . funId , root ) ; <nl> - <nl> - if ( returnValue instanceof Thrown ) { <nl> - frameObserver . exception ( root , ( Thrown ) returnValue ) ; <nl> + try { <nl> + root . function . handle . invoke ( this , root ) ; <nl> + } catch ( Throwable e ) { <nl> + if ( e instanceof Thrown ) { <nl> + throw ( Thrown ) e ; <nl> 
mmm a / src / main / java / com / jetbrains / jetpad / vclang / core / expr / visitor / FindBindingVisitor . java <nl> ppp b / src / main / java / com / jetbrains / jetpad / vclang / core / expr / visitor / FindBindingVisitor . java <nl> @ Override <nl> - public Boolean visitLam ( LamExpression expr , Void params ) { <nl> - return visitDependentLink ( expr . getParameters ( ) ) || expr . getBody ( ) . accept ( this , null ) ; <nl> + public Referable visitLam ( LamExpression expr , Void params ) { <nl> + Referable result = visitDependentLink ( expr . getParameters ( ) ) ; <nl> + return result ! = null ? result : expr . getBody ( ) . accept ( this , null ) ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / catalog / spatial / registry / registry - schema - bindings / src / test / java / org / codice / ddf / registry / schemabindings / helper / InternationalStringTypeHelperTest . java <nl> ppp b / catalog / spatial / registry / registry - schema - bindings / src / test / java / org / codice / ddf / registry / schemabindings / helper / InternationalStringTypeHelperTest . java <nl> - @ Test <nl> public void testGetStringWithNoMatchingLocale ( ) throws Exception { <nl> InternationalStringType ist = getTestInternationalStringType ( ) ; <nl> - istHelper . setLocale ( Locale . CHINA ) ; <nl> + if ( Locale . getDefault ( ) == Locale . CHINA ) { <nl> + istHelper . setLocale ( Locale . KOREA ) ; <nl> + } else { <nl> + istHelper . setLocale ( Locale . CHINA ) ; <nl> + } <nl>  <nl> String istString = istHelper . getString ( ist ) ; <nl> - assertThat ( istString , is ( equalTo ( EMPTY_STRING ) ) ) ; <nl> 
mmm a / src / main / java / redis / clients / jedis / Jedis . java <nl> ppp b / src / main / java / redis / clients / jedis / Jedis . java <nl> public Set & lt ; Tuple & gt ; zrevrangeByScoreWithScores ( final String key , final double max , final double min ) { <nl> checkIsInMulti ( ) ; <nl> client . zrevrangeByScoreWithScores ( key , max , min ) ; <nl> - Set & lt ; Tuple & gt ; set = getTupledSet ( ) ; <nl> - return set ; <nl> + return getTupledSet ( ) ; <nl> } <nl>  <nl> public Set & lt ; Tuple & gt ; zrevrangeByScoreWithScores ( final String key , final double max , <nl> 
mmm a / src / main / java / org / jboss / logmanager / handlers / SslTcpOutputStream . java <nl> ppp b / src / main / java / org / jboss / logmanager / handlers / SslTcpOutputStream . java <nl> - public class SslTcpOutputStream extends TcpOutputStream implements FlushableCloseable { <nl> - <nl> + * @ throws IOException if an I / O error occurs when creating the socket <nl> + * / <nl> public SslTcpOutputStream ( final InetAddress address , final int port ) throws IOException { <nl> - super ( SSLSocketFactory . getDefault ( ) . createSocket ( address , port ) ) ; <nl> + super ( SSLSocketFactory . getDefault ( ) , address , port ) ; <nl> } <nl> - } <nl> + <nl> + / ** <nl> + * Creates a SSL TCP output stream . <nl> 
mmm a / server / src / nl / tue / id / oocsi / server / model / Channel . java <nl> ppp b / server / src / nl / tue / id / oocsi / server / model / Channel . java <nl> public void addChannel ( Channel channel ) { <nl> if ( ! token . equals ( channel . getName ( ) ) & & ! subChannels . containsKey ( channel . getName ( ) ) ) { <nl> subChannels . put ( channel . getName ( ) , channel ) ; <nl> - OOCSIServer . logConnection ( token , channel . getName ( ) , " added channel " , new Date ( ) ) ; <nl> + if ( ! isPrivate ( ) ) { <nl> + OOCSIServer . logConnection ( token , channel . getName ( ) , " added channel " , new Date ( ) ) ; <nl> + } <nl> } <nl> } <nl> 
mmm a / pippo - core / src / main / java / ro / pippo / core / route / DefaultRouter . java <nl> ppp b / pippo - core / src / main / java / ro / pippo / core / route / DefaultRouter . java <nl> - public List & lt ; Route & gt ; getRoutes ( String requestMethod ) { <nl> - List & lt ; Route & gt ; routes = cache . get ( requestMethod ) ; <nl> - if ( routes ! = null ) { <nl> - routes = Collections . unmodifiableList ( routes ) ; <nl> - } else { <nl> - routes = Collections . emptyList ( ) ; <nl> - } <nl> + allRoutes . addAll ( getCompiledRoutes ( requestMethod ) ) ; <nl>  <nl> - return routes ; <nl> + return Collections . unmodifiableList ( allRoutes ) ; <nl> } <nl>  <nl> - protected void validateRoute ( Route route ) { <nl> + @ Override <nl> 
mmm a / aem - mock / src / main / java / io / wcm / testing / mock / aem / MockPage . java <nl> ppp b / aem - mock / src / main / java / io / wcm / testing / mock / aem / MockPage . java <nl> if ( type == Resource . class ) { <nl> return ( AdapterType ) this . resource ; <nl> } <nl> - return super . adaptTo ( type ) ; <nl> - } <nl> + AdapterType result = super . adaptTo ( type ) ; <nl> + if ( result == null ) { <nl> + result = this . resource . adaptTo ( type ) ; <nl> + } <nl> + return result ; <nl> 
mmm a / co . codewizards . cloudstore . core / src / main / java / co / codewizards / cloudstore / core / config / ConfigImpl . java <nl> ppp b / co . codewizards . cloudstore . core / src / main / java / co / codewizards / cloudstore / core / config / ConfigImpl . java <nl> - if ( isDirectory ) { <nl> - return new File [ ] { <nl> - createFile ( file , PROPERTIES_FILE_NAME_FOR_DIRECTORY_HIDDEN ) , <nl> - createFile ( file , PROPERTIES_FILE_NAME_FOR_DIRECTORY_VISIBLE ) , <nl> - createFile ( file , PROPERTIES_FILE_NAME_FOR_DIRECTORY_LOCAL ) /  / overrides the settings of the shared file ! <nl> - } ; <nl> + files . add ( createFile ( metaDir , PROPERTIES_FILE_NAME_PARENT ) ) ; <nl> + <nl> + files . add ( createFile ( file , PROPERTIES_FILE_NAME_FOR_DIRECTORY ) ) ; <nl> + files . add ( createFile ( file , PROPERTIES_FILE_NAME_FOR_DIRECTORY_VISIBLE ) ) ; <nl> + files . add ( createFile ( file , PROPERTIES_FILE_NAME_FOR_DIRECTORY_LOCAL ) ) ; /  / overrides the settings of the shared file ! <nl> + return files . toArray ( new File [ files . size ( ) ] ) ; <nl> } <nl> 
mmm a / src / main / java / ru / yandex / qatools / allure / cucumberjvm / AllureRunListener . java <nl> ppp b / src / main / java / ru / yandex / qatools / allure / cucumberjvm / AllureRunListener . java <nl> - if ( description . isTest ( ) ) { <nl> - String methodName = extractMethodName ( description ) ; <nl> TestCaseStartedEvent event = new TestCaseStartedEvent ( getSuiteUid ( description ) , methodName ) ; <nl> - AnnotationManager am = new AnnotationManager ( description . getAnnotations ( ) ) ; <nl> - am . update ( event ) ; <nl> - getLifecycle ( ) . fire ( event ) ; <nl> - } <nl> + <nl> + Collection & lt ; Annotation & gt ; annotations = new ArrayList & lt ; & gt ; ( ) ; <nl> + for ( Annotation annotation : description . getAnnotations ( ) ) { <nl> + annotations . add ( annotation ) ; <nl> + } <nl> + <nl> + Title title = getTitleAnnotation ( description . getDisplayName ( ) ) ; <nl> 
mmm a / src / org / yaxim / androidclient / service / GenericService . java <nl> ppp b / src / org / yaxim / androidclient / service / GenericService . java <nl> mNotification = new NotificationCompat . Builder ( this ) <nl> . setContentTitle ( title ) <nl> . setContentText ( message ) <nl> + . setStyle ( new NotificationCompat . BigTextStyle ( ) . bigText ( message ) ) <nl> . setTicker ( ticker ) <nl> . setSmallIcon ( R . drawable . sb_message ) <nl> . setCategory ( Notification . CATEGORY_MESSAGE ) <nl> 
mmm a / src / main / java / org / icij / extract / tasks / TagTask . java <nl> ppp b / src / main / java / org / icij / extract / tasks / TagTask . java <nl> logger . info ( String . format ( " Processed a total of % d documents . " , processed ) ) ; <nl> logger . info ( String . format ( " Tagged % d documents . " , consumer . getConsumeCount ( ) ) ) ; <nl>  <nl> - if ( options . get ( " soft - commit " ) . on ( ) ) { <nl> + if ( options . get ( " soft - commit " ) . parse ( ) . isOn ( ) ) { <nl> client . commit ( true , true , true ) ; <nl> - } else if ( options . get ( " commit " ) . on ( ) ) { <nl> + } else if ( options . get ( " commit " ) . parse ( ) . isOn ( ) ) { <nl> client . commit ( true , true , false ) ; <nl> } <nl> 
mmm a / library / src / main / java / com / google / android / media / tv / companionlibrary / service / BaseTvInputService . java <nl> ppp b / library / src / main / java / com / google / android / media / tv / companionlibrary / service / BaseTvInputService . java <nl> + ContentResolver resolver = mContext . getContentResolver ( ) ; <nl> Program program = TvContractUtils . getCurrentProgram ( resolver , mChannelUri ) ; <nl> if ( program ! = null ) { <nl> - List & lt ; Advertisement & gt ; ads = InternalProviderDataUtil <nl> - . parseAds ( program . getInternalProviderData ( ) ) ; <nl> - Collections . sort ( ads ) ; <nl> - long currentTimeMs = System . currentTimeMillis ( ) ; <nl> - for ( Advertisement ad : ads ) { <nl> + if ( program . getInternalProviderData ( ) ! = null ) { <nl> + List & lt ; Advertisement & gt ; ads = program . getInternalProviderData ( ) . getAds ( ) ; <nl> + Collections . sort ( ads ) ; <nl> + long currentTimeMs = System . currentTimeMillis ( ) ; <nl> + for ( Advertisement ad : ads ) { <nl> 
mmm a / src / main / java / fr / pilato / elasticsearch / crawler / fs / client / ElasticsearchClient . java <nl> ppp b / src / main / java / fr / pilato / elasticsearch / crawler / fs / client / ElasticsearchClient . java <nl> - logger . trace ( " { } " , sbf ) ; <nl> + Map & lt ; String , String & gt ; params ; <nl> + <nl> + if ( pipeline ! = null ) { <nl> + params = new HashMap & lt ; & gt ; ( 1 ) ; <nl> + params . put ( " pipeline " , pipeline ) ; <nl> + } else { <nl> + params = Collections . emptyMap ( ) ; <nl> + } <nl>  <nl> StringEntity entity = new StringEntity ( sbf . toString ( ) , Charset . defaultCharset ( ) ) ; <nl> - Response restResponse = client . performRequest ( " POST " , " / _bulk " , Collections . emptyMap ( ) , entity ) ; <nl> - BulkResponse response = JsonUtil . deserialize ( restResponse , BulkResponse . class ) ; <nl> - logger . debug ( " bulk response : { } " , response ) ; <nl> - return response ; <nl> 
mmm a / app / src / main / java / com / kyletung / simplebookmovie / client / request / AccountClient . java <nl> ppp b / app / src / main / java / com / kyletung / simplebookmovie / client / request / AccountClient . java <nl> + * @ param code AuthorizationCode <nl> + * / <nl> + public Observable & lt ; LoginData & gt ; getToken ( String code ) { <nl> + return mAccountApi . getToken ( <nl> + Constants . APP_KEY , <nl> + Constants . APP_SECRET , <nl> REQUEST_REDIRECT_URI_MINE , <nl> REQUEST_GRANT_TYPE_GET , <nl> code <nl> - ) . enqueue ( newCallback ( responseImpl ) ) ; <nl> + ) . compose ( flatResult ( ) ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / ui - tests / src / test / java / org / openmrs / reference / AddDiagnosisToVisitNoteTest . java <nl> ppp b / ui - tests / src / test / java / org / openmrs / reference / AddDiagnosisToVisitNoteTest . java <nl> @ Category ( BuildTests . class ) <nl> public void AddDiagnosisToVisitNoteTest ( ) throws Exception { <nl>  <nl> - activeVisitsPage = homePage . goToActiveVisitsSearch ( ) ; <nl> + ActiveVisitsPage activeVisitsPage = homePage . goToActiveVisitsSearch ( ) ; <nl> activeVisitsPage . search ( patient . identifier ) ; <nl>  <nl> - patientDashboardPage = activeVisitsPage . goToPatientDashboardOfLastActiveVisit ( ) ; <nl> - visitNotePage = patientDashboardPage . goToVisitNote ( ) ; <nl> + ClinicianFacingPatientDashboardPage patientDashboardPage = activeVisitsPage . goToPatientDashboardOfLastActiveVisit ( ) ; <nl> + VisitNotePage visitNotePage = patientDashboardPage . goToVisitNote ( ) ; <nl> visitNotePage . enterDiagnosis ( " Pne " ) ; <nl> visitNotePage . enterSecondaryDiagnosis ( " Bleed " ) ; <nl> 
mmm a / org . eclipse . virgo . web . war . deployer / src / main / java / org / eclipse / virgo / web / war / deployer / WARDeployer . java <nl> ppp b / org . eclipse . virgo . web . war . deployer / src / main / java / org / eclipse / virgo / web / war / deployer / WARDeployer . java <nl> - logger . error ( " Can not start deployable with URI + [ " + uri + " ] . There is no bundle installed with this URI . " ) ; <nl> - return false ; <nl> - } <nl> - final String warName = extractDecodedWarNameFromString ( uri . toString ( ) ) ; <nl> - StatusFileModificator . deleteStatusFile ( warName , this . pickupDir ) ; <nl> - final long lastModified = new File ( uri ) . lastModified ( ) ; <nl> - this . eventLogger . log ( WARDeployerLogEvents . NANO_WEB_STARTING , bundle . getSymbolicName ( ) , bundle . getVersion ( ) ) ; <nl> + @ Override <nl> + public boolean start ( URI uri ) { <nl> + String extractionFolderName = WebBundleUtils . calculateCorrectSymbolicName ( extractDecodedWarNameFromString ( uri . toString ( ) ) ) ; <nl> + Bundle bundle = getInstalledBundle ( extractionFolderName ) ; <nl> + if ( bundle == null ) { <nl> + this . eventLogger . log ( WARDeployerLogEvents . NANO_STARTING_ERROR , uri ) ; <nl> 
mmm a / src / main / java / eu / hansolo / medusa / skins / GaugeSkin . java <nl> ppp b / src / main / java / eu / hansolo / medusa / skins / GaugeSkin . java <nl> - } else if ( " LCD " . equals ( EVENT_TYPE ) ) { <nl> - if ( getSkinnable ( ) . isLcdVisible ( ) ) redraw ( ) ; <nl> - } else if ( " RECALC " . equals ( EVENT_TYPE ) ) { <nl> - if ( getSkinnable ( ) . isAutoScale ( ) ) getSkinnable ( ) . calcAutoScale ( ) ; <nl> - startAngle = getSkinnable ( ) . getStartAngle ( ) ; <nl> - angleRange = getSkinnable ( ) . getAngleRange ( ) ; <nl> - angleStep = getSkinnable ( ) . getAngleStep ( ) ; <nl> + if ( getSkinnable ( ) . getValue ( ) & gt ; maxValue ) { oldValue = maxValue ; } <nl> + resize ( ) ; <nl> + redraw ( ) ; <nl> + rotateNeedle ( getSkinnable ( ) . getCurrentValue ( ) ) ; <nl> + } else if ( " SECTION " . equals ( EVENT_TYPE ) ) { <nl> + sections = getSkinnable ( ) . getSections ( ) ; <nl> + highlightSections = getSkinnable ( ) . isHighlightSections ( ) ; <nl> 
mmm a / app / src / main / java / com / waz / zclient / pages / BasePreferenceFragment . java <nl> ppp b / app / src / main / java / com / waz / zclient / pages / BasePreferenceFragment . java <nl> @ Override <nl> public final IStoreFactory getStoreFactory ( ) { <nl> - return getActivity ( ) ! = null ? ZApplication . from ( getActivity ( ) ) . getStoreFactory ( ) : null ; <nl> + return getActivity ( ) ! = null ? ( ( WireApplication ) getActivity ( ) . getApplication ( ) ) . storeFactory ( ) : null ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / ardor3d - jogl / src / main / java / com / ardor3d / scene / state / jogl / JoglShaderObjectsStateUtil . java <nl> ppp b / ardor3d - jogl / src / main / java / com / ardor3d / scene / state / jogl / JoglShaderObjectsStateUtil . java <nl> - final IntBuffer compiled = BufferUtils . createIntBuffer ( 1 ) ; <nl> - gl . getGL2 ( ) . glGetObjectParameterivARB ( programId , GL2ES2 . GL_LINK_STATUS , compiled ) ; <nl> + } <nl> + } <nl> if ( compiled . get ( 0 ) == GL . GL_FALSE ) { <nl> - gl . getGL2 ( ) . glGetObjectParameterivARB ( programId , GL2ES2 . GL_INFO_LOG_LENGTH , compiled ) ; <nl> - final int length = compiled . get ( 0 ) ; <nl> - String out = null ; <nl> - if ( length & gt ; 0 ) { <nl> + if ( gl . isGL2 ( ) ) { <nl> + gl . getGL2 ( ) . glGetObjectParameterivARB ( programId , GL2ES2 . GL_INFO_LOG_LENGTH , compiled ) ; <nl> + } else { <nl> + if ( gl . isGL2ES2 ( ) ) { <nl> + } <nl> + } <nl> 
mmm a / src / main / java / com / jjoe64 / graphview / series / LineGraphSeries . java <nl> ppp b / src / main / java / com / jjoe64 / graphview / series / LineGraphSeries . java <nl> - } <nl> - <nl> mPath . moveTo ( startXAnimated , startY ) ; <nl> - mPath . lineTo ( endXAnimated , endY ) ; <nl> - } <nl>  <nl> - if ( mStyles . drawBackground ) { <nl> + if ( Math . abs ( endX - lastRenderedX ) & gt ; . 3f ) { <nl> + if ( mDrawAsPath ) { <nl> + mPath . lineTo ( endXAnimated , endY ) ; <nl> + } else { <nl> + renderLine ( canvas , new float [ ] { startXAnimated , startY , endXAnimated , endY } ) ; <nl> + } <nl> 
mmm a / sdk / src / main / java / com / braunster / chatsdk / dao / BMessageDao . java <nl> ppp b / sdk / src / main / java / com / braunster / chatsdk / dao / BMessageDao . java <nl> - entity . setResourcesPath ( cursor . isNull ( offset + 4 ) ? null : cursor . getString ( offset + 4 ) ) ; <nl> - entity . setText ( cursor . getString ( offset + 5 ) ) ; <nl> - entity . setType ( cursor . getInt ( offset + 6 ) ) ; <nl> - entity . setOwnerThread ( cursor . isNull ( offset + 7 ) ? null : cursor . getString ( offset + 7 ) ) ; <nl> - entity . setSender ( cursor . isNull ( offset + 8 ) ? null : cursor . getString ( offset + 8 ) ) ; <nl> + entity . setDate ( new java . util . Date ( cursor . getLong ( offset + 2 ) ) ) ; <nl> + entity . setDirty ( cursor . isNull ( offset + 3 ) ? null : cursor . getShort ( offset + 3 ) ! = 0 ) ; <nl> + entity . setResources ( cursor . isNull ( offset + 4 ) ? null : cursor . getString ( offset + 4 ) ) ; <nl> + entity . setResourcesPath ( cursor . isNull ( offset + 5 ) ? null : cursor . getString ( offset + 5 ) ) ; <nl> + entity . setText ( cursor . getString ( offset + 6 ) ) ; <nl> + entity . setType ( cursor . getInt ( offset + 7 ) ) ; <nl> + entity . setOwnerThread ( cursor . isNull ( offset + 8 ) ? null : cursor . getLong ( offset + 8 ) ) ; <nl> + entity . setSender ( cursor . isNull ( offset + 9 ) ? null : cursor . getLong ( offset + 9 ) ) ; <nl> } <nl>  <nl> 
mmm a / plugins / org . eclipse . emf . cdo . server / src / org / eclipse / emf / cdo / internal / server / Repository . java <nl> ppp b / plugins / org . eclipse . emf . cdo . server / src / org / eclipse / emf / cdo / internal / server / Repository . java <nl> - branchManager . setBranchLoader ( this ) ; <nl> + revisionManager . setRevisionLoader ( this ) ; <nl> + } <nl>  <nl> - revisionManager . setRevisionLoader ( this ) ; <nl> - sessionManager . setRepository ( this ) ; <nl> - queryManager . setRepository ( this ) ; <nl> - commitInfoManager . setRepository ( this ) ; <nl> - commitInfoManager . setCommitInfoLoader ( this ) ; <nl> + if ( sessionManager . getRepository ( ) == null ) <nl> + { <nl> + sessionManager . setRepository ( this ) ; <nl> + } <nl> + <nl> + if ( queryManager . getRepository ( ) == null ) <nl> 
mmm a / app / src / main / java / com / jrummyapps / packagemanager / fragments / InstallerFragment . java <nl> ppp b / app / src / main / java / com / jrummyapps / packagemanager / fragments / InstallerFragment . java <nl> + if ( binary . path . startsWith ( " http " ) ) { <nl> File destination = new File ( getActivity ( ) . getCacheDir ( ) , binary . name + " / " + binary . filename ) ; <nl> - <nl> - Download download = new Download . Builder ( binary . path ) <nl> - . setDestination ( destination ) <nl> - . setShouldRedownload ( false ) <nl> - . setMd5sum ( binary . md5sum ) <nl> - . build ( ) ; <nl> + if ( destination . exists ( ) & & destination . length ( ) == binary . size ) { <nl> + Installer installer = new Installer . Builder ( ) <nl> + . setFilename ( binary . filename ) <nl> + . setBinary ( new AFile ( destination ) ) <nl> + . setPath ( path ) <nl> + . setSymlink ( true ) <nl> + . setOverwrite ( false ) <nl> + . create ( ) ; <nl> + new Thread ( installer ) . start ( ) ; <nl> + } else { <nl> + download = new Download . Builder ( binary . path ) <nl> + . setDestination ( destination ) <nl> + . setFilename ( binary . filename ) <nl> + . setShouldRedownload ( true ) <nl> + . setMd5sum ( binary . md5sum ) <nl> + . build ( ) ; <nl> 
mmm a / app / src / main / java / com / money / manager / ex / search / SearchParametersFragment . java <nl> ppp b / app / src / main / java / com / money / manager / ex / search / SearchParametersFragment . java <nl> if ( searchParameters . dateFrom ! = null ) { <nl> - where . addStatement ( QueryAllData . Date , " & gt ; = " , MmxDateTimeUtils . getIsoStringFrom ( searchParameters . dateFrom . toDate ( ) ) ) ; <nl> + where . addStatement ( QueryAllData . Date , " & gt ; = " , new MmxDate ( searchParameters . dateFrom ) . toIsoString ( ) ) ; <nl> } <nl> if ( searchParameters . dateTo ! = null ) { <nl> 
mmm a / opendaylight / md - sal / sal - distributed - datastore / src / test / java / org / opendaylight / controller / cluster / datastore / entityownership / DistributedEntityOwnershipIntegrationTest . java <nl> ppp b / opendaylight / md - sal / sal - distributed - datastore / src / test / java / org / opendaylight / controller / cluster / datastore / entityownership / DistributedEntityOwnershipIntegrationTest . java <nl> + boolean passed = false ; <nl> for ( int i = 0 ; i & lt ; 100 ; i++ ) { <nl> Uninterruptibles . sleepUninterruptibly ( 50 , TimeUnit . MILLISECONDS ) ; <nl> - if ( ! leaderEntityOwnershipService . getOwnershipState ( ENTITY1 ) . isPresent ( ) <nl> - || leaderEntityOwnershipService . getOwnershipState ( ENTITY1 ) . get ( ) == EntityOwnershipState . NO_OWNER <nl> - & & follower1EntityOwnershipService . getOwnershipState ( ENTITY1 ) . isPresent ( ) <nl> - & & follower1EntityOwnershipService . getOwnershipState ( ENTITY1 ) <nl> - . get ( ) == EntityOwnershipState . NO_OWNER <nl> - & & follower2EntityOwnershipService . getOwnershipState ( ENTITY1 ) . isPresent ( ) <nl> + final Optional & lt ; EntityOwnershipState & gt ; leaderState = leaderEntityOwnershipService . getOwnershipState ( ENTITY1 ) ; <nl> + final Optional & lt ; EntityOwnershipState & gt ; follower1State = <nl> + follower1EntityOwnershipService . getOwnershipState ( ENTITY1 ) ; <nl> + final Optional & lt ; EntityOwnershipState & gt ; follower2State = <nl> 
mmm a / src / fourthline / mabiicco / midi / MabiDLS . java <nl> ppp b / src / fourthline / mabiicco / midi / MabiDLS . java <nl> 0 ) ; <nl> track . add ( new MidiEvent ( pcMessage , 0 ) ) ; <nl> boolean enablePart [ ] = InstClass . getEnablePartByProgram ( program ) ; <nl> - InstType instType = getInstByProgram ( mmlTrack . getProgram ( ) ) . getType ( ) ; <nl> + InstClass instClass = getInstByProgram ( mmlTrack . getProgram ( ) ) ; <nl>  <nl> MMLMidiTrack midiTrack = new MMLMidiTrack ( mmlTrack . getGlobalTempoList ( ) ) ; <nl> for ( int i = 0 ; i & lt ; enablePart . length ; i++ ) { <nl> 
mmm a / 1 . 7 . 10 / src / main / java / net / geforcemods / securitycraft / gui / GuiSCManual . java <nl> ppp b / 1 . 7 . 10 / src / main / java / net / geforcemods / securitycraft / gui / GuiSCManual . java <nl> this . drawTexturedModalRect ( k , 5 , 0 , 0 , 256 , 250 ) ; <nl>  <nl> if ( this . currentPage & gt ; - 1 ) { <nl> - this . fontRendererObj . drawString ( mod_SecurityCraft . instance . manualPages . get ( currentPage ) . getItemName ( ) , k + 39 , 27 , 0 , false ) ; <nl> + this . fontRendererObj . drawString ( StatCollector . translateToLocal ( mod_SecurityCraft . instance . manualPages . get ( currentPage ) . getItem ( ) . getUnlocalizedName ( ) + " . name " ) , k + 39 , 27 , 0 , false ) ; <nl> this . fontRendererObj . drawSplitString ( mod_SecurityCraft . instance . manualPages . get ( currentPage ) . getHelpInfo ( ) , k + 18 , 45 , 225 , 0 ) ; <nl> } else { <nl> this . fontRendererObj . drawString ( StatCollector . translateToLocal ( " gui . scManual . intro . 1 " ) , k + 39 , 27 , 0 , false ) ; <nl> 
mmm a / modules / unsupported / mbstyle / src / main / java / org / geotools / mbstyle / parse / MBObjectParser . java <nl> ppp b / modules / unsupported / mbstyle / src / main / java / org / geotools / mbstyle / parse / MBObjectParser . java <nl> - * / <nl> - public static Expression percentage ( JSONObject json , String tag , Number fallback ) throws MBFormatException { <nl> - if ( json . get ( tag ) == null ) { <nl> - return ff . literal ( fallback ) ; <nl> + public static Expression percentage ( JSONObject json , String tag , Number fallback ) <nl> + throws MBFormatException { <nl> + if ( json == null ) { <nl> + return fallback == null ? null : ff . literal ( fallback ) ; <nl> } <nl> Object obj = json . get ( tag ) ; <nl> - <nl> 
mmm a / ttt - ttpe / src / main / java / com / skynav / ttpe / app / Presenter . java <nl> ppp b / ttt - ttpe / src / main / java / com / skynav / ttpe / app / Presenter . java <nl> return null ; <nl> } <nl> if ( d . exists ( ) ) { <nl> - String outputFileName = MessageFormat . format ( outputPatternISD , ++outputFileSequenceISD ) ; <nl> + String outputFileName = outputPatternISDFormatter . format ( new Object [ ] { Integer . valueOf ( ++outputFileSequenceISD ) } ) ; <nl> File outputFile = new File ( d , outputFileName ) . getCanonicalFile ( ) ; <nl> if ( retOutputFile ! = null ) <nl> retOutputFile [ 0 ] = outputFile ; <nl> 
mmm a / dalesbred / src / test / java / org / dalesbred / internal / instantiation / ConversionMapTest . java <nl> ppp b / dalesbred / src / test / java / org / dalesbred / internal / instantiation / ConversionMapTest . java <nl> @ Test <nl> public void searchBasedOnResultCovariance ( ) { <nl> - TypeConversion conversion = dummyConversion ( Integer . class , String . class ) ; <nl> - registry . register ( conversion ) ; <nl> + TypeConversion conversion = dummyConversion ( ) ; <nl> + registry . register ( Integer . class , String . class , conversion ) ; <nl>  <nl> assertSame ( conversion , registry . findConversion ( Integer . class , Object . class ) . orElse ( null ) ) ; <nl> } <nl> 
mmm a / core / src / main / java / com / tickaroo / tikxml / XmlReader . java <nl> ppp b / core / src / main / java / com / tickaroo / tikxml / XmlReader . java <nl> - * / <nl> - public double nextTextContentAsDouble ( ) throws IOException { <nl> - return Double . parseDouble ( nextTextContent ( ) ) ; <nl> - } <nl>  <nl> - / ** <nl> + String content = nextTextContent ( ) ; <nl> + if ( content . equals ( " " ) ) { <nl> + return 0 ; <nl> + } <nl> + <nl> + return Double . parseDouble ( content ) ; <nl> 
mmm a / src / test / java / com / wikia / webdriver / testcases / visualeditor / text / VisualEditorEditingTests . java <nl> ppp b / src / test / java / com / wikia / webdriver / testcases / visualeditor / text / VisualEditorEditingTests . java <nl> ve . typeTextInAllFormat ( text ) ; <nl> ve . typeTextInAllStyle ( text ) ; <nl> ve . typeTextInAllList ( text ) ; <nl> - ve . clickPublishButton ( ) ; <nl> - ArticlePageObject article = new ArticlePageObject ( ) ; <nl> + VisualEditorSaveChangesDialog saveDialog = ve . clickPublishButton ( ) ; <nl> + VisualEditorReviewChangesDialog reviewDialog = saveDialog . clickReviewYourChanges ( ) ; <nl> + reviewDialog . verifyAddedDiffs ( wikiTexts ) ; <nl> + saveDialog = reviewDialog . clickReturnToSaveFormButton ( ) ; <nl> + ArticlePageObject article = saveDialog . savePage ( ) ; <nl> article . verifyVEPublishComplete ( ) ; <nl> article . verifyContent ( " Lorem ipsum dolor sit amet , consectetur adipiscing elit . " ) ; <nl> 
mmm a / Misc / ThutEssentials / src / main / java / thut / essentials / land / LandEventsHandler . java <nl> ppp b / Misc / ThutEssentials / src / main / java / thut / essentials / land / LandEventsHandler . java <nl> - String owner = LandManager . getInstance ( ) . getLandOwner ( c ) ; <nl> + LandTeam owner = LandManager . getInstance ( ) . getLandOwner ( c ) ; <nl> if ( owner == null || evt . getItemStack ( ) . getItem ( ) instanceof ItemFood || ! ConfigManager . INSTANCE . landEnabled ) <nl> return ; <nl> - LandTeam playerTeam = LandManager . getTeam ( evt . getEntityPlayer ( ) ) ; <nl> - String team = playerTeam . teamName ; <nl> - if ( owner . equals ( team ) ) <nl> + if ( LandManager . owns ( evt . getEntityPlayer ( ) , c ) ) <nl> { <nl> return ; <nl> } <nl> 
mmm a / sqldelight - gradle - plugin / src / test / fixtures / works - fine - as - library / expected / com / test / UserModel . java <nl> ppp b / sqldelight - gradle - plugin / src / test / fixtures / works - fine - as - library / expected / com / test / UserModel . java <nl> cursor . isNull ( cursor . getColumnIndex ( MIDDLE_INITIAL ) ) ? null : cursor . getString ( cursor . getColumnIndex ( MIDDLE_INITIAL ) ) , <nl> cursor . getString ( cursor . getColumnIndex ( LAST_NAME ) ) , <nl> cursor . getInt ( cursor . getColumnIndex ( AGE ) ) , <nl> - User . Gender . valueOf ( cursor . getString ( cursor . getColumnIndex ( GENDER ) ) ) <nl> + genderAdapter . map ( cursor , cursor . getColumnIndex ( GENDER ) ) <nl> ) ; <nl> } <nl>  <nl> 
mmm a / cepheus - ngsi / src / test / java / com / orange / ngsi / server / NgsiBaseControllerTest . java <nl> ppp b / cepheus - ngsi / src / test / java / com / orange / ngsi / server / NgsiBaseControllerTest . java <nl> NotifyContext notifyContext = createNotifyContextTempSensor ( 0 ) ; <nl> notifyContext . setSubscriptionId ( null ) ; <nl>  <nl> - mockMvc . perform ( post ( " / ni / notifyContext " ) . content ( json ( jsonConverter , notifyContext ) ) . contentType ( MediaType . APPLICATION_JSON ) ) <nl> + mockMvc . perform ( post ( " / ni / notifyContext " ) . content ( json ( jsonConverter , notifyContext ) ) . contentType ( MediaType . APPLICATION_JSON ) . header ( " Host " , " localhost " ) . accept ( MediaType . APPLICATION_JSON ) ) <nl> . andExpect ( status ( ) . isOk ( ) ) <nl> . andExpect ( MockMvcResultMatchers . jsonPath ( " $ . responseCode . code " ) . value ( CodeEnum . CODE_471 . getLabel ( ) ) ) <nl> . andExpect ( MockMvcResultMatchers . jsonPath ( " $ . responseCode . reasonPhrase " ) . value ( CodeEnum . CODE_471 . getShortPhrase ( ) ) ) <nl> 
mmm a / appcore / src / main / java / mobi / cangol / mobile / db / DatabaseUtils . java <nl> ppp b / appcore / src / main / java / mobi / cangol / mobile / db / DatabaseUtils . java <nl> Object value=null ; <nl> for ( Field field : obj . getClass ( ) . getDeclaredFields ( ) ) { <nl> field . setAccessible ( true ) ; <nl> - if ( field . isEnumConstant ( ) ) continue ; <nl> + if ( field . isEnumConstant ( ) ||Modifier . isFinal ( field . getModifiers ( ) ) ||Modifier . isTransient ( field . getModifiers ( ) ) ) continue ; <nl> if ( field . isAnnotationPresent ( DatabaseField . class ) ) { <nl> DatabaseField dbField = field . getAnnotation ( DatabaseField . class ) ; <nl> if ( dbField . primaryKey ( ) ==true ) { <nl> 
mmm a / enforcer - rules / src / test / java / org / apache / maven / plugins / enforcer / RequireActiveProfileTest . java <nl> ppp b / enforcer - rules / src / test / java / org / apache / maven / plugins / enforcer / RequireActiveProfileTest . java <nl> public void testTwoActiveProfilesWhereOneProfileIsRequiredToBeActivated ( ) <nl> throws EnforcerRuleException <nl> { <nl> - List & lt ; Profile & gt ; profiles = new ArrayList & lt ; Profile & gt ; ( ) ; <nl> - profiles . add ( createProfile ( " profile - 1 " ) ) ; <nl> - profiles . add ( createProfile ( " profile - 2 " ) ) ; <nl> + List & lt ; Profile & gt ; profiles = Arrays . asList ( createProfile ( " profile - 1 " ) , createProfile ( " profile - 2 " ) ) ; <nl>  <nl> when ( project . getActiveProfiles ( ) ) . thenReturn ( profiles ) ; <nl> 
mmm a / rznw / game / maincharacter / MainCharacterStepIncrementer . java <nl> ppp b / rznw / game / maincharacter / MainCharacterStepIncrementer . java <nl> mainCharacter . getSteps ( ) . setHPSteps ( mainCharacter . getSteps ( ) . getHPSteps ( ) + 1 ) ; <nl> if ( mainCharacter . getSteps ( ) . getHPSteps ( ) & gt ; = mainCharacter . getSteps ( ) . getStepsForHeal ( ) ) <nl> { <nl> - mainCharacter . heal ( 10 ) ; <nl> + int HPHealed = mainCharacter . heal ( 10 ) ; <nl> mainCharacter . getSteps ( ) . setHPSteps ( 0 ) ; <nl> + <nl> + LogRendererFactory . instance ( ) . log ( " You healed " + HPHealed + " HP via physical regeneration . " ) ; <nl> } <nl> } <nl> 
mmm a / sources / net . sf . j2s . java . org . eclipse . swt / src / org / eclipse / swt / widgets / Menu . java <nl> ppp b / sources / net . sf . j2s . java . org . eclipse . swt / src / org / eclipse / swt / widgets / Menu . java <nl> btnFocus = document . createElement ( " BUTTON " ) ; <nl> btnFocus . className = " menu - focus " ; <nl> - handle . appendChild ( btnFocus ) ; <nl> + if ( beginSpace ! = null ) { <nl> + handle . insertBefore ( btnFocus , beginSpace ) ; <nl> + } else { <nl> + handle . appendChild ( btnFocus ) ; <nl> + } <nl> hMenuKeyDown = new RunnableCompatibility ( ) { <nl> public void run ( ) { <nl> - HTMLEvent evt = ( HTMLEvent ) getEvent ( ) ; <nl> 
mmm a / sdk / src / com / constellio / app / modules / rm / model / DecommissioningListAcceptanceTest . java <nl> ppp b / sdk / src / com / constellio / app / modules / rm / model / DecommissioningListAcceptanceTest . java <nl> public void givenFoldersWithUniformRuleAndNonUniformCopyAndCategoryThenNotUniform ( ) <nl> throws Exception { <nl>  <nl> - decommissioningList = saveAndLoad ( newFilingSpaceAList ( ) . setFolderDetailsFor ( records . folders ( " A04 - A06 " ) ) ) ; <nl> + decommissioningList = saveAndLoad ( newFilingSpaceAList ( ) . setDecommissioningListType ( DecommissioningListType . FOLDERS_TO_TRANSFER ) . setFolderDetailsFor ( records . folders ( " A04 - A06 " ) ) ) ; <nl> assertThat ( decommissioningList . hasAnalogicalMedium ( ) ) . isEqualTo ( true ) ; <nl> assertThat ( decommissioningList . hasElectronicMedium ( ) ) . isEqualTo ( true ) ; <nl> assertThat ( decommissioningList . getFoldersMediaTypes ( ) ) . containsOnly ( HYBRID , HYBRID , HYBRID ) ; <nl> assertThat ( decommissioningList . getUniformRule ( ) ) . isEqualTo ( records . ruleId_1 ) ; <nl> assertThat ( decommissioningList . isUniform ( ) ) . isEqualTo ( true ) ; <nl>  <nl> - decommissioningList = saveAndLoad ( newFilingSpaceAList ( ) . setFolderDetailsFor ( records . folders ( " A04 - A06 , A16 - A18 " ) ) ) ; <nl> + decommissioningList = saveAndLoad ( newFilingSpaceAList ( ) . setDecommissioningListType ( DecommissioningListType . FOLDERS_TO_TRANSFER ) . setFolderDetailsFor ( records . folders ( " A04 - A06 , A16 - A18 " ) ) ) ; <nl> assertThat ( decommissioningList . hasAnalogicalMedium ( ) ) . isEqualTo ( true ) ; <nl> assertThat ( decommissioningList . hasElectronicMedium ( ) ) . isEqualTo ( true ) ; <nl> assertThat ( decommissioningList . getFoldersMediaTypes ( ) ) . containsOnly ( HYBRID , HYBRID , HYBRID , HYBRID , HYBRID , HYBRID ) ; <nl> 
mmm a / scim2 - sdk - client / src / main / java / com / unboundid / scim2 / client / requests / RetrieveRequestBuilder . java <nl> ppp b / scim2 - sdk - client / src / main / java / com / unboundid / scim2 / client / requests / RetrieveRequestBuilder . java <nl> public & lt ; T & gt ; T invoke ( final Class & lt ; T & gt ; cls ) throws ScimException <nl> { <nl> Response response = buildRequest ( ) . get ( ) ; <nl> - if ( response . getStatusInfo ( ) . getFamily ( ) == <nl> - Response . Status . Family . SUCCESSFUL ) <nl> - { <nl> - T entity = response . readEntity ( cls ) ; <nl> - response . close ( ) ; <nl> - return entity ; <nl> - } <nl> - else <nl> + try <nl> { <nl> + if ( response . getStatusInfo ( ) . getFamily ( ) == <nl> + Response . Status . Family . SUCCESSFUL ) <nl> + { <nl> + return response . readEntity ( cls ) ; <nl> + } <nl> + else <nl> + { <nl> 
mmm a / src / main / java / jas / spawner / refactor / configsloader / BiomeSpawnListLoader . java <nl> ppp b / src / main / java / jas / spawner / refactor / configsloader / BiomeSpawnListLoader . java <nl> + entityValueObject . addProperty ( LIVING_HANDLER_KEY , builder . getLivingHandlerID ( ) . get ( ) ) ; <nl> } <nl>  <nl> - if ( ! " " . equals ( builder . getCanSpawn ( ) ) ) { <nl> - entityValueObject . addProperty ( SPAWN_TAG_KEY , builder . getCanSpawn ( ) ) ; <nl> + if ( ! " " . equals ( builder . getCanSpawn ( ) ) & & builder . getCanSpawn ( ) . isPresent ( ) ) { <nl> + entityValueObject . addProperty ( SPAWN_TAG_KEY , builder . getCanSpawn ( ) . get ( ) ) ; <nl> } <nl> - if ( ! " " . equals ( builder . getPostSpawn ( ) ) ) { <nl> - entityValueObject . addProperty ( POSTSPAWN_KEY , builder . getPostSpawn ( ) ) ; <nl> + if ( ! " " . equals ( builder . getPostSpawn ( ) ) & & builder . getPostSpawn ( ) . isPresent ( ) ) { <nl> + entityValueObject . addProperty ( POSTSPAWN_KEY , builder . getPostSpawn ( ) . get ( ) ) ; <nl> } <nl> - if ( ! " " . equals ( builder . getEntityToSpawn ( ) ) ) { <nl> - entityValueObject . addProperty ( ENTITY_SPAWN , builder . getEntityToSpawn ( ) ) ; <nl> + tertObject . add ( tertKey , entityValueObject ) ; <nl> 
mmm a / retrofit - adapters / rxjava / src / test / java / retrofit2 / adapter / rxjava / SingleTest . java <nl> ppp b / retrofit - adapters / rxjava / src / test / java / retrofit2 / adapter / rxjava / SingleTest . java <nl> @ Test public void resultSuccess404 ( ) throws IOException { <nl> server . enqueue ( new MockResponse ( ) . setResponseCode ( 404 ) . setBody ( " Hi " ) ) ; <nl>  <nl> - BlockingSingle & lt ; Result & lt ; String & gt ; & gt ; o = service . result ( ) . toBlocking ( ) ; <nl> - Result & lt ; String & gt ; result = o . value ( ) ; <nl> + TestSubscriber & lt ; Result & lt ; String & gt ; & gt ; subscriber = new TestSubscriber & lt ; & gt ; ( ) ; <nl> + service . result ( ) . subscribe ( subscriber ) ; <nl> + Result & lt ; String & gt ; result = subscriber . getOnNextEvents ( ) . get ( 0 ) ; <nl> assertThat ( result . isError ( ) ) . isFalse ( ) ; <nl> Response & lt ; String & gt ; response = result . response ( ) ; <nl> assertThat ( response . isSuccessful ( ) ) . isFalse ( ) ; <nl> 
mmm a / src / main / java / org / markdownwriterfx / editor / SmartEdit . java <nl> ppp b / src / main / java / org / markdownwriterfx / editor / SmartEdit . java <nl> - } <nl> + textArea . getUndoManager ( ) . preventMerge ( ) ; <nl>  <nl> - public void insertBold ( ) { <nl> - surroundSelectionInCode ( " ** " ) ; <nl> + List & lt ; StrongEmphasis & gt ; nodes = findNodesAtSelection ( StrongEmphasis . class ) ; <nl> + if ( nodes . size ( ) & gt ; 0 ) { <nl> + removeDelimiters ( nodes ) ; <nl> + } else <nl> + surroundSelectionInCode ( " ** " ) ; <nl> } <nl>  <nl> public void insertItalic ( ) { <nl> 
mmm a / time4j - android / src / main / java / net / time4j / format / expert / Iso8601Format . java <nl> ppp b / time4j - android / src / main / java / net / time4j / format / expert / Iso8601Format . java <nl> ChronoFormatter . Builder & lt ; PlainDate & gt ; builder = <nl> ChronoFormatter <nl> . setUp ( PlainDate . class , Locale . ROOT ) <nl> + . startSection ( Attributes . NUMBER_SYSTEM , NumberSystem . ARABIC ) <nl> . startSection ( Attributes . ZERO_DIGIT , ' 0 ' ) <nl> . addInteger ( YEAR_OF_WEEKDATE , 4 , 9 , SignPolicy . SHOW_WHEN_BIG_NUMBER ) ; <nl>  <nl> builder . addLiteral ( ' - ' ) ; <nl> } <nl>  <nl> - return builder . addFixedNumerical ( DAY_OF_WEEK , 1 ) . endSection ( ) . build ( ) . with ( Leniency . STRICT ) ; <nl> + return builder . addFixedNumerical ( DAY_OF_WEEK , 1 ) . endSection ( ) . endSection ( ) . build ( ) . with ( Leniency . STRICT ) ; <nl>  <nl> } <nl> 
mmm a / graylog2 - server / src / test / java / org / graylog2 / indexer / ranges / EsIndexRangeServiceTest . java <nl> ppp b / graylog2 - server / src / test / java / org / graylog2 / indexer / ranges / EsIndexRangeServiceTest . java <nl> . rotationStrategy ( MessageCountRotationStrategyConfig . createDefault ( ) ) <nl> . retentionStrategyClass ( DeletionRetentionStrategy . class . getCanonicalName ( ) ) <nl> . retentionStrategy ( DeletionRetentionStrategyConfig . createDefault ( ) ) <nl> + . indexAnalyzer ( " standard " ) <nl> + . indexTemplateName ( " template - 1 " ) <nl> + . indexOptimizationMaxNumSegments ( 1 ) <nl> + . indexOptimizationDisabled ( false ) <nl> . build ( ) ; <nl> this . indexSet = new TestIndexSet ( indexSetConfig ) ; <nl> this . elasticsearchRule = newElasticsearchRule ( ) . defaultEmbeddedElasticsearch ( ) ; <nl> 
mmm a / src / main / java / org / gedcomx / conversion / gedcom / dq55 / PersonMapper . java <nl> ppp b / src / main / java / org / gedcomx / conversion / gedcom / dq55 / PersonMapper . java <nl> - gedxPerson . setGender ( gender ) ; <nl> + } <nl> + } <nl> + <nl> + private void processSex ( Person gedxPerson , EventFact fact ) { <nl> + if ( gedxPerson . getGender ( ) ! = null ) { <nl> + } <nl> + <nl> + if ( fact . getValue ( ) . equalsIgnoreCase ( " M " ) ) { <nl> + gedxPerson . setGender ( new Gender ( GenderType . Male ) ) ; <nl> + } <nl> + else if ( fact . getValue ( ) . equalsIgnoreCase ( " F " ) ) { <nl> + gedxPerson . setGender ( new Gender ( GenderType . Female ) ) ; <nl> } <nl> else if ( fact . getValue ( ) . equalsIgnoreCase ( " U " ) ) { <nl> - Gender gender = new Gender ( ) ; <nl> - gender . setKnownType ( GenderType . Unknown ) ; <nl> - gedxPerson . setGender ( gender ) ; <nl> + gedxPerson . setGender ( new Gender ( GenderType . Unknown ) ) ; <nl> } <nl> else { <nl> 
mmm a / mobile / src / androidTest / java / com / kuxhausen / huemore / MoodTest . java <nl> ppp b / mobile / src / androidTest / java / com / kuxhausen / huemore / MoodTest . java <nl> Event e1 = new Event ( bs1 , 1 , 0 ) ; <nl> Event e2 = new Event ( bs2 , 1 , 5000l ) ; <nl>  <nl> - Mood m = new Mood ( ) ; <nl> - m . setEvents ( new Event [ ] { e1 , e2 } ) ; <nl> - m . setNumChannels ( 2 ) ; <nl> + Mood m = new Mood . Builder ( ) <nl> + . setEvents ( new Event [ ] { e1 , e2 } ) <nl> + . setNumChannels ( 2 ) <nl> + . build ( ) ; <nl>  <nl> assertFalse ( m . getTimeAddressingRepeatPolicy ( ) ) ; <nl> assertFalse ( m . isInfiniteLooping ( ) ) ; <nl> 
mmm a / hemesh 2014 / src / wblut / processing / WB_DebugRender3D . java <nl> ppp b / hemesh 2014 / src / wblut / processing / WB_DebugRender3D . java <nl> home . box ( ( float ) d ) ; <nl> home . popMatrix ( ) ; <nl> } else { <nl> - c = he . getHalfedgeCenter ( ) ; <nl> - c . addSelf ( he . getPair ( ) . getHalfedgeNormal ( ) . mulSelf ( - d ) ) ; <nl> + c = new WB_Point ( he . getHalfedgeCenter ( ) ) ; <nl> + c . addMulSelf ( - d , he . getPair ( ) . getHalfedgeNormal ( ) ) ; <nl> home . stroke ( 255 , 0 , 0 ) ; <nl> home . line ( he . getVertex ( ) . xf ( ) , he . getVertex ( ) . yf ( ) , he <nl> . getVertex ( ) . zf ( ) , c . xf ( ) , c . yf ( ) , c . zf ( ) ) ; <nl> 
mmm a / src / main / java / modtweaker2 / mods / forestry / handlers / Carpenter . java <nl> ppp b / src / main / java / modtweaker2 / mods / forestry / handlers / Carpenter . java <nl> * / <nl> @ ZenMethod <nl> public static void addRecipe ( IItemStack output , IIngredient [ ] [ ] ingredients , int packagingTime , @ Optional IItemStack box ) { <nl> - MineTweakerAPI . apply ( new Add ( new Recipe ( packagingTime , null , toStack ( box ) , ShapedRecipeCustom . createShapedRecipe ( toStack ( output ) , toShapedObjects ( ingredients ) ) ) ) ) ; <nl> + IDescriptiveRecipe craftRecipe = new DescriptiveRecipe ( 3 , 3 , toShapedObjects ( ingredients ) , toStack ( output ) , false ) ; <nl> + MineTweakerAPI . apply ( new Add ( new CarpenterRecipe ( packagingTime , null , toStack ( box ) , craftRecipe ) ) ) ; <nl> } <nl> - <nl> - / ** <nl> 
mmm a / src / test / java / org / jfaster / mango / exception / IllegalStateExceptionTest . java <nl> ppp b / src / test / java / org / jfaster / mango / exception / IllegalStateExceptionTest . java <nl> thrown . expect ( IllegalStateException . class ) ; <nl> thrown . expectMessage ( " if use cache , each method expected one or more " + <nl> " @ CacheBy annotation on parameter but found 0 " ) ; <nl> - Dao3 dao = mango . create ( Dao3 . class , new LocalCacheHandler ( ) ) ; <nl> + Mango mango = Mango . newInstance ( DataSourceConfig . getDataSource ( ) ) ; <nl> + mango . setLazyInit ( true ) ; <nl> + mango . setCacheHandler ( new LocalCacheHandler ( ) ) ; <nl> + Dao3 dao = mango . create ( Dao3 . class ) ; <nl> dao . add ( ) ; <nl> } <nl> 
mmm a / core / src / main / java / org / fourthline / cling / transport / impl / DatagramIOImpl . java <nl> ppp b / core / src / main / java / org / fourthline / cling / transport / impl / DatagramIOImpl . java <nl> + } <nl> + <nl> synchronized public void send ( OutgoingDatagramMessage message ) { <nl> - log . fine ( " Sending message from address : " + localAddress ) ; <nl> + if ( log . isLoggable ( Level . FINE ) ) { <nl> + log . fine ( " Sending message from address : " + localAddress ) ; <nl> + } <nl> DatagramPacket packet = datagramProcessor . write ( message ) ; <nl> - log . fine ( " Sending UDP datagram packet to : " + message . getDestinationAddress ( ) + " : " + message . getDestinationPort ( ) ) ; <nl> + <nl> + if ( log . isLoggable ( Level . FINE ) ) { <nl> + log . fine ( " Sending UDP datagram packet to : " + message . getDestinationAddress ( ) + " : " + message . getDestinationPort ( ) ) ; <nl> + } <nl> + <nl> send ( packet ) ; <nl> - } <nl> 
mmm a / ding - impl / ding - presentation - impl / src / main / java / org / cytoscape / ding / impl / DEdgeDetails . java <nl> ppp b / ding - impl / ding - presentation - impl / src / main / java / org / cytoscape / ding / impl / DEdgeDetails . java <nl> + @ Override <nl> public Paint getSourceArrowPaint ( final CyEdge edge ) { <nl> boolean isSelected = selected . contains ( edge ) ; <nl>  <nl> - if ( isSelected ) <nl> - return getSelectedPaint ( edge ) ; <nl> - else <nl> - return getSourceArrowUnselectedPaint ( edge ) ; <nl> + return isSelected ? getSelectedPaint ( edge ) : getSourceArrowUnselectedPaint ( edge ) ; <nl> } <nl>  <nl> private final Paint getSourceArrowUnselectedPaint ( final CyEdge edge ) { <nl> 
mmm a / src / com / bfh / logisim / designrulecheck / Netlist . java <nl> ppp b / src / com / bfh / logisim / designrulecheck / Netlist . java <nl> if ( SlaveNet ! = null ) { <nl> if ( SlaveNet . IsRootNet ( ) ) { <nl> - result . addAll ( GetHiddenSource ( SlaveNet , Netindex , <nl> + SourceInfo ret = GetHiddenSource ( SlaveNet , Netindex , <nl> SplitterList , currentSplitter , <nl> - HandledNets , Segments ) ) ; <nl> + HandledNets , Segments , Reporter ) ; <nl> + if ( ret ! = null ) <nl> + return ret ; <nl> } else { <nl> - result . addAll ( GetHiddenSource ( SlaveNet . getParent ( ) , <nl> - SlaveNet . getBit ( Netindex ) , <nl> + SourceInfo ret = GetHiddenSource ( SlaveNet . getParent ( ) , <nl> + SlaveNet . getBit ( Netindex ) , <nl> 
mmm a / src / main / java / com / yandex / money / api / typeadapters / showcase / ShowcaseTypeAdapter . java <nl> ppp b / src / main / java / com / yandex / money / api / typeadapters / showcase / ShowcaseTypeAdapter . java <nl> + List & lt ; AllowedMoneySource & gt ; moneySources = AllowedMoneySourceTypeAdapter . getInstance ( ) <nl> + . fromJson ( object . getAsJsonArray ( MEMBER_MONEY_SOURCE ) ) ; <nl> + List & lt ; Error & gt ; errors = ErrorTypeAdapter . getInstance ( ) . fromJson ( object . getAsJsonArray ( MEMBER_ERROR ) ) ; <nl> + <nl> + return new Showcase . Builder ( ) <nl> + . setTitle ( getMandatoryString ( object , MEMBER_TITLE ) ) <nl> + . setHiddenFields ( getNotNullMap ( object , MEMBER_HIDDEN_FIELDS ) ) <nl> . setForm ( form ) <nl> - . setMoneySources ( new LinkedHashSet & lt ; & gt ; ( getNotNullArray ( object , MEMBER_MONEY_SOURCE , <nl> - AllowedMoneySourceTypeAdapter . getInstance ( ) ) ) ) <nl> - . setErrors ( getNotNullArray ( object , MEMBER_ERROR , ErrorTypeAdapter . getInstance ( ) ) ) <nl> + . setMoneySources ( toEmptyListIfNull ( moneySources ) ) <nl> + . setErrors ( toEmptyListIfNull ( errors ) ) <nl> . create ( ) ; <nl> } <nl> 
mmm a / src / main / java / com / fabahaba / jedipus / cluster / Jedipus . java <nl> ppp b / src / main / java / com / fabahaba / jedipus / cluster / Jedipus . java <nl> - return result ; <nl> - } catch ( final RedisConnectionException jcex ) { <nl> - <nl> - retries = connHandler . getClusterNodeRetryDelay ( ) <nl> - . markFailure ( client == null ? node : client . getNode ( ) , maxRetries , jcex , retries ) ; <nl> - } catch ( final RedisRetryableUnhandledException retryableEx ) { <nl> - <nl> - if ( ! retryUnhandledRetryableExceptions ) { <nl> + pool = null ; <nl> + final Node failedNode = client == null ? retryableEx . getNode ( ) : client . getNode ( ) ; <nl> + client = null ; <nl> + retries = connHandler . getClusterNodeRetryDelay ( ) . markFailure ( failedNode , maxRetries , <nl> + retryableEx , retries ) ; <nl> + } finally { <nl> + RedisClientPool . returnClient ( pool , client ) ; <nl> + } <nl> 
mmm a / app / src / main / java / com / cooloongwu / greendao / gen / ChatFriendDao . java <nl> ppp b / app / src / main / java / com / cooloongwu / greendao / gen / ChatFriendDao . java <nl> cursor . isNull ( offset + 5 ) ? null : cursor . getString ( offset + 5 ) , /  / content <nl> cursor . isNull ( offset + 6 ) ? null : cursor . getString ( offset + 6 ) , /  / contentType <nl> - cursor . isNull ( offset + 7 ) ? null : cursor . getString ( offset + 7 ) , /  / time <nl> - cursor . getShort ( offset + 8 ) ! = 0 /  / isRead <nl> + cursor . isNull ( offset + 7 ) ? null : cursor . getString ( offset + 7 ) , /  / audioLength <nl> + cursor . isNull ( offset + 8 ) ? null : cursor . getString ( offset + 8 ) , /  / time <nl> + cursor . getShort ( offset + 9 ) ! = 0 /  / isRead <nl> ) ; <nl> return entity ; <nl> } <nl> 
mmm a / src / main / java / com / marklogic / client / impl / JerseyServices . java <nl> ppp b / src / main / java / com / marklogic / client / impl / JerseyServices . java <nl> if ( logger . isDebugEnabled ( ) ) <nl> logger . debug ( " Searching for structure { } " , structure ) ; <nl>  <nl> - builder = getConnection ( ) . path ( " search " ) . queryParams ( params ) <nl> - . type ( " application / xml " ) . accept ( mimetype ) ; <nl> + webResource = getConnection ( ) . path ( " search " ) . queryParams ( params ) ; <nl> + builder = webResource . type ( " application / xml " ) . accept ( mimetype ) ; <nl> } else if ( queryDef instanceof CombinedQueryDefinition ) { <nl> structure = ( ( CombinedQueryDefinition ) queryDef ) . serialize ( ) ; <nl> 
mmm a / dbfit - java / db2 / src / main / java / dbfit / environment / DB2iEnvironment . java <nl> ppp b / dbfit - java / db2 / src / main / java / dbfit / environment / DB2iEnvironment . java <nl> + while ( rs . next ( ) ) { <nl> + String paramName = rs . getString ( 1 ) ; <nl> + if ( paramName == null ) <nl> + paramName = " " ; <nl> + String dataType = rs . getString ( 2 ) ; <nl> String direction = rs . getString ( 4 ) ; <nl> Direction paramDirection = getParameterDirection ( direction ) ; <nl> - DbParameterAccessor dbp = new DbParameterAccessor ( paramName , <nl> + DbParameterAccessor dbp = createDbParameterAccessor ( <nl> + paramName , <nl> paramDirection , getSqlType ( dataType ) , <nl> getJavaClass ( dataType ) , <nl> - paramDirection == RETURN_VALUE ? - 1 <nl> - : position++ ) ; <nl> + paramDirection == RETURN_VALUE ? - 1 : position++ ) ; <nl> allParams . put ( NameNormaliser . normaliseName ( paramName ) , dbp ) ; <nl> } <nl> rs . close ( ) ; <nl> 
mmm a / Phosphor / src / edu / columbia / cs / psl / phosphor / instrumenter / TaintTrackingClassVisitor . java <nl> ppp b / Phosphor / src / edu / columbia / cs / psl / phosphor / instrumenter / TaintTrackingClassVisitor . java <nl> mv . visitFieldInsn ( Opcodes . PUTFIELD , className , TaintUtils . TAINT_FIELD , Configuration . TAINT_TAG_DESC ) ; <nl> if ( className . equals ( " java / lang / String " ) ) { <nl> + mv . visitVarInsn ( Opcodes . ALOAD , 0 ) ; <nl> + mv . visitVarInsn ( Opcodes . ALOAD , 0 ) ; <nl> + mv . visitFieldInsn ( Opcodes . GETFIELD , className , " value " , " [ C " ) ; /  / Force the StringTaintVerifyingMV to make sure there is a taint array here <nl> + mv . visitInsn ( Opcodes . ARRAYLENGTH ) ; <nl> + mv . visitIntInsn ( Opcodes . NEWARRAY , Opcodes . T_INT ) ; <nl> + mv . visitFieldInsn ( Opcodes . PUTFIELD , className , " value " + TaintUtils . TAINT_FIELD , Configuration . TAINT_TAG_ARRAYDESC ) ; <nl> + <nl> mv . visitVarInsn ( Opcodes . ALOAD , 0 ) ; <nl> mv . visitFieldInsn ( Opcodes . GETFIELD , className , " value " + TaintUtils . TAINT_FIELD , Configuration . TAINT_TAG_ARRAYDESC ) ; <nl> mv . visitVarInsn ( Opcodes . ILOAD , 1 ) ; <nl> 
mmm a / src / com / avail / descriptor / MessageBundleTreeDescriptor . java <nl> ppp b / src / com / avail / descriptor / MessageBundleTreeDescriptor . java <nl> + * / <nl> + @ Override <nl> + void o_RemovePlanInProgress ( <nl> final AvailObject object , <nl> - final A_DefinitionParsingPlan plan ) <nl> + final A_ParsingPlanInProgress planInProgress ) <nl> { <nl> synchronized ( object ) <nl> { <nl> - final A_Bundle bundle = plan . bundle ( ) ; <nl> - final A_Definition definition = plan . definition ( ) ; <nl> - A_Map allPlans = object . slot ( ALL_PLANS ) ; <nl> - assert allPlans . hasKey ( bundle ) ; <nl> - A_Map submap = allPlans . mapAt ( bundle ) ; <nl> - submap = submap . mapWithoutKeyCanDestroy ( definition , true ) ; <nl> - if ( submap . mapSize ( ) == 0 ) <nl> - { <nl> - allPlans = allPlans . mapWithoutKeyCanDestroy ( bundle , true ) ; <nl> - } <nl> - else <nl> - { <nl> - allPlans = allPlans . mapAtPuttingCanDestroy ( <nl> - bundle , submap , true ) ; <nl> - } <nl> - object . setSlot ( ALL_PLANS , allPlans . makeShared ( ) ) ; <nl> - A_Map unclassified = object . slot ( UNCLASSIFIED ) ; <nl> - if ( unclassified . hasKey ( bundle ) ) <nl> - { <nl> - A_Map unclassifiedSubmap = unclassified . mapAt ( bundle ) ; <nl> - unclassifiedSubmap = unclassifiedSubmap . mapWithoutKeyCanDestroy ( <nl> - definition , true ) ; <nl> - if ( unclassifiedSubmap . mapSize ( ) == 0 ) <nl> - { <nl> - unclassified = unclassified . mapWithoutKeyCanDestroy ( <nl> - bundle , true ) ; <nl> - } <nl> - else <nl> - { <nl> - unclassified = unclassified . mapAtPuttingCanDestroy ( <nl> - bundle , unclassifiedSubmap , true ) ; <nl> - } <nl> - object . setSlot ( UNCLASSIFIED , unclassified . makeShared ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> + object . setSlot ( <nl> + ALL_PLANS_IN_PROGRESS , <nl> + layeredMapWithoutPlan ( <nl> + object . slot ( ALL_PLANS_IN_PROGRESS ) , planInProgress ) ) ; <nl> + object . setSlot ( <nl> + UNCLASSIFIED , <nl> + layeredMapWithoutPlan ( <nl> 
mmm a / src / main / java / org / zwobble / mammoth / internal / styles / parsing / StyleMappingTokeniser . java <nl> ppp b / src / main / java / org / zwobble / mammoth / internal / styles / parsing / StyleMappingTokeniser . java <nl> list ( <nl> RegexTokeniser . rule ( TokenType . IDENTIFIER , " ( [ a - zA - Z ] [ a - zA - Z0 - 9 \  \  - ] * ) " ) , <nl> RegexTokeniser . rule ( TokenType . CLASS_NAME , " ( \  \  . ( ? : [ a - zA - Z0 - 9 \  \  - ] | \  \  \  \ . ) + ) " ) , <nl> - RegexTokeniser . rule ( TokenType . COLON , " : " ) , <nl> - RegexTokeniser . rule ( TokenType . GREATER_THAN , " & gt ; " ) , <nl> + RegexTokeniser . rule ( TokenType . SYMBOL , " : | & gt ; |= & gt ; |=| \  \ ( | \  \ ) | \  \ [ | \  \ ] | \  \ || ! " ) , <nl> RegexTokeniser . rule ( TokenType . WHITESPACE , " \  \ s+ " ) , <nl> - RegexTokeniser . rule ( TokenType . ARROW , " = & gt ; " ) , <nl> - RegexTokeniser . rule ( TokenType . EQUALS , " = " ) , <nl> - RegexTokeniser . rule ( TokenType . OPEN_PAREN , " \  \ ( " ) , <nl> - RegexTokeniser . rule ( TokenType . CLOSE_PAREN , " \  \ ) " ) , <nl> + RegexTokeniser . rule ( TokenType . STRING , stringPrefix + " ' " ) , <nl> 
mmm a / src / main / java / com / github / games647 / flexiblelogin / listener / PreventListener . java <nl> ppp b / src / main / java / com / github / games647 / flexiblelogin / listener / PreventListener . java <nl> - @ Listener ( ignoreCancelled = true ) <nl> - public void onItemConsume ( UseItemStackEvent . SourcePlayer itemConsumeEvent ) { <nl> - checkAllowance ( itemConsumeEvent , itemConsumeEvent . getSourceEntity ( ) ) ; <nl> } <nl>  <nl> @ Listener ( ignoreCancelled = true ) <nl> + public void onItemConsume ( UseItemStackEvent itemConsumeEvent ) { <nl> + Optional & lt ; Player & gt ; playerOptional = itemConsumeEvent . getCause ( ) . first ( Player . class ) ; <nl> + if ( playerOptional . isPresent ( ) ) { <nl> + checkAllowance ( itemConsumeEvent , playerOptional . get ( ) ) ; <nl> + } <nl> + } <nl> 
mmm a / src / v2 / org / analysis / complement / BitVector . java <nl> ppp b / src / v2 / org / analysis / complement / BitVector . java <nl> - result |= ( b1 & 0xFF ) ; <nl>  <nl> - result = ( BitVector . isAPIHandle ( ) ) ? Convert . convetUnsignedValue ( result , 32 ) : Convert . convertSignedValue ( <nl> - result , 32 ) ; <nl> - <nl> - return result ; <nl> + return Convert . convetUnsignedValue ( result , 32 ) ; <nl> } <nl>  <nl> public static long bytesToLong ( int b1 , int b2 ) { <nl> 
mmm a / main / plugins / org . talend . designer . camel . dependencies . core / src / org / talend / designer / camel / dependencies / core / DependenciesResolver . java <nl> ppp b / main / plugins / org . talend . designer . camel . dependencies . core / src / org / talend / designer / camel / dependencies / core / DependenciesResolver . java <nl> - continue ; <nl> - } <nl> - for ( ImportPackage importPackage : targets ) { <nl> - if ( ! importPackages . add ( importPackage ) ) { <nl> - for ( ImportPackage obj : importPackages ) { <nl> - if ( importPackage . equals ( obj ) ) { <nl> - importPackage = obj ; <nl> - break ; <nl> - } <nl> - } <nl> + final Collection & lt ; ImportPackage & gt ; targets = ip . toTargets ( n ) ; <nl> + if ( targets ! = null ) { <nl> + for ( ImportPackage importPackage : targets ) { <nl> + addItem ( importPackages , importPackage ) . addRelativeComponent ( uniqueName ) ; <nl> } <nl> + } <nl> + } <nl> 
mmm a / patient - user / src / test / java / gov / samhsa / c2s / patientuser / web / UserCreationControllerTest . java <nl> ppp b / patient - user / src / test / java / gov / samhsa / c2s / patientuser / web / UserCreationControllerTest . java <nl> mvc . perform ( post ( " / activations " ) <nl> . contentType ( MediaType . APPLICATION_JSON_UTF8 ) <nl> - . content ( objectMapper . writeValueAsBytes ( request ) ) ) <nl> + . content ( objectMapper . writeValueAsBytes ( request ) ) <nl> + . header ( UserCreationController . X_FORWARDED_PROTO , xForwardedProto ) <nl> + . header ( UserCreationController . X_FORWARDED_HOST , xForwardedHost ) <nl> + . header ( UserCreationController . X_FORWARDED_PORT , xForwardedPort ) ) <nl> . andExpect ( status ( ) . isOk ( ) ) <nl> . andExpect ( jsonPath ( " $ . id " , is ( patientId . intValue ( ) ) ) ) <nl> . andExpect ( jsonPath ( " $ . lastName " , is ( lastName ) ) ) <nl> 
mmm a / src / main / java / com / github / bingoohuang / springrestclient / generators / MethodGenerator . java <nl> ppp b / src / main / java / com / github / bingoohuang / springrestclient / generators / MethodGenerator . java <nl> - mv . visitVarInsn ( ALOAD , paramSize + 2 ) ; <nl> - <nl> - mv . visitLdcInsn ( Type . getType ( returnType ) ) ; <nl> - mv . visitMethodInsn ( INVOKESTATIC , p ( UniRestUtils . class ) , " asJson " , <nl> - sig ( Object . class , String . class , Map . class , Map . class , Class . class ) , false ) ; <nl> - mv . visitTypeInsn ( CHECKCAST , p ( returnType ) ) ; <nl> - mv . visitInsn ( ARETURN ) ; <nl> - mv . visitMaxs ( - 1 , - 1 ) ; <nl> + if ( requestBodyIndex & lt ; 0 ) { <nl> + mv . visitLdcInsn ( Type . getType ( returnType ) ) ; <nl> + mv . visitMethodInsn ( INVOKESTATIC , p ( UniRestUtils . class ) , " get " , <nl> + sig ( Object . class , String . class , Map . class , Map . class , Class . class ) , false ) ; <nl> + mv . visitTypeInsn ( CHECKCAST , p ( returnType ) ) ; <nl> + mv . visitInsn ( ARETURN ) ; <nl> + } else { <nl> + mv . visitVarInsn ( ALOAD , requestBodyIndex + 1 ) ; <nl> + mv . visitMethodInsn ( INVOKESTATIC , p ( UniRestUtils . class ) , " postAsJson " , <nl> + sig ( String . class , String . class , Map . class , Map . class , Object . class ) , false ) ; <nl> + mv . visitVarInsn ( ASTORE , paramSize + 3 ) ; <nl> + mv . visitVarInsn ( ALOAD , paramSize + 3 ) ; <nl> 
mmm a / src / main / java / org / squiddev / cobalt / lib / DebugLib . java <nl> ppp b / src / main / java / org / squiddev / cobalt / lib / DebugLib . java <nl> + valueOf ( ds . hookcount ) ) ; <nl> + } <nl> + <nl> static Varargs _sethook ( LuaState state , Varargs args ) { <nl> int a = 1 ; <nl> - LuaThread thread = args . isthread ( a ) ? args . checkthread ( a++ ) : state . currentThread ; <nl> - LuaValue func = args . optfunction ( a++ , null ) ; <nl> - String str = args . optjstring ( a++ , " " ) ; <nl> - int count = args . optint ( a++ , 0 ) ; <nl> + LuaThread thread = args . arg ( a ) . isThread ( ) ? args . arg ( a++ ) . checkThread ( ) : state . currentThread ; <nl> + int i1 = a++ ; <nl> + LuaValue func = args . arg ( i1 ) . optFunction ( null ) ; <nl> + int i3 = a++ ; <nl> + String str = args . arg ( i3 ) . optjstring ( " " ) ; <nl> + int i2 = a++ ; <nl> + int count = args . arg ( i2 ) . optInteger ( 0 ) ; <nl> + boolean call = false , line = false , rtrn = false ; <nl> + for ( int i = 0 ; i & lt ; str . length ( ) ; i++ ) { <nl> + switch ( str . charAt ( i ) ) { <nl> 
mmm a / rest / src / main / java / org / teavm / flavour / rest / impl / FactoryEmitter . java <nl> ppp b / rest / src / main / java / org / teavm / flavour / rest / impl / FactoryEmitter . java <nl> } <nl>  <nl> - private ValueEmitter createListDeserializer ( Type itemType , ProgramEmitter pe ) { <nl> - ValueEmitter itemDeserializer = createDeserializer ( itemType , pe ) . cast ( JsonDeserializer . class ) ; <nl> - return pe . construct ( ListDeserializer . class , itemDeserializer ) ; <nl> + private Value & lt ; JsonDeserializer & gt ; createListDeserializer ( Emitter & lt ; ? & gt ; em , Type itemType ) { <nl> + Value & lt ; JsonDeserializer & gt ; itemDeserializer = createDeserializer ( em , itemType ) ; <nl> + return em . emit ( ( ) - & gt ; new ListDeserializer ( itemDeserializer . get ( ) ) ) ; <nl> } <nl>  <nl> - private ValueEmitter createSetDeserializer ( Type itemType , ProgramEmitter pe ) { <nl> + private Value & lt ; JsonDeserializer & gt ; createSetDeserializer ( Emitter & lt ; ? & gt ; em , Type itemType ) { <nl> 
mmm a / src / consulo / unity3d / jsonApi / UnityOpenFilePostHandler . java <nl> ppp b / src / consulo / unity3d / jsonApi / UnityOpenFilePostHandler . java <nl> - } <nl> - <nl> IdeFrame ideFrame = WindowManager . getInstance ( ) . getIdeFrame ( openedProject ) ; <nl> - RequestFocusHttpRequestHandler . activateFrame ( ideFrame ) ; <nl> + if ( SystemInfo . isMac ) <nl> + { <nl> + ID id = MacUtil . findWindowFromJavaWindow ( ( Window ) ideFrame ) ; <nl> + if ( id ! = null ) <nl> + { <nl> + Foundation . invoke ( id , " makeKeyAndOrderFront " , new Object [ ] { null } ) ; <nl> + } <nl> + } <nl> + else if ( SystemInfo . isWindows ) <nl> + { <nl> + Pointer windowPointer = Native . getWindowPointer ( ( Window ) ideFrame ) ; <nl> + User32 . INSTANCE . SetForegroundWindow ( new WinDef . HWND ( windowPointer ) ) ; <nl> + } <nl> + else <nl> + { <nl> + RequestFocusHttpRequestHandler . activateFrame ( ideFrame ) ; <nl> + } <nl> } <nl> - <nl> - private void openFile ( @ Nullable Project openedProject , @ NotNull UnityOpenFilePostHandlerRequest body ) <nl> 
mmm a / mjolnirrecyclerview / src / main / java / co / infinum / mjolnirrecyclerview / MjolnirRecyclerAdapter . java <nl> ppp b / mjolnirrecyclerview / src / main / java / co / infinum / mjolnirrecyclerview / MjolnirRecyclerAdapter . java <nl> - * @ return true if header was added / replaced , false otherwise . <nl> - * / <nl> - public boolean setHeader ( @ LayoutRes int headerViewId , boolean shouldReplace ) { <nl> - if ( shouldReplace || ! hasHeader ( ) ) { <nl> - removeHeader ( ) ; <nl> - headerView = LayoutInflater . from ( getContext ( ) ) . inflate ( headerViewId , null , false ) ; <nl> - setDefaultLayoutParams ( headerView ) ; <nl> - notifyItemInserted ( 0 ) ; <nl> - return true ; <nl> + headerView = LayoutInflater . from ( getContext ( ) ) . inflate ( headerViewId , null , false ) ; <nl> + setDefaultLayoutParams ( headerView ) ; <nl> + <nl> + if ( hadHeaderBefore ) { <nl> + notifyItemChanged ( 0 ) ; <nl> } else { <nl> - return false ; <nl> + notifyItemInserted ( 0 ) ; <nl> } <nl> } <nl> 
mmm a / src / shaders / ShadowShader . java <nl> ppp b / src / shaders / ShadowShader . java <nl> ShaderProgram . pedantic = false ; <nl> ShaderProgram shadowShader = new ShaderProgram ( vertexShader , <nl> fragmentShader ) ; <nl> - if ( shadowShader . isCompiled ( ) == false ) { <nl> - Gdx . app . log ( " ERROR " , shadowShader . getLog ( ) ) ; <nl> - <nl> + if ( ! shadowShader . isCompiled ( ) ) { <nl> + shadowShader = new ShaderProgram ( " # version 330 core \ n " +vertexShader , <nl> + " # version 330 core \ n " +fragmentShader ) ; <nl> + if ( ! shadowShader . isCompiled ( ) ) { <nl> + Gdx . app . log ( " ERROR " , shadowShader . getLog ( ) ) ; <nl> + } <nl> } <nl> 
mmm a / src / main / java / edu / sc / seis / TauP / TauP_Curve . java <nl> ppp b / src / main / java / edu / sc / seis / TauP / TauP_Curve . java <nl> ( isBetween ( Math . acos ( Math . cos ( phase . getDist ( ) [ distIndex ] ) ) , <nl> Math . acos ( Math . cos ( phase . getDist ( ) [ distIndex+1 ] ) ) , <nl> arcDistance ) ) ) { <nl> - phase . calcTime ( arcDistance*180 / Math . PI ) ; <nl> - Arrival [ ] phaseArrivals = phase . getArrivals ( ) ; <nl> - int j = 0 ; <nl> - while ( j & lt ; phaseArrivals . length ) { <nl> - if ( ( phase . rayParams [ distIndex ] - phaseArrivals [ j ] . getRayParam ( ) ) <nl> - * ( phaseArrivals [ j ] . getRayParam ( ) - phase . rayParams [ distIndex + 1 ] ) & gt ; 0 ) { <nl> + List & lt ; Arrival & gt ; phaseArrivals = phase . calcTime ( arcDistance*180 / Math . PI ) ; <nl> + for ( Arrival arrival : phaseArrivals ) { <nl> + if ( ( phase . rayParams [ distIndex ] - arrival . getRayParam ( ) ) <nl> + * ( arrival . getRayParam ( ) - phase . rayParams [ distIndex + 1 ] ) & gt ; 0 ) { <nl> if ( reduceTime ) { <nl> - writeValue ( arcDistance , phaseArrivals [ j ] . getTime ( ) - arcDistance <nl> - / reduceVel , relPhase , out ) ; <nl> - } else { <nl> - writeValue ( arcDistance , phaseArrivals [ j ] . getTime ( ) , relPhase , out ) ; <nl> - } <nl> - break ; <nl> - } <nl> 
mmm a / org . eclipse . january . geometry / src - gen / xtext / parser / antlr / internal / InternalSTLParser . java <nl> ppp b / org . eclipse . january . geometry / src - gen / xtext / parser / antlr / internal / InternalSTLParser . java <nl> - newCompositeNode ( grammarAccess . getVertexAccess ( ) . getZEDoubleParserRuleCall_3_0 ( ) ) ; <nl> - <nl> - pushFollow ( FOLLOW_2 ) ; <nl> - lv_z_3_0=ruleEDouble ( ) ; <nl> - <nl> - state . _fsp -  - ; <nl> + { <nl> + lv_z_3_0= ( Token ) match ( input , RULE_DOUBLE , FOLLOW_2 ) ; <nl>  <nl> + newLeafNode ( lv_z_3_0 , grammarAccess . getVertexAccess ( ) . getZDOUBLETerminalRuleCall_3_0 ( ) ) ; <nl> + <nl>  <nl> if ( current==null ) { <nl> - current = createModelElementForParent ( grammarAccess . getVertexRule ( ) ) ; <nl> + current = createModelElement ( grammarAccess . getVertexRule ( ) ) ; <nl> } <nl> - set ( <nl> + setWithLastConsumed ( <nl> current , <nl> " z " , <nl> lv_z_3_0 , <nl> - " xtext . STL . EDouble " ) ; <nl> - afterParserOrEnumRuleCall ( ) ; <nl> + " xtext . STL . DOUBLE " ) ; <nl>  <nl> + <nl> + } <nl> 
mmm a / ij / plugin / PluginInstaller . java <nl> ppp b / ij / plugin / PluginInstaller . java <nl> + } <nl> + <nl> + public static byte [ ] download ( String urlString , String name ) { <nl> + URL url = null ; <nl> + try { <nl> + url = new URL ( urlString ) ; <nl> + } catch ( Exception e ) { <nl> + IJ . log ( " " +e ) ; <nl> + } <nl> + if ( url==null ) return null ; <nl> + byte [ ] data ; <nl> try { <nl> URLConnection uc = url . openConnection ( ) ; <nl> int len = uc . getContentLength ( ) ; <nl> - IJ . showStatus ( " Downloading " +url . getFile ( ) ) ; <nl> + if ( name ! =null ) <nl> + IJ . showStatus ( " Downloading " +url . getFile ( ) ) ; <nl> InputStream in = uc . getInputStream ( ) ; <nl> data = new byte [ len ] ; <nl> int n = 0 ; <nl> 
mmm a / src / com / opentaxi / android / fragments / RequestDetailsFragment . java <nl> ppp b / src / com / opentaxi / android / fragments / RequestDetailsFragment . java <nl> if ( newCRequest . getCarNumber ( ) ! = null & & ! newCRequest . getCarNumber ( ) . isEmpty ( ) ) { <nl> car . setText ( ( newCRequest . getNotes ( ) ! = null ? newCRequest . getNotes ( ) : " " ) + " â " + newCRequest . getCarNumber ( ) ) ; <nl> - Drawable icon = new IconicsDrawable ( mActivity , GoogleMaterial . Icon . gmd_info ) . actionBar ( ) . colorRes ( R . color . transparent_blue ) ; <nl> + Drawable icon = new IconDrawable ( mActivity , MaterialIcons . md_info ) . colorRes ( R . color . transparent_blue ) . sizeDp ( 30 ) ; <nl> car . setCompoundDrawablesWithIntrinsicBounds ( null , null , icon , null ) ; <nl> car . setOnClickListener ( new View . OnClickListener ( ) { <nl> - public void onClick ( View v ) { <nl> 
mmm a / src / com / android / providers / downloads / Helpers . java <nl> ppp b / src / com / android / providers / downloads / Helpers . java <nl> + / ** <nl> + * Checks whether the filename looks legitimate <nl> + * / <nl> + static boolean isFilenameValid ( String filename , File downloadsDataDir ) { <nl> + final String [ ] whitelist ; <nl> + try { <nl> + filename = new File ( filename ) . getCanonicalPath ( ) ; <nl> + whitelist = new String [ ] { <nl> + downloadsDataDir . getCanonicalPath ( ) , <nl> + Environment . getDownloadCacheDirectory ( ) . getCanonicalPath ( ) , <nl> + Environment . getExternalStorageDirectory ( ) . getCanonicalPath ( ) , <nl> + } ; <nl> + } catch ( IOException e ) { <nl> + Log . w ( TAG , " Failed to resolve canonical path : " + e ) ; <nl> return false ; <nl> } <nl>  <nl> - return filename . startsWith ( Environment . getDownloadCacheDirectory ( ) . toString ( ) ) <nl> - || filename . startsWith ( downloadsDataDir . toString ( ) ) <nl> - || filename . startsWith ( Environment . getExternalStorageDirectory ( ) . toString ( ) ) ; <nl> + for ( String test : whitelist ) { <nl> + if ( filename . startsWith ( test ) ) { <nl> + return true ; <nl> + } <nl> + } <nl> + <nl> + return false ; <nl> } <nl> + <nl> + / ** <nl> 
mmm a / org . eclipse . jdt . ui / ui / org / eclipse / jdt / internal / ui / util / CoreUtility . java <nl> ppp b / org . eclipse . jdt . ui / ui / org / eclipse / jdt / internal / ui / util / CoreUtility . java <nl> + } <nl> + } <nl> } <nl> + SubMonitor subMonitor= SubMonitor . convert ( monitor , Messages . format ( JavaUIMessages . CoreUtility_buildproject_taskname , BasicElementLabels . getResourceName ( fProject ) ) , 2 ) ; <nl> try { <nl> if ( fProject ! = null ) { <nl> - monitor . beginTask ( Messages . format ( JavaUIMessages . CoreUtility_buildproject_taskname , BasicElementLabels . getResourceName ( fProject ) ) , 2 ) ; <nl> - fProject . build ( IncrementalProjectBuilder . FULL_BUILD , new SubProgressMonitor ( monitor,1 ) ) ; <nl> - JavaPlugin . getWorkspace ( ) . build ( IncrementalProjectBuilder . INCREMENTAL_BUILD , new SubProgressMonitor ( monitor,1 ) ) ; <nl> + fProject . build ( IncrementalProjectBuilder . FULL_BUILD , subMonitor . split ( 1 ) ) ; <nl> + JavaPlugin . getWorkspace ( ) . build ( IncrementalProjectBuilder . INCREMENTAL_BUILD , subMonitor . split ( 1 ) ) ; <nl> } else { <nl> monitor . beginTask ( JavaUIMessages . CoreUtility_buildall_taskname , 2 ) ; <nl> - JavaPlugin . getWorkspace ( ) . build ( IncrementalProjectBuilder . FULL_BUILD , new SubProgressMonitor ( monitor , 2 ) ) ; <nl> - } <nl> - } catch ( CoreException e ) { <nl> - return e . getStatus ( ) ; <nl> + JavaPlugin . getWorkspace ( ) . build ( IncrementalProjectBuilder . FULL_BUILD , subMonitor . split ( 2 ) ) ; <nl> 
mmm a / hadoop - hdfs - project / hadoop - hdfs / src / main / java / org / apache / hadoop / hdfs / server / namenode / FSPermissionChecker . java <nl> ppp b / hadoop - hdfs - project / hadoop - hdfs / src / main / java / org / apache / hadoop / hdfs / server / namenode / FSPermissionChecker . java <nl> return ; <nl> } <nl>  <nl> - DataInputBuffer buffer = new DataInputBuffer ( ) ; <nl> - buffer . reset ( inode . getPermission ( ) , inode . getPermission ( ) . length ) ; <nl> - PermissionStatus ps = PermissionStatus . read ( buffer ) ; <nl> - FsPermission mode = ps . getPermission ( ) ; <nl> - <nl> - check ( inode . getId ( ) , access , mode , ps . getUserName ( ) , ps . getGroupName ( ) ) ; <nl> + check ( inode . getId ( ) , access , new FsPermission ( inode . getPermission ( ) ) , inode <nl> + . getUserName ( ) , inode . getGroupName ( ) ) ; <nl> } <nl> 
mmm a / java - symbol - solver - core / src / main / java / com / github / javaparser / symbolsolver / javaparsermodel / contexts / MethodCallExprContext . java <nl> ppp b / java - symbol - solver - core / src / main / java / com / github / javaparser / symbolsolver / javaparsermodel / contexts / MethodCallExprContext . java <nl> @ Override <nl> public SymbolReference & lt ; MethodDeclaration & gt ; solveMethod ( String name , List & lt ; Type & gt ; argumentsTypes , TypeSolver typeSolver ) { <nl> - if ( wrappedNode . getScope ( ) . isPresent ( ) ) { <nl> + if ( wrappedNode . getScope ( ) ! = null ) { <nl>  <nl> - if ( wrappedNode . getScope ( ) . get ( ) instanceof NameExpr ) { <nl> - NameExpr scopeAsName = ( NameExpr ) wrappedNode . getScope ( ) . get ( ) ; <nl> + if ( wrappedNode . getScope ( ) instanceof NameExpr ) { <nl> + NameExpr scopeAsName = ( NameExpr ) wrappedNode . getScope ( ) ; <nl> SymbolReference symbolReference = this . solveType ( scopeAsName . getName ( ) , typeSolver ) ; <nl> if ( symbolReference . isSolved ( ) & & symbolReference . getCorrespondingDeclaration ( ) . isType ( ) ) { <nl> TypeDeclaration typeDeclaration = symbolReference . getCorrespondingDeclaration ( ) . asType ( ) ; <nl>  <nl> Type typeOfScope = null ; <nl> try { <nl> - typeOfScope = JavaParserFacade . get ( typeSolver ) . getType ( wrappedNode . getScope ( ) . get ( ) ) ; <nl> + typeOfScope = JavaParserFacade . get ( typeSolver ) . getType ( wrappedNode . getScope ( ) ) ; <nl> } catch ( Exception e ) { <nl> throw new RuntimeException ( String . format ( " Issur calculating the type of the scope of " + this ) , e ) ; <nl> } <nl> 
mmm a / thrifty - schema / src / main / java / com / microsoft / thrifty / schema / Linker . java <nl> ppp b / thrifty - schema / src / main / java / com / microsoft / thrifty / schema / Linker . java <nl> try { <nl> structType . link ( this ) ; <nl> } catch ( LinkFailureException e ) { <nl> - environment . addError ( <nl> - " Failed to resolve type " + e . getMessage ( ) + " referenced at " + structType . location ( ) ) ; <nl> + reporter . error ( structType . location ( ) , " Failed to resolve type ' " + e . getMessage ( ) + " ' " ) ; <nl> } <nl> } <nl> } <nl> 
mmm a / third - party / triemap / src / main / java / org / opendaylight / yangtools / triemap / TrieMap . java <nl> ppp b / third - party / triemap / src / main / java / org / opendaylight / yangtools / triemap / TrieMap . java <nl> public V put ( final K key , final V value ) { <nl> ensureReadWrite ( ) ; <nl> final int hc = computeHash ( key ) ; <nl> - final Option & lt ; V & gt ; ov = insertifhc ( key , hc , value , null ) ; <nl> - if ( ov instanceof Some ) { <nl> - Some & lt ; V & gt ; sv = ( Some & lt ; V & gt ; ) ov ; <nl> - return sv . get ( ) ; <nl> - } <nl> - <nl> - return null ; <nl> + return insertifhc ( key , hc , value , null ) . orElse ( null ) ; <nl> } <nl>  <nl> TrieMap & lt ; K , V & gt ; add ( final K k , final V v ) { <nl> 
mmm a / src / test / java / com / google / api / gax / grpc / UnaryCallableTest . java <nl> ppp b / src / test / java / com / google / api / gax / grpc / UnaryCallableTest . java <nl> @ Test ( expected = ValidationException . class ) <nl> public void pagedFixedSizeCollectionTooManyElements ( ) { <nl> Mockito . when ( callIntList . futureCall ( ( Integer ) Mockito . any ( ) , ( CallContext ) Mockito . any ( ) ) ) <nl> - . thenReturn ( Futures . & lt ; List & lt ; Integer & gt ; & gt ; immediateFuture ( Lists . newArrayList ( 0 , 1 , 2 ) ) ) <nl> - . thenReturn ( Futures . & lt ; List & lt ; Integer & gt ; & gt ; immediateFuture ( Lists . newArrayList ( 3 , 4 ) ) ) <nl> - . thenReturn ( Futures . immediateFuture ( Collections . & lt ; Integer & gt ; emptyList ( ) ) ) ; <nl> + . thenReturn ( immediateFuture ( Arrays . asList ( 0 , 1 , 2 ) ) ) <nl> + . thenReturn ( immediateFuture ( Arrays . asList ( 3 , 4 ) ) ) <nl> + . thenReturn ( immediateFuture ( Collections . & lt ; Integer & gt ; emptyList ( ) ) ) ; <nl>  <nl> UnaryCallable . & lt ; Integer , List & lt ; Integer & gt ; & gt ; create ( callIntList ) <nl> 
mmm a / test / FunctionalTest . java <nl> ppp b / test / FunctionalTest . java <nl> - } <nl> is . close ( ) ; <nl>  <nl> - Iterator & lt ; Result & lt ; Upload & gt ; & gt ; uploadIter = client . listIncompleteUploads ( bucketName , " minio " , true ) ; <nl> - for ( int i = 0 ; i & lt ; 10 ; i++ ) { <nl> - if ( uploadIter . hasNext ( ) ) { <nl> - Result r = uploadIter . next ( ) ; <nl> - println ( i , r . getResult ( ) ) ; <nl> - } else { <nl> + int i = 0 ; <nl> + for ( Result & lt ; Upload & gt ; r : client . listIncompleteUploads ( bucketName , " minio " , true ) ) { <nl> + println ( i++ , r . get ( ) ) ; <nl> + if ( i == 10 ) { <nl> break ; <nl> } <nl> + } <nl> 
mmm a / SimpleNewsProject / SimpleNews / src / main / java / de / dala / simplenews / ui / ExpandableNewsFragment . java <nl> ppp b / SimpleNewsProject / SimpleNews / src / main / java / de / dala / simplenews / ui / ExpandableNewsFragment . java <nl> - ShareActionProvider shareActionProvider = new ShareActionProvider ( getActivity ( ) ) ; <nl> - item . setActionProvider ( shareActionProvider ) ; <nl> - shareActionProvider . setShareHistoryFileName ( <nl> - ShareActionProvider . DEFAULT_SHARE_HISTORY_FILE_NAME ) ; <nl> - shareActionProvider . setShareIntent ( createShareIntent ( ) ) ; <nl> - shareActionProvider . setOnShareTargetSelectedListener ( new ShareActionProvider . OnShareTargetSelectedListener ( ) { <nl> - @ Override <nl> - public boolean onShareTargetSelected ( ShareActionProvider shareActionProvider , Intent intent ) { <nl> - return false ; <nl> + mode . getMenuInflater ( ) . inflate ( R . menu . contextual_list_view , menu ) ; <nl> + MenuItem item = menu . findItem ( R . id . menu_item_share ) ; <nl> + if ( item ! = null ) { <nl> + shareActionProvider = ( ShareActionProvider ) item . getActionProvider ( ) ; <nl> + if ( shareActionProvider ! = null ) { <nl> + String shareHistoryFileName = ShareActionProvider . DEFAULT_SHARE_HISTORY_FILE_NAME ; <nl> + shareActionProvider . setShareHistoryFileName ( shareHistoryFileName ) ; <nl> + shareActionProvider . setShareIntent ( getShareIntent ( ) ) ; <nl> + shareActionProvider . setOnShareTargetSelectedListener ( new ShareActionProvider . OnShareTargetSelectedListener ( ) { <nl> + @ Override <nl> + public boolean onShareTargetSelected ( ShareActionProvider shareActionProvider , Intent intent ) { <nl> + return false ; <nl> + } <nl> + } ) ; <nl> } <nl> - } ) ; <nl> + } <nl> return true ; <nl> - } <nl> 
mmm a / src / util / ConnectionManager . java <nl> ppp b / src / util / ConnectionManager . java <nl> System . out . println ( " Errore 401 " ) ; <nl> System . out . println ( " Token scaduto , richiesta nuovo token " ) ; <nl> ConnectionManager . tokenExpired = true ; <nl> - ConnectAndGetToken ( ) ; <nl> - getAnimeInformation ( animeID ) ; <nl> + attempts++ ; <nl> + if ( attempts & gt ; 5 ) <nl> + { <nl> + ConnectAndGetToken ( ) ; <nl> + getAnimeInformation ( animeID ) ; <nl> + attempts = 0 ; <nl> + } <nl> + else <nl> + JOptionPane . showMessageDialog ( AnimeIndex . frame , " Errore durante la connessione ! Potrebbe dipendere dalla tua connessione o dal sito di Anilist . " , " Errore ! " , JOptionPane . ERROR_MESSAGE ) ; <nl> } <nl> else <nl> + { <nl> 
mmm a / deeplearning4j - core / src / test / java / org / deeplearning4j / gradientcheck / CNNGradientCheckTest . java <nl> ppp b / deeplearning4j - core / src / test / java / org / deeplearning4j / gradientcheck / CNNGradientCheckTest . java <nl> + double [ ] l2vals = { 0 . 4 , 0 . 0 , 0 . 4 , 0 . 4 } ; <nl> + double [ ] l1vals = { 0 . 0 , 0 . 0 , 0 . 5 , 0 . 0 } ; <nl> + double [ ] biasL2 = { 0 . 0 , 0 . 0 , 0 . 0 , 0 . 2 } ; <nl> + double [ ] biasL1 = { 0 . 0 , 0 . 0 , 0 . 6 , 0 . 0 } ; <nl> + <nl> + for ( String afn : activFns ) { <nl> + for ( boolean doLearningFirst : characteristic ) { <nl> + for ( int i=0 ; i & lt ; lossFunctions . length ; i++ ) { <nl> + for ( int k = 0 ; k & lt ; l2vals . length ; k++ ) { <nl> + LossFunctions . LossFunction lf = lossFunctions [ i ] ; <nl> + String outputActivation = outputActivations [ i ] ; <nl> + double l2 = l2vals [ k ] ; <nl> + double l1 = l1vals [ k ] ; <nl> + <nl> MultiLayerConfiguration . Builder builder = new NeuralNetConfiguration . Builder ( ) <nl> . regularization ( true ) <nl> . l2 ( l2 ) . l1 ( l1 ) <nl> + . l2Bias ( biasL2 [ k ] ) . l1Bias ( biasL1 [ k ] ) <nl> . optimizationAlgo ( OptimizationAlgorithm . CONJUGATE_GRADIENT ) <nl> . seed ( 12345L ) <nl> . list ( ) <nl> 
mmm a / test / FunctionalTest . java <nl> ppp b / test / FunctionalTest . java <nl> - fileNames [ i ] = fileName ; <nl> } <nl>  <nl> - Iterator & lt ; Result & lt ; Item & gt ; & gt ; objectIter = client . listObjects ( bucketName ) ; <nl> - for ( int i = 0 ; i & lt ; 10 ; i++ ) { <nl> - if ( objectIter . hasNext ( ) ) { <nl> - Result r = objectIter . next ( ) ; <nl> - println ( i , r . getResult ( ) ) ; <nl> - } else { <nl> + i = 0 ; <nl> + for ( Result r : client . listObjects ( bucketName ) ) { <nl> + println ( i++ , r . get ( ) ) ; <nl> + if ( i == 10 ) { <nl> break ; <nl> } <nl> + } <nl> 
mmm a / src / main / java / reborncore / common / recipes / RecipeCrafter . java <nl> ppp b / src / main / java / reborncore / common / recipes / RecipeCrafter . java <nl> - for ( ItemStack input : recipeType . getInputs ( ) ) { <nl> - Boolean hasItem = false ; <nl> + if ( recipeType == null ) { <nl> + return false ; <nl> + } <nl> + for ( Object input : recipeType . getInputs ( ) ) { <nl> + boolean hasItem = false ; <nl> + boolean useOreDict = input instanceof String || recipeType . useOreDic ( ) ; <nl> + boolean checkSize = input instanceof ItemStack ; <nl> for ( int inputslot : inputSlots ) { <nl> - if ( ItemUtils . isItemEqual ( input , inventory . getStackInSlot ( inputslot ) , true , true , <nl> - recipeType . useOreDic ( ) ) & & inventory . getStackInSlot ( inputslot ) . getCount ( ) & gt ; = input . getCount ( ) ) { <nl> - hasItem = true ; <nl> - } <nl> - } <nl> + if ( ItemUtils . isInputEqual ( input , inventory . getStackInSlot ( inputslot ) , true , true , <nl> + useOreDict ) ) { <nl> + ItemStack stack = RecipeTranslator . getStackFromObject ( input ) ; <nl> + if ( ! checkSize || inventory . getStackInSlot ( inputslot ) . getCount ( ) & gt ; = stack . getCount ( ) ) { <nl> + hasItem = true ; <nl> + } <nl> 
mmm a / validator / src / main / java / com / networknt / validator / parameter / ArrayParameterValidator . java <nl> ppp b / validator / src / main / java / com / networknt / validator / parameter / ArrayParameterValidator . java <nl> - } <nl> - <nl> - public ValidationReport validate ( final Collection & lt ; String & gt ; values , final Parameter p ) { <nl> - final MutableValidationReport report = new MutableValidationReport ( ) ; <nl> - if ( p == null ) { <nl> - return report ; <nl> - } <nl> - <nl> final SerializableParameter parameter = ( SerializableParameter ) p ; <nl> if ( parameter . getRequired ( ) & & ( values == null || values . isEmpty ( ) ) ) { <nl> - return report . add ( messages . get ( " validation . request . parameter . missing " , parameter . getName ( ) ) ) ; <nl> + return new Status ( " ERR11001 " , parameter . getName ( ) ) ; <nl> } <nl>  <nl> if ( values == null ) { <nl> - return report ; <nl> + return null ; <nl> } <nl>  <nl> if ( ! parameter . getCollectionFormat ( ) . equalsIgnoreCase ( CollectionFormat . MULTI . name ( ) ) ) { <nl> - return report . add ( messages . get ( " validation . request . parameter . collection . invalidFormat " , <nl> - p . getName ( ) , parameter . getCollectionFormat ( ) , " multi " ) <nl> - ) ; <nl> + return new Status ( " ERR11005 " , p . getName ( ) , parameter . getCollectionFormat ( ) , " multi " ) ; <nl> } <nl>  <nl> - doValidate ( values , parameter , report ) ; <nl> - return report ; <nl> + return doValidate ( values , parameter ) ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / src / edu / umass / cs / gnsclient / console / commands / AclList . java <nl> ppp b / src / edu / umass / cs / gnsclient / console / commands / AclList . java <nl> + } <nl> + <nl> - JSONArray write = gnsClient . aclGet ( AclAccessType . WRITE_WHITELIST , module . getCurrentGuid ( ) , field , module <nl> - . getCurrentGuid ( ) . getGuid ( ) ) ; <nl> - console . printString ( " Write ACL : " + write . toString ( ) ) ; <nl> - console . printNewline ( ) ; <nl> - } <nl> - catch ( Exception e ) <nl> - { <nl> + if ( gnsClient . fieldAclExists ( AclAccessType . WRITE_WHITELIST , module . getCurrentGuid ( ) , field ) ) { <nl> + JSONArray write = gnsClient . aclGet ( AclAccessType . WRITE_WHITELIST , module . getCurrentGuid ( ) , field , module <nl> + . getCurrentGuid ( ) . getGuid ( ) ) ; <nl> + console . printString ( " Write ACL : " + write . toString ( ) ) ; <nl> + console . printNewline ( ) ; <nl> + } else { <nl> + console . printString ( " Write ACL for field " + field + " does not exist " ) ; <nl> + console . printNewline ( ) ; <nl> + } <nl> + } catch ( Exception e ) { <nl> 
mmm a / app / src / main / java / in / aviaryan / hinix / MainActivity . java <nl> ppp b / app / src / main / java / in / aviaryan / hinix / MainActivity . java <nl> for ( int i = 0 ; i & lt ; NUM_ROWS ; i++ ) { <nl> for ( int j = 0 ; j & lt ; NUM_COLS ; j++ ) { <nl> TextView tv = ( TextView ) findViewById ( fetchId ( i , j ) ) ; <nl> - tv . setBackground ( getDrawable ( R . drawable . my_border ) ) ; <nl> + if ( Build . VERSION . SDK_INT & gt ; =Build . VERSION_CODES . LOLLIPOP ) <nl> + tv . setBackground ( getDrawable ( R . drawable . my_border ) ) ; <nl> + else <nl> + tv . setBackgroundDrawable ( getResources ( ) . getDrawable ( R . drawable . my_border ) ) ; <nl> } <nl> } <nl> } <nl> 
mmm a / rt / rs / security / jose - parent / jose / src / main / java / org / apache / cxf / rs / security / jose / jws / JwsUtils . java <nl> ppp b / rt / rs / security / jose - parent / jose / src / main / java / org / apache / cxf / rs / security / jose / jws / JwsUtils . java <nl> + return algo ; <nl> } <nl> public static SignatureAlgorithm getSignatureAlgorithm ( Properties props , <nl> - SignatureAlgorithm defaultAlgo ) { <nl> - String algo = KeyManagementUtils . getKeyAlgorithm ( PhaseInterceptorChain . getCurrentMessage ( ) , <nl> - props , <nl> - JoseConstants . RSSEC_SIGNATURE_ALGORITHM , <nl> - defaultAlgo == null ? null : defaultAlgo . getJwaName ( ) ) ; <nl> - return SignatureAlgorithm . getAlgorithm ( algo ) ; <nl> + SignatureAlgorithm defaultAlgo ) { <nl> + return getSignatureAlgorithm ( PhaseInterceptorChain . getCurrentMessage ( ) , <nl> + props , defaultAlgo ) ; <nl> } <nl> - private static SignatureAlgorithm getDefaultKeyAlgorithm ( JsonWebKey jwk ) { <nl> - KeyType keyType = jwk . getKeyType ( ) ; <nl> + public static SignatureAlgorithm getSignatureAlgorithm ( Message m , <nl> 
mmm a / src / main / java / me / gnat008 / perworldinventory / data / players / PWIPlayerManager . java <nl> ppp b / src / main / java / me / gnat008 / perworldinventory / data / players / PWIPlayerManager . java <nl> + * @ param player The Player <nl> * @ return The PWIPlayer in the cache , or null <nl> * / <nl> public PWIPlayer getPlayer ( Group group , Player player ) { <nl> - String key = player . getUniqueId ( ) . toString ( ) + " . " + group . getName ( ) + " . " ; <nl> - if ( settings . getProperty ( PwiProperties . SEPARATE_GAMEMODE_INVENTORIES ) ) <nl> - key += player . getGameMode ( ) . toString ( ) . toLowerCase ( ) ; <nl> - else <nl> - key += " survival " ; <nl> + String key = makeKey ( player . getUniqueId ( ) , group , player . getGameMode ( ) ) ; <nl> + <nl> + return playerCache . get ( key ) ; <nl> + } <nl> 
mmm a / src / main / java / com / myapp / repository / UserRepositoryImpl . java <nl> ppp b / src / main / java / com / myapp / repository / UserRepositoryImpl . java <nl> - ) ; <nl> - query . orderBy ( cb . desc ( root . get ( " id " ) ) ) ; <nl> + Optional & lt ; Long & gt ; sinceId , <nl> + Optional & lt ; Long & gt ; maxId , <nl> + Integer maxSize ) { <nl> + final QUser qUser = QUser . user ; <nl> + final QRelationship qRelationship = QRelationship . relationship ; <nl>  <nl> - return entityManager <nl> - . createQuery ( query ) <nl> - . setMaxResults ( Optional . ofNullable ( maxSize ) . orElse ( 20 ) ) <nl> - . getResultList ( ) ; <nl> + final JPQLQuery & lt ; Relationship & gt ; relationshipSubQuery = JPAExpressions . selectFrom ( qRelationship ) <nl> + . where ( qRelationship . follower . eq ( user ) <nl> + . and ( qRelationship . followed . eq ( qUser ) ) <nl> + ) ; <nl> + return queryFactory . selectFrom ( qUser ) <nl> + . where ( relationshipSubQuery . exists ( ) <nl> + . and ( sinceId . map ( qUser . id : : gt ) . orElse ( null ) ) <nl> + . and ( maxId . map ( qUser . id : : lt ) . orElse ( null ) ) <nl> + ) <nl> + . orderBy ( qUser . id . desc ( ) ) <nl> + . limit ( Optional . ofNullable ( maxSize ) . orElse ( 20 ) ) <nl> + . fetch ( ) ; <nl> } <nl> 
mmm a / src / main / java / org / roaringbitmap / RunContainer . java <nl> ppp b / src / main / java / org / roaringbitmap / RunContainer . java <nl> + int start = 0 ; <nl> + for ( int rlepos = 0 ; rlepos & lt ; this . nbrruns ; ++rlepos ) { <nl> + int end = Util . toIntUnsigned ( this . getValue ( rlepos ) ) ; <nl> + int prevOnes = Util . cardinalityInBitmapRange ( answer . bitmap , start , end ) ; <nl> Util . resetBitmapRange ( answer . bitmap , start , end ) ; /  / had been x . bitmap <nl> + answer . updateCardinality ( prevOnes , 0 ) ; <nl> start = end + Util . toIntUnsigned ( this . getLength ( rlepos ) ) + 1 ; <nl> } <nl> - Util . resetBitmapRange ( answer . bitmap , start , Util . maxLowBitAsInteger ( ) + 1 ) ; /  / had been x . bitmap <nl> - answer . computeCardinality ( ) ; <nl> + int ones = Util . cardinalityInBitmapRange ( answer . bitmap , start , BitmapContainer . MAX_CAPACITY ) ; <nl> + Util . resetBitmapRange ( answer . bitmap , start , BitmapContainer . MAX_CAPACITY ) ; /  / had been x . bitmap <nl> + answer . updateCardinality ( ones , 0 ) ; <nl> if ( answer . getCardinality ( ) & gt ; ArrayContainer . DEFAULT_MAX_SIZE ) { <nl> return answer ; <nl> 
mmm a / src / peergos / shared / crypto / asymmetric / curve25519 / Ed25519SecretKey . java <nl> ppp b / src / peergos / shared / crypto / asymmetric / curve25519 / Ed25519SecretKey . java <nl> @ Override <nl> public CborObject toCbor ( ) { <nl> - Map & lt ; String , CborObject & gt ; cbor = new TreeMap & lt ; & gt ; ( ) ; <nl> - cbor . put ( " t " , new CborObject . CborLong ( type ( ) . value ) ) ; <nl> - cbor . put ( " k " , new CborObject . CborByteArray ( secretKey ) ) ; <nl> - return CborObject . CborMap . build ( cbor ) ; <nl> + return new CborObject . CborList ( Arrays . asList ( new CborObject . CborLong ( type ( ) . value ) , new CborObject . CborByteArray ( secretKey ) ) ) ; <nl> } <nl>  <nl> public byte [ ] signMessage ( byte [ ] message ) { <nl> 
mmm a / forge111 / src / main / java / com / boydti / fawe / forge / v111 / ForgeQueue_All . java <nl> ppp b / forge111 / src / main / java / com / boydti / fawe / forge / v111 / ForgeQueue_All . java <nl> @ Override <nl> - public Chunk getChunk ( World world , int x , int z ) { <nl> - Chunk chunk = world . getChunkProvider ( ) . provideChunk ( x , z ) ; <nl> - if ( chunk ! = null & & ! chunk . isLoaded ( ) ) { <nl> - chunk . onChunkLoad ( ) ; <nl> - } <nl> - return chunk ; <nl> + public Chunk getCachedChunk ( World world , int cx , int cz ) { <nl> + return world . getChunkProvider ( ) . getLoadedChunk ( cx , cz ) ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / sdk / com . ibm . sbt . core / src / main / java / com / ibm / sbt / services / client / connections / profiles / ProfileService . java <nl> ppp b / sdk / com . ibm . sbt . core / src / main / java / com / ibm / sbt / services / client / connections / profiles / ProfileService . java <nl> + } <nl> + <nl> protected EntityList & lt ; ColleagueConnection & gt ; getColleagueConnectionEntityList ( String requestUrl , Map & lt ; String , String & gt ; parameters ) throws ClientServicesException { <nl> - ColleagueConnection result = null ; <nl> - IFeedHandler & lt ; ColleagueConnection & gt ; handler = getColleagueFeedHandler ( ) ; <nl> - <nl> - Response response = getClientService ( ) . get ( requestUrl , parameters ) ; <nl> - <nl> - try { <nl> - checkResponseCode ( response , HTTPCode . OK ) ; <nl> - result = handler . createEntity ( response ) ; <nl> - } catch ( ClientServicesException cse ) { <nl> - checkResponseCode ( response , HTTPCode . NOT_FOUND ) ; <nl> - } <nl> - <nl> - return result ; <nl> + return getEntities ( requestUrl , parameters , getColleagueFeedHandler ( ) ) ; <nl> } <nl>  <nl> protected EntityList & lt ; Tag & gt ; getTagEntityList ( String requestUrl , Map & lt ; String , String & gt ; parameters ) throws ClientServicesException { <nl> 
mmm a / src / main / java / jp / classmethod / aws / gradle / cloudformation / AmazonCloudFormationMigrateStackTask . java <nl> ppp b / src / main / java / jp / classmethod / aws / gradle / cloudformation / AmazonCloudFormationMigrateStackTask . java <nl> + private void createStack ( AmazonCloudFormation cfn ) throws IOException { <nl> + String stackName = getStackName ( ) ; <nl> + String cfnTemplateUrl = getCfnTemplateUrl ( ) ; <nl> + List & lt ; Parameter & gt ; cfnStackParams = getCfnStackParams ( ) ; <nl> + List & lt ; Tag & gt ; cfnStackTags = getCfnStackTags ( ) ; <nl> + String cfnStackPolicyUrl = getCfnStackPolicyUrl ( ) ; <nl> + File cfnTemplateFile = getCfnTemplateFile ( ) ; <nl> + File cfnStackPolicyFile = getCfnStackPolicyFile ( ) ; <nl> + String cfnOnFailure = getCfnOnFailure ( ) ; <nl> + <nl> getLogger ( ) . info ( " create stack : { } " , stackName ) ; <nl>  <nl> CreateStackRequest req = new CreateStackRequest ( ) <nl> . withStackName ( stackName ) <nl> - . withTemplateURL ( cfnTemplateUrl ) <nl> . withParameters ( cfnStackParams ) <nl> - . withTags ( cfnStackTags ) ; <nl> + . withTags ( cfnStackTags ) <nl> + . withOnFailure ( cfnOnFailure ) ; <nl> + <nl> + if ( Strings . isNullOrEmpty ( cfnTemplateUrl ) == false ) { <nl> + req . setTemplateURL ( cfnTemplateUrl ) ; <nl> + } else { <nl> + req . setTemplateBody ( FileUtils . readFileToString ( cfnTemplateFile ) ) ; <nl> + } <nl> if ( isCapabilityIam ( ) ) { <nl> + req . setCapabilities ( Arrays . asList ( Capability . CAPABILITY_IAM . toString ( ) ) ) ; <nl> 
mmm a / kubernetes - client / src / main / java / io / fabric8 / kubernetes / client / dsl / internal / ReplicaSetOperationsImpl . java <nl> ppp b / kubernetes - client / src / main / java / io / fabric8 / kubernetes / client / dsl / internal / ReplicaSetOperationsImpl . java <nl> return rs ; <nl> } <nl>  <nl> - final CountDownLatch latch = new CountDownLatch ( 1 ) ; <nl> - Watcher & lt ; ReplicaSet & gt ; watcher = new ReadinessWatcher & lt ; & gt ; ( latch ) ; <nl> + ReadinessWatcher & lt ; ReplicaSet & gt ; watcher = new ReadinessWatcher & lt ; & gt ; ( rs . getKind ( ) , getName ( ) , getNamespace ( ) ) ; <nl> try ( Watch watch = watch ( watcher ) ) { <nl> - if ( latch . await ( amount , timeUnit ) ) { <nl> - return get ( ) ; <nl> - } <nl> + return watcher . await ( amount , timeUnit ) ; <nl> } <nl> - throw new KubernetesClientTimeoutException ( rs . getKind ( ) , getName ( ) , getNamespace ( ) , amount , timeUnit ) ; <nl> } <nl> - <nl> - private static class ReplicaSetReaper implements Reaper { <nl> 
mmm a / src / test / java / org / passay / IllegalCharacterRuleTest . java <nl> ppp b / src / test / java / org / passay / IllegalCharacterRuleTest . java <nl> return <nl> new Object [ ] [ ] { <nl>  <nl> - { rule , new PasswordData ( VALID_PASS ) , null , } , <nl> + { new IllegalCharacterRule ( new char [ ] { ' @ ' , ' $ ' } ) , new PasswordData ( " AycDPdsyz " ) , null , } , <nl> { <nl> - rule , <nl> - new PasswordData ( INVALID_PASS ) , <nl> + new IllegalCharacterRule ( new char [ ] { ' @ ' , ' $ ' } ) , <nl> + new PasswordData ( " AycD @ Pdsyz " ) , <nl> codes ( IllegalCharacterRule . ERROR_CODE ) , <nl> } , <nl> + { <nl> + new IllegalCharacterRule ( new char [ ] { ' @ ' , ' $ ' } ) , <nl> + new PasswordData ( " AycD @ Pd $ yz " ) , <nl> + codes ( IllegalCharacterRule . ERROR_CODE , IllegalCharacterRule . ERROR_CODE ) , <nl> + } , <nl> + { <nl> + new IllegalCharacterRule ( new char [ ] { ' @ ' , ' $ ' } , false ) , <nl> + new PasswordData ( " AycD @ Pd $ yz " ) , <nl> + codes ( IllegalCharacterRule . ERROR_CODE ) , <nl> + } , <nl> + { <nl> + new IllegalCharacterRule ( new char [ ] { ' @ ' , ' $ ' } ) , <nl> + new PasswordData ( " AycD @ Pd $ yz @ " ) , <nl> + codes ( IllegalCharacterRule . ERROR_CODE , IllegalCharacterRule . ERROR_CODE ) , <nl> + } , <nl> } ; <nl> } <nl> 
mmm a / api / api - agi / src / main / java / org / astivetoolkit / agi / fastagi / FastAgiResponse . java <nl> ppp b / api / api - agi / src / main / java / org / astivetoolkit / agi / fastagi / FastAgiResponse . java <nl> throws AgiException { <nl> SayAlpha command = new SayAlpha ( text ) ; <nl>  <nl> - return cHandler . sendAgiCommand ( command ) . getResultCodeAsChar ( ) ; <nl> + AgiCommandReply acr = cHandler . sendAgiCommand ( command ) ; <nl> + <nl> + if ( acr . getResultCode ( ) == - 1 ) { <nl> + throw new AgiException ( AppLocale . getI18n ( " errorChannelErrorOrDisconnected " ) ) ; <nl> + } <nl> + <nl> + return acr . getResultCodeAsChar ( ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / user / super / com / google / gwt / emul / java / util / Arrays . java <nl> ppp b / user / super / com / google / gwt / emul / java / util / Arrays . java <nl> + return copyPrimitiveArray ( original , new boolean [ to - from ] , from , to ) ; <nl> } <nl>  <nl> public static byte [ ] copyOfRange ( byte [ ] original , int from , int to ) { <nl> - int len = getCopyLength ( original , from , to ) ; <nl> - byte [ ] copy = new byte [ to - from ] ; <nl> - ArrayHelper . copy ( original , from , copy , 0 , len ) ; <nl> - return copy ; <nl> + checkCopyOfRange ( original , from , to ) ; <nl> + return copyPrimitiveArray ( original , new byte [ to - from ] , from , to ) ; <nl> } <nl>  <nl> public static char [ ] copyOfRange ( char [ ] original , int from , int to ) { <nl> 
mmm a / megamek / src / megamek / common / MiscType . java <nl> ppp b / megamek / src / megamek / common / MiscType . java <nl> - public static MiscType createEngineeringSuitInfArmor ( ) { <nl> + } <nl> + <nl> + public static MiscType createISEngineeringSuitInfArmor ( ) { <nl> MiscType misc = new MiscType ( ) ; <nl>  <nl> - misc . techLevel . put ( 3071 , TechConstants . T_ALL ) ; <nl> misc . name = " Engineering Suit " ; <nl> misc . setInternalName ( misc . name ) ; <nl> - misc . addLookupName ( " EngineeringSuit " ) ; <nl> + misc . addLookupName ( " ISEngineeringSuit " ) ; <nl> misc . damageDivisor = 1 . 0 ; <nl> misc . subType = S_ENCUMBERING | S_SPACE_SUIT ; <nl> misc . cost = 7500 ; <nl> - misc . availRating = new int [ ] { EquipmentType . RATING_D , EquipmentType . RATING_D , EquipmentType . RATING_D } ; <nl> misc . flags = misc . flags . or ( F_INF_EQUIPMENT ) . or ( F_ARMOR_KIT ) ; <nl> - misc . introDate = 2350 ; <nl> - misc . techLevel . put ( 2350 , misc . techLevel . get ( 3071 ) ) ; <nl> + misc . introDate = 2335 ; <nl> + misc . techLevel . put ( 2335 , TechConstants . T_IS_EXPERIMENTAL ) ; <nl> + misc . techLevel . put ( 2350 , TechConstants . T_IS_ADVANCED ) ; <nl> + misc . techLevel . put ( 2351 , TechConstants . T_IS_TW_NON_BOX ) ; <nl> + misc . availRating = new int [ ] { RATING_D , RATING_D , RATING_D , RATING_C } ; <nl> misc . techRating = RATING_D ; <nl> - <nl> - return misc ; <nl> + misc . rulesRefs = " 317 , TO " ; <nl> 
mmm a / auto - project / auto - ui / src / main / java / jp / primecloud / auto / ui / WinLoadBalancerAdd . java <nl> ppp b / auto - project / auto - ui / src / main / java / jp / primecloud / auto / ui / WinLoadBalancerAdd . java <nl> - } <nl> + private void loadData ( ) { <nl> + LoadBalancerService loadBalancerService = BeanContext . getBean ( LoadBalancerService . class ) ; <nl> + platforms = loadBalancerService . getPlatforms ( ViewContext . getUserNo ( ) ) ; <nl>  <nl> - private void initData ( ) { <nl> - Long userNo = ViewContext . getUserNo ( ) ; <nl> - Long farmNo = ViewContext . getFarmNo ( ) ; <nl> - <nl> + for ( int i = platforms . size ( ) - 1 ; i & gt ; = 0 ; i -  - ) { <nl> + if ( BooleanUtils . isNotTrue ( platforms . get ( i ) . getPlatform ( ) . getSelectable ( ) ) ) { <nl> + platforms . remove ( i ) ; <nl> + } <nl> + } <nl> 
mmm a / openid - connect - server / src / main / java / org / mitre / openid / connect / view / UserInfoJWTView . java <nl> ppp b / openid - connect - server / src / main / java / org / mitre / openid / connect / view / UserInfoJWTView . java <nl> - JWTClaimsSet claims = JWTClaimsSet . parse ( writer . toString ( ) ) ; <nl> - <nl> - claims . setAudience ( Lists . newArrayList ( client . getClientId ( ) ) ) ; <nl> - <nl> - claims . setIssuer ( config . getIssuer ( ) ) ; <nl> - <nl> - claims . setIssueTime ( new Date ( ) ) ; <nl> - <nl> - claims . setJWTID ( UUID . randomUUID ( ) . toString ( ) ) ; /  / set a random NONCE in the middle of it <nl> + response . setContentType ( JOSE_MEDIA_TYPE_VALUE ) ; <nl> + <nl> + JWTClaimsSet claims = new JWTClaimsSet . Builder ( JWTClaimsSet . parse ( writer . toString ( ) ) ) <nl> + . audience ( Lists . newArrayList ( client . getClientId ( ) ) ) <nl> + . issuer ( config . getIssuer ( ) ) <nl> + . issueTime ( new Date ( ) ) <nl> + . jwtID ( UUID . randomUUID ( ) . toString ( ) ) /  / set a random NONCE in the middle of it <nl> + . build ( ) ; <nl>  <nl>  <nl> if ( client . getUserInfoEncryptedResponseAlg ( ) ! = null & & ! client . getUserInfoEncryptedResponseAlg ( ) . equals ( Algorithm . NONE ) <nl> 
mmm a / eventstore / src / test / java / no / ks / eventstore2 / projection / ProjectionManagerTest . java <nl> ppp b / eventstore / src / test / java / no / ks / eventstore2 / projection / ProjectionManagerTest . java <nl> - @ Test <nl> public void testProjectionManagerCreatesProjections ( ) throws Exception { <nl>  <nl> - final ActorRef eventstore = super . testActor ( ) ; <nl> + List & lt ; Props & gt ; factories = new ArrayList & lt ; & gt ; ( ) ; <nl> + factories . add ( Props . create ( FormStatuses . class , super . testActor ( ) ) ) ; <nl>  <nl> - ProjectionFactory projectionFactory = new ProjectionFactory ( eventstore ) { <nl> - @ Override <nl> - public Class & lt ; ? extends Projection & gt ; getProjectionClass ( ) { <nl> - return FormStatuses . class ; <nl> - } <nl> - <nl> - public Actor create ( ) throws Exception { <nl> - return new FormStatuses ( eventstore ) ; <nl> - } <nl> - } ; <nl> - <nl> - List & lt ; ProjectionFactory & gt ; factories = new ArrayList & lt ; ProjectionFactory & gt ; ( ) ; <nl> - factories . add ( projectionFactory ) ; <nl> - <nl> - final TestActorRef & lt ; ProjectionManager & gt ; ref = TestActorRef . create ( _system , new Props ( new ProjectionManagerFactory ( factories , super . testActor ( ) ) ) , " projectionManager " ) ; <nl> + final TestActorRef & lt ; ProjectionManager & gt ; ref = TestActorRef . create ( _system , ProjectionManager . mkProps ( super . testActor ( ) , factories ) , " projectionManager " ) ; <nl>  <nl> Future & lt ; Object & gt ; getProjectionref = ask ( ref , call ( " getProjectionRef " , FormStatuses . class ) , 3000 ) ; <nl> 
mmm a / SoulissApp / src / main / java / it / angelic / soulissclient / AddProgramActivity . java <nl> ppp b / SoulissApp / src / main / java / it / angelic / soulissclient / AddProgramActivity . java <nl> - spinnerArrVal = getResources ( ) . getIntArray ( R . array . scheduleIntervalValues ) ; <nl> - ImageView nodeic = ( ImageView ) findViewById ( R . id . timed_icon ) ; <nl> - tvcommand = ( TextView ) findViewById ( R . id . textViewCommand ) ; <nl> - nodeic . setColorFilter ( getResources ( ) . getColor ( R . color . aa_violet ) , android . graphics . PorterDuff . Mode . SRC_ATOP ) ; <nl> - <nl> - ImageView nodeic2 = ( ImageView ) findViewById ( R . id . position_icon ) ; <nl> - nodeic2 . setColorFilter ( getResources ( ) . getColor ( R . color . aa_blue ) , android . graphics . PorterDuff . Mode . SRC_ATOP ) ; <nl> - <nl> - ImageView nodeic3 = ( ImageView ) findViewById ( R . id . triggered_icon ) ; <nl> - nodeic3 . setColorFilter ( getResources ( ) . getColor ( R . color . aa_red ) , android . graphics . PorterDuff . Mode . SRC_ATOP ) ; <nl> + FontAwesomeUtil . prepareFontAweTextView ( AddProgramActivity . this , nodeic2 , FontAwesomeEnum . fa_sign_out . getFontName ( ) ) ; <nl> + TextView nodeic3 = ( TextView ) findViewById ( R . id . triggered_icon ) ; <nl> + nodeic3 . setTextColor ( ContextCompat . getColor ( AddProgramActivity . this , R . color . md_light_blue_900 ) ) ; <nl> + FontAwesomeUtil . prepareFontAweTextView ( AddProgramActivity . this , nodeic3 , FontAwesomeEnum . fa_puzzle_piece . getFontName ( ) ) ; <nl>  <nl> List & lt ; SoulissNode & gt ; goer = datasource . getAllNodes ( ) ; <nl> 
mmm a / main / src / main / java / de / learnlib / alex / rest / CounterResource . java <nl> ppp b / main / src / main / java / de / learnlib / alex / rest / CounterResource . java <nl> User user = ( ( UserPrincipal ) securityContext . getUserPrincipal ( ) ) . getUser ( ) ; <nl> LOGGER . traceEntry ( " deleteCounter ( { } , { } ) for user { } . " , projectId , names , user ) ; <nl>  <nl> - try { <nl> - counterDAO . delete ( user . getId ( ) , projectId , names . toArray ( new String [ names . size ( ) ] ) ) ; <nl> + counterDAO . delete ( user . getId ( ) , projectId , names . toArray ( new String [ names . size ( ) ] ) ) ; <nl>  <nl> - LOGGER . traceExit ( " Counter ( s ) { } deleted . " , names ) ; <nl> - return Response . status ( Response . Status . NO_CONTENT ) . build ( ) ; <nl> - } catch ( NotFoundException e ) { <nl> - LOGGER . traceExit ( e ) ; <nl> - return ResourceErrorHandler . createRESTErrorMessage ( " CounterResource . deleteCounter " , <nl> - Response . Status . NOT_FOUND , <nl> - e ) ; <nl> - } <nl> + LOGGER . traceExit ( " Counter ( s ) { } deleted . " , names ) ; <nl> + return Response . status ( Response . Status . NO_CONTENT ) . build ( ) ; <nl>  <nl> } <nl> 
mmm a / src / me / ryanhamshire / griefprevention / listener / PlayerEventHandler . java <nl> ppp b / src / me / ryanhamshire / griefprevention / listener / PlayerEventHandler . java <nl> final GPPlayerData playerData = this . dataStore . getOrCreatePlayerData ( location . getExtent ( ) , player . getUniqueId ( ) ) ; <nl> final GPClaim claim = this . dataStore . getClaimAtPlayer ( playerData , location , false ) ; <nl>  <nl> - if ( GPPermissionHandler . getFlagOverride ( claim , GPPermissions . INTERACT_BLOCK_PRIMARY , player , clickedBlock . getState ( ) ) == Tristate . FALSE ) { <nl> + Tristate override = GPPermissionHandler . getFlagOverride ( claim , GPPermissions . INTERACT_BLOCK_PRIMARY , player , clickedBlock . getState ( ) ) ; <nl> + if ( override ! = Tristate . UNDEFINED ) { <nl> + if ( override == Tristate . TRUE ) { <nl> + GPTimings . PLAYER_INTERACT_BLOCK_PRIMARY_EVENT . stopTimingIfSync ( ) ; <nl> + return ; <nl> + } <nl> + <nl> event . setCancelled ( true ) ; <nl> - GPTimings . PLAYER_INTERACT_BLOCK_PRIMARY_EVENT . stopTimingIfSync ( ) ; <nl> GriefPreventionPlugin . addEventLogEntry ( event , claim , location , GPPermissions . INTERACT_BLOCK_PRIMARY , player , clickedBlock . getState ( ) , player , " " ) ; <nl> + GPTimings . PLAYER_INTERACT_BLOCK_PRIMARY_EVENT . stopTimingIfSync ( ) ; <nl> return ; <nl> } <nl> 
mmm a / optaplanner - core / src / test / java / org / optaplanner / core / api / score / buildin / hardmediumsoft / HardMediumSoftScoreHolderTest . java <nl> ppp b / optaplanner - core / src / test / java / org / optaplanner / core / api / score / buildin / hardmediumsoft / HardMediumSoftScoreHolderTest . java <nl> - scoreHolder . addSoftConstraintMatch ( mockRuleContext ( " scoreRule4 " ) , - 4 ) ; <nl> + scoreHolder . addSoftConstraintMatch ( soft1 , - 100 ) ; <nl> + scoreHolder . addSoftConstraintMatch ( soft1 , - 300 ) ; /  / Overwrite existing <nl>  <nl> - RuleContext ruleContext5 = mockRuleContext ( " scoreRule5 " ) ; <nl> - scoreHolder . addHardConstraintMatch ( ruleContext5 , - 1 ) ; <nl> - scoreHolder . addSoftConstraintMatch ( ruleContext5 , - 1 ) ; /  / Different score level <nl> - callUnMatch ( ruleContext5 ) ; <nl> + RuleContext multi1 = mockRuleContext ( " multi1 " ) ; <nl> + scoreHolder . addMultiConstraintMatch ( multi1 , - 1000 , - 10000 , - 100000 ) ; <nl> + scoreHolder . addMultiConstraintMatch ( multi1 , - 4000 , - 50000 , - 600000 ) ; /  / Overwrite existing <nl> + <nl> + RuleContext hard3 = mockRuleContext ( " hard3 " ) ; <nl> + scoreHolder . addHardConstraintMatch ( hard3 , - 1000000 ) ; <nl> + scoreHolder . addHardConstraintMatch ( hard3 , - 7000000 ) ; /  / Overwrite existing <nl> + <nl> + RuleContext soft2Undo = mockRuleContext ( " soft2Undo " ) ; <nl> + scoreHolder . addSoftConstraintMatch ( soft2Undo , - 99 ) ; <nl> + callUnMatch ( soft2Undo ) ; <nl> + <nl> + RuleContext multi2Undo = mockRuleContext ( " multi2Undo " ) ; <nl> + scoreHolder . addMultiConstraintMatch ( multi2Undo , - 999 , - 999 , - 999 ) ; <nl> + callUnMatch ( multi2Undo ) ; <nl> + <nl> + RuleContext medium2Undo = mockRuleContext ( " medium2Undo " ) ; <nl> + scoreHolder . addMediumConstraintMatch ( medium2Undo , - 9999 ) ; <nl> 
mmm a / org . eclipse . january / src / org / eclipse / january / dataset / AbstractCompoundDataset . java <nl> ppp b / org . eclipse . january / src / org / eclipse / january / dataset / AbstractCompoundDataset . java <nl> + return es ; <nl> } <nl>  <nl> private double [ ] getInternalErrorArray ( final boolean squared , final int .  .  . pos ) { <nl> - Dataset sed = squared ? getInternalSquaredError ( ) : getInternalError ( ) ; <nl> + Dataset sed = getInternalError ( squared ) ; <nl> if ( sed == null ) <nl> return null ; <nl>  <nl> - BroadcastStride bs = ( BroadcastStride ) getStoredValue ( STORE_BROADCAST ) ; <nl> - int n = bs . get1DIndex ( pos ) ; <nl> double [ ] es = new double [ isize ] ; <nl> if ( sed instanceof CompoundDoubleDataset ) { <nl> - ( ( CompoundDoubleDataset ) sed ) . getDoubleArrayAbs ( n , es ) ; <nl> + es = ( ( CompoundDoubleDataset ) sed ) . getDoubleArray ( pos ) ; <nl> if ( sed . getElementsPerItem ( ) ! = isize ) { /  / ensure error is broadcasted <nl> Arrays . fill ( es , es [ 0 ] ) ; <nl> } <nl> 
mmm a / app / src / main / java / tech / ozak / sportmix / fragment / SabahFragment . java <nl> ppp b / app / src / main / java / tech / ozak / sportmix / fragment / SabahFragment . java <nl> private void fillTheData ( ) { <nl> ListActivity splashActivity = ListActivity . getInstance ( ) ; <nl> - if ( ! splashActivity . getRssItems ( ) . equals ( Collections . EMPTY_LIST ) ) { <nl> + if ( splashActivity . getRssItems ( ) ! =null & & splashActivity . getRssItems ( ) . size ( ) & gt ; 0 ) { <nl> rssItems . addAll ( splashActivity . getRssItems ( ) ) ; <nl>  <nl> ListView listView = ( ListView ) v . findViewById ( R . id . postListView ) ; <nl> + <nl> + itemAdapter = new PostItemAdapter ( getActivity ( ) , <nl> + R . layout . postitem , rssItems ) ; <nl> + <nl> + <nl> + SwingBottomInAnimationAdapter swingBottomInAnimationAdapter = new SwingBottomInAnimationAdapter ( itemAdapter ) ; <nl> + <nl> + swingBottomInAnimationAdapter . setAbsListView ( listView ) ; <nl> + <nl> + listView . setAdapter ( swingBottomInAnimationAdapter ) ; <nl> + swipeRefreshLayout . setRefreshing ( false ) ; <nl> + } <nl> + else { <nl> + Toast . makeText ( getActivity ( ) , " LÃ¼tfen DiÄer haber kaynaklarÄ±nÄ± inceleyiniz .  .  . " , Toast . LENGTH_LONG ) ; <nl> + } <nl> + } <nl> 
mmm a / sdk / src / main / java / com / silanis / esl / sdk / internal / converter / VisibilityConverter . java <nl> ppp b / sdk / src / main / java / com / silanis / esl / sdk / internal / converter / VisibilityConverter . java <nl> return sdkVisibility ; <nl> } <nl>  <nl> - Visibility [ ] visibilities = Visibility . values ( ) ; <nl> - for ( Visibility visibility : visibilities ) { <nl> - if ( apiVisibility . equals ( visibility . getApiValue ( ) ) ) { <nl> - return visibility ; <nl> - } <nl> + try { <nl> + return Iterables . find ( Arrays . asList ( Visibility . values ( ) ) , new Predicate & lt ; Visibility & gt ; ( ) { <nl> + public boolean apply ( Visibility visibility ) { <nl> + return apiVisibility . equals ( visibility . getApiValue ( ) ) ; <nl> + } <nl> + } ) ; <nl> + } catch ( NoSuchElementException e ) { <nl> + return Visibility . UNRECOGNIZED ( apiVisibility ) ; <nl> } <nl> - return Visibility . UNRECOGNIZED ( apiVisibility ) ; <nl> } <nl> - <nl> - public String toAPIVisibility ( ) { <nl> 
mmm a / nakadi - java - client / src / main / java / nakadi / OkHttpResource . java <nl> ppp b / nakadi - java - client / src / main / java / nakadi / OkHttpResource . java <nl> public & lt ; Res & gt ; Res requestThrowing ( String method , String url , ResourceOptions options , <nl> Class & lt ; Res & gt ; res ) throws NakadiException { <nl>  <nl> - if ( null == retryPolicy ) { <nl> - Response response = requestThrowingInner ( method , url , options ) ; <nl> - return marshalResponse ( response , res ) ; <nl> - } else { <nl> - Observable & lt ; Response & gt ; observable = Observable . defer ( <nl> - ( ) - & gt ; Observable . just ( requestThrowingInner ( method , url , options ) ) <nl> - ) . compose ( buildRetry ( retryPolicy ) ) ; <nl> + Observable & lt ; Response & gt ; observable = <nl> + Observable . defer ( ( ) - & gt ; Observable . just ( requestThrowingInner ( method , url , options ) ) ) ; <nl>  <nl> - Response response = observable . toBlocking ( ) . first ( ) ; <nl> - return marshalResponse ( response , res ) ; <nl> + Response response = maybeComposeRetryPolicy ( observable ) . toBlocking ( ) . first ( ) ; <nl> + return marshalResponse ( response , res ) ; <nl> + } <nl> 
mmm a / compact - hash - map - java / CompactHashMap . java <nl> ppp b / compact - hash - map - java / CompactHashMap . java <nl> + throw new NullPointerException ( ) ; <nl> if ( ! translator . isKeyInstance ( key ) ) <nl> return false ; <nl> - @ SuppressWarnings ( " unchecked " ) <nl> - Object chain = table [ getIndex ( ( K ) key ) ] ; <nl> - if ( chain == null ) <nl> - return false ; <nl> - while ( true ) { <nl> - if ( chain instanceof byte [ ] ) <nl> - return equals ( key , ( byte [ ] ) chain ) ; <nl> - else { /  / chain instanceof Node <nl> - Node node = ( Node ) chain ; <nl> - if ( equals ( key , node . object ) ) <nl> - return true ; <nl> - chain = node . next ; <nl> - } <nl> - } <nl> + return probe ( ( K ) key ) & gt ; = 0 ; <nl> } <nl> + <nl> + <nl> 
mmm a / src / main / java / com / net2plan / documentation / CreateHTMLKeywords . java <nl> ppp b / src / main / java / com / net2plan / documentation / CreateHTMLKeywords . java <nl> { <nl> final ClassDoc javaClass = classes [ i ] ; <nl> final String className = javaClass . qualifiedName ( ) ; <nl> - final String firstSentenceThisClass = javaClass . firstSentenceTags ( ) [ 0 ] . text ( ) ; <nl> + final Tag [ ] firstSentenceTags = javaClass . firstSentenceTags ( ) ; <nl> + if ( firstSentenceTags . length == 0 ) System . out . println ( " A class without first sentence ! ! : " + className ) ; <nl> + final String firstSentenceThisClass = ( firstSentenceTags . length == 0 ) ? " " : javaClass . firstSentenceTags ( ) [ 0 ] . text ( ) ; <nl> algorithmToFirstSentence . put ( className , firstSentenceThisClass ) ; <nl> algorithmToKeywordsMap . put ( className , new LinkedList & lt ; String & gt ; ( ) ) ; <nl> String keywordsString = " " ; for ( Tag tag : javaClass . tags ( ) ) { if ( tag . name ( ) . equals ( " @ " +tagName ) ) keywordsString += " " + tag . text ( ) + " " ; } <nl> 
mmm a / single - module / src / main / java / net / chrisrichardson / eventstore / examples / todolist / queryside / TodoQueryService . java <nl> ppp b / single - module / src / main / java / net / chrisrichardson / eventstore / examples / todolist / queryside / TodoQueryService . java <nl> } <nl>  <nl> - public Optional & lt ; Todo & gt ; findById ( String id ) { <nl> - return Optional . of ( repository . findOne ( id ) ) ; <nl> + public CompletableFuture & lt ; Todo & gt ; findById ( String todoId ) { <nl> + Todo res = repository . findOne ( todoId ) ; <nl> + if ( res ! = null ) { <nl> + return CompletableFuture . completedFuture ( res ) ; <nl> + } <nl> + return CompletableFutureUtil . failedFuture ( new NoSuchElementException ( " No todo with given id found " ) ) ; <nl> } <nl> - <nl> - public Observable & lt ; Todo & gt ; findById ( EntityIdentifier todoId ) { <nl> 
mmm a / hazelcast - hibernate3 / src / main / java / com / hazelcast / hibernate / instance / HazelcastInstanceFactory . java <nl> ppp b / hazelcast - hibernate3 / src / main / java / com / hazelcast / hibernate / instance / HazelcastInstanceFactory . java <nl> - } <nl> - <nl> - private static Class getInstanceLoaderClass ( Properties props , boolean useNativeClient ) throws ClassNotFoundException { <nl> - if ( props ! = null ) { <nl> - useNativeClient = CacheEnvironment . isNativeClient ( props ) ; <nl> - } <nl> - Class loaderClass = null ; <nl> + private static Class getInstanceLoaderClass ( Properties props ) throws ClassNotFoundException { <nl> ClassLoader cl = HazelcastInstanceFactory . class . getClassLoader ( ) ; <nl> - if ( useNativeClient ) { <nl> - loaderClass = cl . loadClass ( HZ_CLIENT_LOADER_CLASSNAME ) ; <nl> + if ( props ! = null & & CacheEnvironment . isNativeClient ( props ) ) { <nl> + return cl . loadClass ( HZ_CLIENT_LOADER_CLASSNAME ) ; <nl> } else { <nl> - loaderClass = cl . loadClass ( HZ_INSTANCE_LOADER_CLASSNAME ) ; <nl> + return cl . loadClass ( HZ_INSTANCE_LOADER_CLASSNAME ) ; <nl> } <nl> - return loaderClass ; <nl> } <nl> } <nl> 
mmm a / ctk - transport / src / main / java / org / ga4gh / ctk / transport / protocols / Client . java <nl> ppp b / ctk - transport / src / main / java / org / ga4gh / ctk / transport / protocols / Client . java <nl> - @ Override <nl> - public SearchPhenotypeAssociationSetsResponse searchPhenotypeAssociationSets ( SearchPhenotypeAssociationSetsRequest request ) throws AvroRemoteException , GAException { <nl> - String path = urls . getSearchPhenotypeAssociationSets ( ) ; <nl> - SearchPhenotypeAssociationSetsResponse response = new SearchPhenotypeAssociationSetsResponse ( ) ; <nl> - final AvroJson aj = <nl> - new AvroJson & lt ; & gt ; ( request , response , urls . getUrlRoot ( ) , path , wireTracker ) ; <nl> - response = ( SearchPhenotypeAssociationSetsResponse ) aj . doPostResp ( ) ; <nl> - return response ; <nl> + public SearchPhenotypeAssociationSetsResponse searchPhenotypeAssociationSets ( SearchPhenotypeAssociationSetsRequest request ) throws InvalidProtocolBufferException , GAWrapperException , UnirestException { <nl> + String path = urls . getPhenotypes ( ) ; <nl> + SearchPhenotypeAssociationSetsResponse . Builder builder = SearchPhenotypeAssociationSetsResponse . newBuilder ( ) ; <nl> + new Post & lt ; & gt ; ( urls . getUrlRoot ( ) , path , request , builder , wireTracker ) . performQuery ( ) ; <nl> + return builder . build ( ) ; <nl> } <nl> } <nl> + } <nl> 
mmm a / src / graphtea / extensions / reports / hamilton / HamiltonianPathExtension . java <nl> ppp b / src / graphtea / extensions / reports / hamilton / HamiltonianPathExtension . java <nl> + SubGraph sg = new SubGraph ( ) ; <nl> + <nl> HamiltonianCycle hc = new HamiltonianCycle ( ) ; <nl> double [ ] [ ] adj = g . getAdjacencyMatrix ( ) . getArray ( ) ; <nl> - int [ ] [ ] adjMatrix = new int [ g . getVerticesCount ( ) ] <nl> - [ g . getVerticesCount ( ) ] ; <nl> + int [ ] [ ] adjMatrix = Utils . getBinaryPattern ( adj , g . getVerticesCount ( ) ) ; <nl> + int [ ] path = hc . HamiltonCycle ( adjMatrix ) ; <nl>  <nl> - for ( int i=0 ; i & lt ; g . getVerticesCount ( ) ; i++ ) { <nl> - for ( int j=0 ; j & lt ; g . getVerticesCount ( ) ; j++ ) { <nl> - if ( adj [ i ] [ j ] == 0 ) adjMatrix [ i ] [ j ] =0 ; <nl> - else adjMatrix [ i ] [ j ] =1 ; <nl> - } <nl> - } <nl> + if ( path == null ) return sg ; <nl> 
mmm a / pax - logging - log4j2 / src / main / java / org / ops4j / pax / logging / log4j2 / internal / PaxLoggerImpl . java <nl> ppp b / pax - logging - log4j2 / src / main / java / org / ops4j / pax / logging / log4j2 / internal / PaxLoggerImpl . java <nl> + } <nl> + } <nl> + <nl> + public void trace ( String message , Throwable t , String fqcn ) <nl> + { <nl> if ( isTraceEnabled ( ) ) <nl> { <nl> - setDelegateContext ( ) ; <nl> - Message msg = m_delegate . getMessageFactory ( ) . newMessage ( message ) ; <nl> - m_delegate . logMessage ( fqcn , Level . TRACE , null , msg , t ) ; <nl> - clearDelegateContext ( ) ; <nl> - m_service . handleEvents ( m_bundle , null , LogService . LOG_DEBUG , message , t ) ; <nl> + doLog ( Level . TRACE , LogService . LOG_DEBUG , fqcn , message , t ) ; <nl> } <nl> } <nl> 
mmm a / src / test / java / net / sf / oval / test / guard / PrePostJavascriptTest . java <nl> ppp b / src / test / java / net / sf / oval / test / guard / PrePostJavascriptTest . java <nl> + final Guard guard = new Guard ( ) ; <nl> + TestGuardAspect . aspectOf ( ) . setGuard ( guard ) ; <nl> + <nl> + final TestTransaction t = new TestTransaction ( ) ; <nl> + <nl> try <nl> { <nl> - t . increase1 ( new BigDecimal ( 1 ) ) ; <nl> + t . increase ( BigDecimal . valueOf ( 1 ) ) ; <nl> fail ( ) ; <nl> } <nl> catch ( final ConstraintsViolatedException ex ) <nl> assertEquals ( ex . getConstraintViolations ( ) [ 0 ] . getMessage ( ) , " PRE " ) ; <nl> } <nl>  <nl> + t . value = BigDecimal . valueOf ( 2 ) ; <nl> try <nl> { <nl> - t . value = new BigDecimal ( 2 ) ; <nl> - t . increase1 ( null ) ; <nl> + t . increase ( null ) ; <nl> fail ( ) ; <nl> } <nl> catch ( final ConstraintsViolatedException ex ) <nl> } <nl> try <nl> { <nl> - t . increase1 ( new BigDecimal ( 1 ) ) ; <nl> + t . increase ( BigDecimal . valueOf ( 1 ) ) ; <nl> } <nl> catch ( final ConstraintsViolatedException ex ) <nl> { <nl> 
mmm a / easyreport - web / src / main / java / com / easytoolsoft / easyreport / web / controller / metadata / ConfController . java <nl> ppp b / easyreport - web / src / main / java / com / easytoolsoft / easyreport / web / controller / metadata / ConfController . java <nl> @ RequestMapping ( value = " / remove " ) <nl> - public JsonResult remove ( int id , HttpServletRequest req ) { <nl> + public JsonResult remove ( int id ) { <nl> JsonResult & lt ; String & gt ; result = new JsonResult & lt ; & gt ; ( ) ; <nl> - try { <nl> - this . confService . removeById ( id ) ; <nl> - this . logSuccessResult ( result , String . format ( " å é¤é ? ç½®é¡¹ [ ID : % s ] æ ? ä½æ ? å ! " , id ) , req ) ; <nl> - } catch ( Exception ex ) { <nl> - result . setMsg ( String . format ( " å é¤é ? ç½®é¡¹ [ ID : % s ] æ ? ä½å¤±è´¥ ! " , id ) ) ; <nl> - this . logExceptionResult ( result , ex , req ) ; <nl> - } <nl> + this . service . removeById ( id ) ; <nl> return result ; <nl> } <nl> + } <nl> 
mmm a / src / main / java / org / pac4j / jax / rs / features / Pac4JSecurityFeature . java <nl> ppp b / src / main / java / org / pac4j / jax / rs / features / Pac4JSecurityFeature . java <nl> + " renewSession parameter in @ Pac4JCallback is not expected to have more than one value " ) ; <nl> + } <nl> + <nl> + if ( cbAnn . skipResponse ( ) . length & gt ; 1 ) { <nl> + throw new IllegalArgumentException ( <nl> + " skipResponse parameter in @ Pac4JCallback is not expected to have more than one value " ) ; <nl> + } <nl> + <nl> + final CallbackFilter filter = new CallbackFilter ( request , config ) ; <nl> + <nl> filter . setMultiProfile ( cbAnn . multiProfile ( ) . length == 0 ? null : cbAnn . multiProfile ( ) [ 0 ] ) ; <nl> filter . setRenewSession ( cbAnn . renewSession ( ) . length == 0 ? null : cbAnn . renewSession ( ) [ 0 ] ) ; <nl> filter . setDefaultUrl ( cbAnn . defaultUrl ( ) . length == 0 ? null : cbAnn . defaultUrl ( ) [ 0 ] ) ; <nl> - filter . setSkipResponse ( cbAnn . skipResponse ( ) ) ; <nl> + filter . setSkipResponse ( cbAnn . skipResponse ( ) . length == 0 ? null : cbAnn . skipResponse ( ) [ 0 ] ) ; <nl>  <nl> context . register ( filter ) ; <nl> } <nl> 
mmm a / src / main / java / io / mewbase / server / impl / ConnectionImpl . java <nl> ppp b / src / main / java / io / mewbase / server / impl / ConnectionImpl . java <nl> - @ Override <nl> public void handleListChannels ( BsonObject frame ) { <nl> checkContext ( ) ; <nl> - if ( ! isAuthorized ( Protocol . LIST_CHANNELS_FRAME ) ) { <nl> - return ; <nl> - } <nl> - Integer requestID = frame . getInteger ( Protocol . REQUEST_REQUEST_ID ) ; <nl> - if ( requestID == null ) { <nl> - missingField ( Protocol . REQUEST_REQUEST_ID , Protocol . LIST_CHANNELS_FRAME ) ; <nl> - return ; <nl> - } <nl> - BsonObject resp = new BsonObject ( ) ; <nl> - resp . put ( Protocol . RESPONSE_REQUEST_ID , requestID ) ; <nl> - resp . put ( Protocol . RESPONSE_OK , true ) ; <nl> + <nl> + CompletableFuture & lt ; Boolean & gt ; authorisedCF = user . isAuthorised ( Protocol . LIST_CHANNELS_FRAME ) ; <nl> + <nl> + Consumer & lt ; BsonObject & gt ; frameConsumer = ( protocolFrame ) - & gt ; { <nl> + Integer requestID = protocolFrame . getInteger ( Protocol . REQUEST_REQUEST_ID ) ; <nl> + if ( requestID == null ) { <nl> + missingField ( Protocol . REQUEST_REQUEST_ID , Protocol . LIST_CHANNELS_FRAME ) ; <nl> + return ; <nl> + } <nl> + BsonObject resp = new BsonObject ( ) ; <nl> + resp . put ( Protocol . RESPONSE_REQUEST_ID , requestID ) ; <nl> + resp . put ( Protocol . RESPONSE_OK , true ) ; <nl> + BsonArray arr = new BsonArray ( server . listChannels ( ) ) ; <nl> + resp . put ( Protocol . LISTCHANNELS_CHANNELS , arr ) ; <nl> + writeResponse ( Protocol . RESPONSE_FRAME , resp ) ; <nl> + } ; <nl> + <nl> + authorisedCF . handle ( ( res , ex ) - & gt ; { <nl> + <nl> + handleFrame ( frame , frameConsumer , res , ex ) ; <nl> + return null ; <nl> + } ) ; <nl> + } <nl> + <nl> + @ Override <nl> 
mmm a / ff4j - store - elastic / src / test / java / org / ff4j / elastic / store / FeatureStoreElasticTest . java <nl> ppp b / ff4j - store - elastic / src / test / java / org / ff4j / elastic / store / FeatureStoreElasticTest . java <nl> @ BeforeClass <nl> public static void setup ( ) { <nl> - server = EmbeddedElasticServer ( folder . getRoot ( ) . getPath ( ) ) ; <nl> - server . start ( ) ; <nl> - ClusterHealthResponse healths = server . client ( ) . admin ( ) . cluster ( ) . prepareHealth ( ) . get ( ) ; <nl> - logger . info ( healths . toString ( ) ) ; <nl> + server = EmbeddedElasticServer . builder ( ) /  / <nl> + . clusterName ( " myIntegrationClusterFeature " ) /  / <nl> + . dataDirectory ( folder . getRoot ( ) . getPath ( ) ) /  / <nl> + . health ( true ) /  / <nl> + . start ( ) ; <nl> } <nl>  <nl> @ AfterClass <nl> 
mmm a / data / org . eclipse . birt . data . aggregation / src / org / eclipse / birt / data / aggregation / impl / TotalMovingAve . java <nl> ppp b / data / org . eclipse . birt . data . aggregation / src / org / eclipse / birt / data / aggregation / impl / TotalMovingAve . java <nl> - assert ( args . length & gt ; 1 ) ; <nl> - if ( args [ 0 ] ! = null & & args [ 1 ] ! = null ) <nl> - { <nl> - if ( calculator == null ) <nl> - { <nl> - calculator = CalculatorFactory . getCalculator ( args [ 0 ] . getClass ( ) ) ; <nl> - } <nl> - try <nl> - { <nl> - if ( list . size ( ) == 0 ) <nl> - { <nl> - window = DataTypeUtil . toInteger ( args [ 1 ] ) . intValue ( ) ; <nl> assert ( window & gt ; 0 ) ; <nl> } <nl> list . addLast ( args [ 0 ] ) ; <nl> - sum = calculator . add ( sum , args [ 0 ] ) ; <nl> + sum = calculator . add ( sum , calculator . getTypedObject ( args [ 0 ] ) ) ; <nl>  <nl> if ( list . size ( ) & gt ; window ) <nl> { <nl> 
mmm a / src / main / java / synapticloop / b2 / response / B2BucketResponse . java <nl> ppp b / src / main / java / synapticloop / b2 / response / B2BucketResponse . java <nl> - this . bucketName = response . optString ( B2ResponseProperties . KEY_BUCKET_NAME , null ) ; <nl> - this . bucketType = response . optString ( B2ResponseProperties . KEY_BUCKET_TYPE , null ) ; <nl> + this . bucketName = this . readString ( B2ResponseProperties . KEY_BUCKET_NAME ) ; <nl> + this . bucketType = this . readString ( B2ResponseProperties . KEY_BUCKET_TYPE ) ; <nl>  <nl> - if ( LOGGER . isWarnEnabled ( ) ) { <nl> - response . remove ( B2ResponseProperties . KEY_BUCKET_ID ) ; <nl> - response . remove ( B2ResponseProperties . KEY_ACCOUNT_ID ) ; <nl> - response . remove ( B2ResponseProperties . KEY_BUCKET_NAME ) ; <nl> - response . remove ( B2ResponseProperties . KEY_BUCKET_TYPE ) ; <nl> - <nl> - warnOnMissedKeys ( LOGGER , response ) ; <nl> - } <nl> + this . warnOnMissedKeys ( LOGGER ) ; <nl> } <nl> + <nl> + / ** <nl> 
mmm a / src / main / java / com / fasterxml / jackson / databind / deser / impl / MethodProperty . java <nl> ppp b / src / main / java / com / fasterxml / jackson / databind / deser / impl / MethodProperty . java <nl> - public Object deserializeSetAndReturn ( JsonParser p , <nl> DeserializationContext ctxt , Object instance ) throws IOException <nl> { <nl> - Object value = deserialize ( p , ctxt ) ; <nl> + Object value ; <nl> + if ( p . hasToken ( JsonToken . VALUE_NULL ) ) { <nl> + if ( _skipNulls ) { <nl> + return instance ; <nl> + } <nl> + value = _nullProvider . getNullValue ( ctxt ) ; <nl> + } else if ( _valueTypeDeserializer == null ) { <nl> + value = _valueDeserializer . deserialize ( p , ctxt ) ; <nl> + } else { <nl> + value = _valueDeserializer . deserializeWithType ( p , ctxt , _valueTypeDeserializer ) ; <nl> + } <nl> try { <nl> Object result = _setter . invoke ( instance , value ) ; <nl> - return ( result == null ) ? instance : result ; <nl> 
mmm a / src / graphtea / extensions / reports / coloring / fillinaware / FillinAwareColoring . java <nl> ppp b / src / graphtea / extensions / reports / coloring / fillinaware / FillinAwareColoring . java <nl> - System . out . println ( " file : " + f . getAbsolutePath ( ) ) ; <nl> Matrix m = MM . loadMatrixFromSPARSE ( f ) ; <nl> SpMat sm = new SpMat ( m ) ; <nl> - generateResults ( ret , f , sm , " Nat " , " Nat " , 10 ) ; <nl> - generateResults ( ret , f , sm , " MinDeg " , " MinDeg " , 10 ) ; <nl> - generateResults ( ret , f , sm , " Metis " , " Metis " ,10 ) ; <nl> + int sizes [ ] = { 10 , sm . rows ( ) / 32 , sm . rows ( ) / 8 } ; <nl> + for ( int i=0 ; i & lt ; sizes . length ; i++ ) { <nl> + generateResults ( ret , f , sm , " Nat " , " Nat " , sizes [ i ] ) ; <nl> + generateResults ( ret , f , sm , " MinDeg " , " MinDeg " , sizes [ i ] ) ; <nl> + generateResults ( ret , f , sm , " Metis " , " Metis " , sizes [ i ] ) ; <nl> + generateResults ( ret , f , sm , " Nat " , " Nat " , sizes [ i ] ) ; <nl> + generateResults ( ret , f , sm , " Metis " , " MaxDeg " , sizes [ i ] ) ; <nl> + generateResults ( ret , f , sm , " Nat " , " MaxDeg " , sizes [ i ] ) ; <nl> + } <nl> } catch ( IOException e ) { <nl> 
mmm a / tests / src / test / java / com / appnexus / opensdk / MediatedAdViewControllerTest . java <nl> ppp b / tests / src / test / java / com / appnexus / opensdk / MediatedAdViewControllerTest . java <nl> @ Test <nl> public void test8StandardThenMediated ( ) { <nl> - FakeHttp . addPendingHttpResponse ( 200 , TestResponses . banner ( ) ) ; <nl> - FakeHttp . addPendingHttpResponse ( 200 , TestResponses . mediatedSuccessfulBanner ( ) ) ; <nl> - FakeHttp . addPendingHttpResponse ( 200 , TestResponses . blank ( ) ) ; <nl> + server . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( TestResponses . banner ( ) ) ) ; <nl> + server . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( TestResponses . mediatedSuccessfulBanner ( ) ) ) ; <nl> + server . enqueue ( new MockResponse ( ) . setResponseCode ( 200 ) . setBody ( TestResponses . blank ( ) ) ) ; <nl>  <nl> requestManager . execute ( ) ; <nl> 
mmm a / demo / src / main / java / com / commonsware / cwac / cam2 / demo / MainActivity . java <nl> ppp b / demo / src / main / java / com / commonsware / cwac / cam2 / demo / MainActivity . java <nl> - } <nl> - <nl> private void captureLandscapeFFC ( ) { <nl> - Intent i=new CameraActivity . IntentBuilder ( MainActivity . this ) <nl> - . skipConfirm ( ) <nl> - . facing ( Facing . FRONT ) <nl> - . facingExactMatch ( ) <nl> - . to ( new File ( testRoot , " landscape - front . jpg " ) ) <nl> - . updateMediaStore ( ) <nl> - . flashModes ( FLASH_MODES ) <nl> - . zoomStyle ( ZoomStyle . SEEKBAR ) <nl> - . debugSavePreviewFrame ( ) <nl> - . debug ( ) <nl> - . build ( ) ; <nl> + Intent i ; <nl> + <nl> + if ( isVideo ) { <nl> + i=new VideoRecorderActivity . IntentBuilder ( MainActivity . this ) <nl> + . facing ( Facing . FRONT ) <nl> + . facingExactMatch ( ) <nl> + . to ( new File ( testRoot , " landscape - front . mp4 " ) ) <nl> + . updateMediaStore ( ) <nl> + . flashModes ( FLASH_MODES ) <nl> + . durationLimit ( 10000 ) <nl> + . debug ( ) <nl> + . build ( ) ; <nl> + } <nl> + else { <nl> + i=new CameraActivity . IntentBuilder ( MainActivity . this ) <nl> + . skipConfirm ( ) <nl> + . facing ( Facing . FRONT ) <nl> + . facingExactMatch ( ) <nl> + . to ( new File ( testRoot , " landscape - front . jpg " ) ) <nl> + . updateMediaStore ( ) <nl> + . flashModes ( FLASH_MODES ) <nl> + . zoomStyle ( ZoomStyle . SEEKBAR ) <nl> + . debugSavePreviewFrame ( ) <nl> + . debug ( ) <nl> + . build ( ) ; <nl> + } <nl>  <nl> startActivityForResult ( i , REQUEST_LANDSCAPE_FFC ) ; <nl> } <nl> 
mmm a / server / src / test / java / timely / test / integration / OneWaySSLBase . java <nl> ppp b / server / src / test / java / timely / test / integration / OneWaySSLBase . java <nl> final MiniAccumuloConfig macConfig = new MiniAccumuloConfig ( temp . newFolder ( " mac " ) , " secret " ) ; <nl> mac = new MiniAccumuloCluster ( macConfig ) ; <nl> mac . start ( ) ; <nl> - conf = temp . newFile ( " config . properties " ) ; <nl> - TestConfiguration config = TestConfiguration . createMinimalConfigurationForTest ( ) ; <nl> - config . put ( Configuration . INSTANCE_NAME , mac . getInstanceName ( ) ) ; <nl> - config . put ( Configuration . ZOOKEEPERS , mac . getZooKeepers ( ) ) ; <nl> - setupSSL ( config ) ; <nl> - config . toConfiguration ( conf ) ; <nl> + conf = TestConfiguration . createMinimalConfigurationForTest ( ) ; <nl> + conf . getAccumulo ( ) . setInstanceName ( mac . getInstanceName ( ) ) ; <nl> + conf . getAccumulo ( ) . setZookeepers ( mac . getZooKeepers ( ) ) ; <nl> + setupSSL ( conf ) ; <nl> } <nl> - <nl> - @ AfterClass <nl> 
mmm a / jooby - metrics / src / test / java / org / jooby / metrics / MetricsTest . java <nl> ppp b / jooby - metrics / src / test / java / org / jooby / metrics / MetricsTest . java <nl> @ Test <nl> public void metricInstance ( ) throws Exception { <nl> new MockUnit ( Env . class , Config . class , Binder . class , Metric . class ) <nl> - . expect ( newRegistry ) <nl> + . expect ( newMetricRegistry ) <nl> + . expect ( newHealthCheckRegistry ) <nl> . expect ( mapBinderStatic ) <nl> . expect ( mapbinder ( Metric . class , ( unit , binder ) - & gt ; { <nl> } ) ) <nl> . expect ( setbinder ( Reporter . class , ( unit , binder ) - & gt ; { <nl>  <nl> } ) ) <nl> - . expect ( bindRegistry ) <nl> - . expect ( bindRegistryInitializer ) <nl> + . expect ( bindMetricRegistry ) <nl> + . expect ( bindMetricRegistryInitializer ) <nl> . expect ( bindHealthCheckRegistry ) <nl> + . expect ( bindHealthCheckRegistryInitializer ) <nl> . expect ( onStop ) <nl> . run ( unit - & gt ; { <nl> new Metrics ( ) <nl> 
mmm a / src / android / com / mirasense / scanditsdk / plugin / PhonegapParamParser . java <nl> ppp b / src / android / com / mirasense / scanditsdk / plugin / PhonegapParamParser . java <nl> - if ( bundle . getSerializable ( paramLandscapeMargins ) ! = null <nl> & & bundle . getSerializable ( paramLandscapeMargins ) instanceof List ) { <nl> List & lt ; Object & gt ; list = ( List & lt ; Object & gt ; ) bundle . getSerializable ( paramLandscapeMargins ) ; <nl> - if ( list . size ( ) == 4 & & UIParamParser . checkClassOfListObjects ( list , Integer . class ) ) { <nl> - landscapeMargins = new Rect ( ( Integer ) list . get ( 0 ) , ( Integer ) list . get ( 1 ) , <nl> - ( Integer ) list . get ( 2 ) , ( Integer ) list . get ( 3 ) ) ; <nl> + if ( list . size ( ) == 4 & & <nl> + ( UIParamParser . checkClassOfListObjects ( list , Integer . class ) || <nl> + UIParamParser . checkClassOfListObjects ( list , String . class ) ) ) { <nl> + landscapeMargins = new Rect ( UIParamParser . getDp ( list . get ( 0 ) ) , UIParamParser . getDp ( list . get ( 1 ) ) , <nl> + UIParamParser . getDp ( list . get ( 2 ) ) , UIParamParser . getDp ( list . get ( 3 ) ) ) ; <nl> } <nl> } else if ( bundle . getString ( paramLandscapeMargins ) ! = null ) { <nl> String landscapeMarginsString = bundle . getString ( paramLandscapeMargins ) ; <nl> 
mmm a / src / java / main / com / topcoder / direct / services / view / action / project / ProjectWorkManagementAction . java <nl> ppp b / src / java / main / com / topcoder / direct / services / view / action / project / ProjectWorkManagementAction . java <nl> if ( closedPhases . containsKey ( ProjectPhaseType . SUBMISSION . toString ( ) ) ) { <nl> - Map & lt ; String , Object & gt ; resultItem = new HashMap & lt ; String , Object & gt ; ( ) ; <nl> - resultItem . put ( " id " , getContestId ( ) + " : " + ProjectPhaseType . FINAL_FIX . toString ( ) ) ; <nl> - resultItem . put ( " label " , ProjectPhaseType . FINAL_FIX . toString ( ) ) ; <nl> - resultItem . put ( " type " , " phase " ) ; <nl> - result . add ( resultItem ) ; <nl> + result . add ( buildPhaseResult ( getContestId ( ) , ProjectPhaseType . FINAL_FIX ) ) ; <nl> } <nl> } <nl> 
mmm a / src / main / java / org / graphity / processor / filter / response / HypermediaFilter . java <nl> ppp b / src / main / java / org / graphity / processor / filter / response / HypermediaFilter . java <nl> + public StateBuilder getPageBuilder ( StateBuilder sb , TemplateCall templateCall ) <nl> { <nl> - if ( resource == null ) throw new IllegalArgumentException ( " Resource can not be null " ) ; <nl> - <nl> - StateBuilder sb = StateBuilder . fromResource ( resource ) ; <nl> + if ( sb == null ) throw new IllegalArgumentException ( " Resource can not be null " ) ; <nl> + if ( templateCall == null ) throw new IllegalArgumentException ( " TemplateCall can not be null " ) ; <nl>  <nl> - if ( offset ! = null ) sb . replaceProperty ( GP . offset , resource . getModel ( ) . createTypedLiteral ( offset ) ) ; <nl> - if ( limit ! = null ) sb . replaceProperty ( GP . limit , resource . getModel ( ) . createTypedLiteral ( limit ) ) ; <nl> - if ( orderBy ! = null ) sb . replaceProperty ( GP . orderBy , resource . getModel ( ) . createTypedLiteral ( orderBy ) ) ; <nl> - if ( desc ! = null ) sb . replaceProperty ( GP . desc , resource . getModel ( ) . createTypedLiteral ( desc ) ) ; <nl> + if ( templateCall . hasProperty ( GP . offset ) ) sb . replaceProperty ( GP . offset , templateCall . getProperty ( GP . offset ) . getObject ( ) ) ; <nl> + if ( templateCall . hasProperty ( GP . limit ) ) sb . replaceProperty ( GP . limit , templateCall . getProperty ( GP . limit ) . getObject ( ) ) ; <nl> + if ( templateCall . hasProperty ( GP . orderBy ) ) sb . replaceProperty ( GP . orderBy , templateCall . getProperty ( GP . orderBy ) . getObject ( ) ) ; <nl> + if ( templateCall . hasProperty ( GP . desc ) ) sb . replaceProperty ( GP . desc , templateCall . getProperty ( GP . desc ) . getObject ( ) ) ; <nl> 
mmm a / src / main / java / shadow / typecheck / ErrorReporter . java <nl> ppp b / src / main / java / shadow / typecheck / ErrorReporter . java <nl> * / <nl> public void addWarning ( Node node , Error warning , String message ) { <nl> - if ( node ! = null ) { <nl> - message = makeMessage ( warning , message , node . getFile ( ) , node . getLineStart ( ) , <nl> - node . getLineEnd ( ) , node . getColumnStart ( ) , node . getColumnEnd ( ) ) ; <nl> - warningList . add ( new TypeCheckException ( warning , message ) ) ; <nl> - } <nl> - } <nl> + if ( node ! = null ) <nl> + warningList . add ( new TypeCheckException ( warning , message , node . getFile ( ) , node . getLineStart ( ) , <nl> + node . getLineEnd ( ) , node . getColumnStart ( ) , node . getColumnEnd ( ) ) ) ; <nl> + } <nl>  <nl> + / ** <nl> 
mmm a / src / main / java / com / openfin / desktop / demo / OpenFinDockingDemo . java <nl> ppp b / src / main / java / com / openfin / desktop / demo / OpenFinDockingDemo . java <nl> + * / <nl> public static void main ( String [ ] args ) { <nl> - if ( args . length & gt ; = 2 ) { <nl> - final String desktop_path = args [ 0 ] ; <nl> - final int port = Integer . parseInt ( args [ 1 ] ) ; <nl> - java . lang . System . out . println ( " Starting Demo : " + desktop_path + " " + port ) ; <nl> - String desktop_cmd_line = " " ; <nl> - if ( args . length & gt ; 2 ) { <nl> - for ( int i = 2 ; i & lt ; args . length ; i++ ) { <nl> - desktop_cmd_line += ( args [ i ] + " " ) ; <nl> - } <nl> - java . lang . System . out . println ( " Passing desktop args : " + desktop_cmd_line ) ; <nl> - } <nl> - final String desktopCommandLine = desktop_cmd_line ; <nl> - javax . swing . SwingUtilities . invokeLater ( new Runnable ( ) { <nl> - public void run ( ) { <nl> - createAndShowGUI ( desktop_path , desktopCommandLine , port ) ; <nl> + final String desktop_option = java . lang . System . getProperty ( " OpenFinOption " ) ; <nl> + final String startupUUID ; <nl> + if ( java . lang . System . getProperty ( " StartupUUID " ) ! = null ) { <nl> + startupUUID = java . lang . System . getProperty ( " StartupUUID " ) ; <nl> + } else { <nl> + startupUUID = " OpenFinHelloWorld " ; <nl> 
mmm a / src / main / java / io / vertx / ext / stomp / DefaultNackHandler . java <nl> ppp b / src / main / java / io / vertx / ext / stomp / DefaultNackHandler . java <nl> - sf . connection ( ) . close ( ) ; <nl> + connection . close ( ) ; <nl> return ; <nl> } else { <nl> - transaction . addFrameToTransaction ( sf . frame ( ) ) ; <nl> - Frames . handleReceipt ( sf . frame ( ) , sf . connection ( ) ) ; <nl> + if ( ! transaction . addFrameToTransaction ( sf . frame ( ) ) ) { <nl> + Frame errorFrame = Frames . createErrorFrame ( " Frame not added to transaction " , <nl> + Headers . create ( Frame . ID , id , Frame . TRANSACTION , txId ) , <nl> + " Message delivery failed - the frame can not be added to the transaction - the number of allowed thread " + <nl> + " may have been reached " ) ; <nl> + connection . handler ( ) . unregisterTransactionsFromConnection ( connection ) ; <nl> + connection . write ( errorFrame ) ; <nl> + connection . close ( ) ; <nl> + return ; <nl> + } <nl> + Frames . handleReceipt ( sf . frame ( ) , connection ) ; <nl> return ; <nl> 
mmm a / src / test / java / org / sonar / plugins / cobertura / CoberturaSensorTest . java <nl> ppp b / src / test / java / org / sonar / plugins / cobertura / CoberturaSensorTest . java <nl> - verify ( context , never ( ) ) . saveMeasure ( eq ( interfaze ) , argThat ( new IsMeasure ( CoreMetrics . COVERAGE ) ) ) ; <nl> + verify ( newMeasure , never ( ) ) . forMetric ( CoreMetrics . COVERAGE ) ; <nl>  <nl> - verify ( context , never ( ) ) . saveMeasure ( eq ( interfaze ) , argThat ( new IsMeasure ( CoreMetrics . LINE_COVERAGE ) ) ) ; <nl> - verify ( context , never ( ) ) . saveMeasure ( eq ( interfaze ) , argThat ( new IsMeasure ( CoreMetrics . LINES_TO_COVER ) ) ) ; <nl> - verify ( context , never ( ) ) . saveMeasure ( eq ( interfaze ) , argThat ( new IsMeasure ( CoreMetrics . UNCOVERED_LINES ) ) ) ; <nl> + verify ( newMeasure , never ( ) ) . forMetric ( CoreMetrics . LINE_COVERAGE ) ; <nl> + verify ( newMeasure , never ( ) ) . forMetric ( CoreMetrics . LINES_TO_COVER ) ; <nl> + verify ( newMeasure , never ( ) ) . forMetric ( CoreMetrics . UNCOVERED_LINES ) ; <nl>  <nl> - verify ( context , never ( ) ) . saveMeasure ( eq ( interfaze ) , argThat ( new IsMeasure ( CoreMetrics . BRANCH_COVERAGE ) ) ) ; <nl> - verify ( context , never ( ) ) . saveMeasure ( eq ( interfaze ) , argThat ( new IsMeasure ( CoreMetrics . CONDITIONS_TO_COVER ) ) ) ; <nl> + verify ( newMeasure , never ( ) ) . forMetric ( CoreMetrics . BRANCH_COVERAGE ) ; <nl> + verify ( newMeasure , never ( ) ) . forMetric ( CoreMetrics . CONDITIONS_TO_COVER ) ; <nl> 
mmm a / HTML_Renderer / src / main / java / org / lobobrowser / html / domimpl / HTMLMeterElementImpl . java <nl> ppp b / HTML_Renderer / src / main / java / org / lobobrowser / html / domimpl / HTMLMeterElementImpl . java <nl> * / <nl> @ Override <nl> public double getOptimum ( ) { <nl> - try { <nl> - return Integer . parseInt ( this . getAttribute ( HtmlAttributeProperties . OPTINUM ) ) ; <nl> - } catch ( Exception thrown ) { <nl> - logger . error ( " getSize ( ) : Unable to parse size attribute in " + this + " . " , thrown ) ; <nl> - return 0 ; <nl> - } <nl> + String valueText = this . getAttribute ( HtmlAttributeProperties . OPTINUM ) ; <nl> + return HtmlValues . getPixelSize ( valueText , this . getRenderState ( ) , 0 ) ; <nl> } <nl> + <nl> + / * <nl> 
mmm a / src / main / java / org / spongepowered / api / data / MemoryDataView . java <nl> ppp b / src / main / java / org / spongepowered / api / data / MemoryDataView . java <nl> @ Override <nl> public Optional & lt ; List & lt ; Boolean & gt ; & gt ; getBooleanList ( DataQuery path ) { <nl> - Optional & lt ; List & lt ; ? & gt ; & gt ; list = getUnsafeList ( path ) ; <nl> - <nl> - if ( ! list . isPresent ( ) ) { <nl> - return Optional . empty ( ) ; <nl> - } <nl> - <nl> - List & lt ; Boolean & gt ; newList = Lists . newArrayList ( ) ; <nl> - <nl> - for ( Object object : list . get ( ) ) { <nl> - Optional & lt ; Boolean & gt ; optional = Coerce . asBoolean ( object ) ; <nl> - if ( optional . isPresent ( ) ) { <nl> - newList . add ( optional . get ( ) ) ; <nl> - } <nl> - } <nl> - return Optional . of ( newList ) ; <nl> + return getUnsafeList ( path ) . map ( list - & gt ; <nl> + list . stream ( ) <nl> + . map ( Coerce : : asBoolean ) <nl> + . filter ( Optional : : isPresent ) <nl> + . map ( Optional : : get ) <nl> + . collect ( Collectors . toList ( ) ) <nl> + ) ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / geoserver / webapp / src / main / java / com / boundlessgeo / geoserver / api / controllers / IconController . java <nl> ppp b / geoserver / webapp / src / main / java / com / boundlessgeo / geoserver / api / controllers / IconController . java <nl> - @ RequestMapping ( value = " / { wsName } / { icon : . + } " , method = RequestMethod . GET ) <nl> - public HttpEntity raw ( @ PathVariable String wsName , @ PathVariable String icon ) throws IOException { <nl> - <nl> - WorkspaceInfo ws = findWorkspace ( wsName , catalog ( ) ) ; <nl> - <nl> - GeoServerResourceLoader rl = geoServer . getCatalog ( ) . getResourceLoader ( ) ; <nl> - Resource resource = rl . get ( Paths . path ( " workspaces " , ws . getName ( ) , " styles " , icon ) ) ; <nl> - <nl> + WorkspaceInfo ws ; <nl> + Resource resource ; <nl> + <nl> + if ( wsName == null ) { <nl> + ws = null ; <nl> + resource = dataDir ( ) . getRoot ( " styles " , icon ) ; <nl> + } else { <nl> + ws = findWorkspace ( wsName , catalog ( ) ) ; <nl> + resource = dataDir ( ) . get ( ws , " styles " , icon ) ; <nl> + } <nl> + <nl> if ( resource . getType ( ) ! = Type . RESOURCE ) { <nl> - throw new NotFoundException ( " Icon " +icon+ " not found " ) ; <nl> 
mmm a / src / main / java / hudson / plugins / clover / results / FileCoverage . java <nl> ppp b / src / main / java / hudson / plugins / clover / results / FileCoverage . java <nl> + } <nl> + <nl> public AbstractCloverMetrics getPreviousResult ( ) { <nl> - return null ; /  / To change body of implemented methods use File | Settings | File Templates . <nl> + if ( owner == null ) return null ; <nl> + Run prevBuild = owner . getPreviousBuild ( ) ; <nl> + if ( prevBuild == null ) return null ; <nl> + CloverBuildAction action = prevBuild . getAction ( CloverBuildAction . class ) ; <nl> + if ( action == null ) return null ; <nl> + return action . findFileCoverage ( getName ( ) ) ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / jetty - io / src / test / java / org / eclipse / jetty / io / WriteFlusherTest . java <nl> ppp b / jetty - io / src / test / java / org / eclipse / jetty / io / WriteFlusherTest . java <nl> + @ Test <nl> public void testCompleteBlocking ( ) throws Exception <nl> { <nl> + ByteArrayEndPoint endPoint = new ByteArrayEndPoint ( new byte [ 0 ] , 10 ) ; <nl> + <nl> + AtomicBoolean incompleteFlush = new AtomicBoolean ( ) ; <nl> + WriteFlusher flusher = new WriteFlusher ( endPoint ) <nl> + { <nl> + @ Override <nl> + protected void onIncompleteFlush ( ) <nl> + { <nl> + incompleteFlush . set ( true ) ; <nl> + } <nl> + } ; <nl> + <nl> FutureCallback callback = new FutureCallback ( ) ; <nl> - _flusher . write ( callback , BufferUtil . toBuffer ( " How " ) , BufferUtil . toBuffer ( " now " ) , BufferUtil . toBuffer ( " brown " ) , BufferUtil . toBuffer ( " cow ! " ) ) ; <nl> - assertFalse ( callback . isDone ( ) ) ; <nl> - assertFalse ( callback . isCancelled ( ) ) ; <nl> + flusher . write ( callback , BufferUtil . toBuffer ( " How now brown cow ! " ) ) ; <nl> + <nl> + Assert . assertFalse ( callback . isDone ( ) ) ; <nl> + Assert . assertFalse ( callback . isCancelled ( ) ) ; <nl> + <nl> + Assert . assertTrue ( incompleteFlush . get ( ) ) ; <nl> + <nl> + try <nl> + { <nl> + callback . get ( 100 , TimeUnit . MILLISECONDS ) ; <nl> + Assert . fail ( ) ; <nl> + } <nl> + catch ( TimeoutException x ) <nl> 
mmm a / src / android / libs / SalesforceHybrid / src / com / salesforce / androidsdk / phonegap / plugin / SmartStorePlugin . java <nl> ppp b / src / android / libs / SalesforceHybrid / src / com / salesforce / androidsdk / phonegap / plugin / SmartStorePlugin . java <nl> - private SmartStore getSmartStore ( JSONObject arg0 ) { <nl> + * @ return <nl> + * / <nl> + public static SmartStore getSmartStore ( JSONObject arg0 ) throws Exception { <nl> boolean isGlobal = getIsGlobal ( arg0 ) ; <nl> - String storeName = getStoreName ( arg0 ) ; <nl> - return ( isGlobal <nl> - ? SmartStoreSDKManager . getInstance ( ) . getGlobalSmartStore ( storeName ) <nl> - : SmartStoreSDKManager . getInstance ( ) . getSmartStore ( storeName , UserAccountManager . getInstance ( ) . getCurrentUser ( ) , UserAccountManager . getInstance ( ) . getCurrentUser ( ) . getCommunityId ( ) ) ) ; <nl> + final String storeName = getStoreName ( arg0 ) ; <nl> + if ( isGlobal ) { <nl> + return SmartStoreSDKManager . getInstance ( ) . getGlobalSmartStore ( storeName ) ; <nl> + } else { <nl> + final UserAccount account = UserAccountManager . getInstance ( ) . getCurrentUser ( ) ; <nl> + if ( account == null ) { <nl> + throw new Exception ( " No user account found " ) ; <nl> + } else { <nl> + return SmartStoreSDKManager . getInstance ( ) . getSmartStore ( storeName , account , account . getCommunityId ( ) ) ; <nl> + } <nl> + } <nl> } <nl> - <nl> - / ** <nl> 
mmm a / src / main / java / org / walkmod / javalang / visitors / DumpVisitor . java <nl> ppp b / src / main / java / org / walkmod / javalang / visitors / DumpVisitor . java <nl> public void visit ( EnumDeclaration n , Object arg ) { <nl> printPreviousComments ( n , arg ) ; <nl> - printJavadoc ( n . getJavaDoc ( ) , arg ) ; <nl> + JavadocComment comment = n . getJavaDoc ( ) ; <nl> + printJavadoc ( comment , arg ) ; <nl> + if ( comment ! = null & & ! n . isNewNode ( ) & & ! comment . isNewNode ( ) ) { <nl> + int start = comment . getEndLine ( ) ; <nl> + int end = n . getBeginLine ( ) ; <nl> + for ( int i = start + 1 ; i & lt ; end ; i++ ) { <nl> + printer . printLn ( ) ; <nl> + } <nl> + } <nl> printMemberAnnotations ( n . getAnnotations ( ) , arg ) ; <nl> - printModifiers ( n . getModifiers ( ) ) ; <nl> - printer . print ( " enum " ) ; <nl> 
mmm a / tests / fr . inria . diverse . melange . tests / src / main / java / simplefsm / fsm / adapters / fsmmt / FsmMTAdaptersFactory . java <nl> ppp b / tests / fr . inria . diverse . melange . tests / src / main / java / simplefsm / fsm / adapters / fsmmt / FsmMTAdaptersFactory . java <nl> - } <nl>  <nl> public EObjectAdapter createAdapter ( final EObject o ) { <nl> - EObjectAdapter res = register . get ( o ) ; <nl> - if ( res ! = null ) { <nl> - return res ; <nl> + if ( o instanceof fsm . FSM ) { <nl> + return createFSMAdapter ( ( fsm . FSM ) o ) ; <nl> } <nl> - else { <nl> - if ( o instanceof fsm . FSM ) { <nl> - res = createFSMAdapter ( ( fsm . FSM ) o ) ; <nl> - register . put ( o , res ) ; <nl> - return res ; <nl> - } <nl> - if ( o instanceof fsm . State ) { <nl> - res = createStateAdapter ( ( fsm . State ) o ) ; <nl> - register . put ( o , res ) ; <nl> - return res ; <nl> - } <nl> - if ( o instanceof fsm . Transition ) { <nl> - res = createTransitionAdapter ( ( fsm . Transition ) o ) ; <nl> - register . put ( o , res ) ; <nl> - return res ; <nl> - } <nl> + if ( o instanceof fsm . State ) { <nl> + return createStateAdapter ( ( fsm . State ) o ) ; <nl> } <nl> + if ( o instanceof fsm . Transition ) { <nl> + return createTransitionAdapter ( ( fsm . Transition ) o ) ; <nl> + } <nl> + <nl> + return null ; <nl> 
mmm a / java / org / lwjgl / opengl / ARBUniformBufferObject . java <nl> ppp b / java / org / lwjgl / opengl / ARBUniformBufferObject . java <nl> * @ param uniformBlockIndex the index of the uniform block within { @ code program } <nl> * / <nl> public static String glGetActiveUniformBlockName ( int program , int uniformBlockIndex ) { <nl> - int bufSize = glGetActiveUniformBlocki ( program , uniformBlockIndex , GL_UNIFORM_BLOCK_NAME_LENGTH ) ; <nl> - MemoryStack stack = stackGet ( ) ; int stackPointer = stack . getPointer ( ) ; <nl> - try { <nl> - IntBuffer length = stack . ints ( 0 ) ; <nl> - ByteBuffer uniformBlockName = stack . malloc ( bufSize ) ; <nl> - nglGetActiveUniformBlockName ( program , uniformBlockIndex , bufSize , memAddress ( length ) , memAddress ( uniformBlockName ) ) ; <nl> - return memASCII ( uniformBlockName , length . get ( 0 ) ) ; <nl> - } finally { <nl> - stack . setPointer ( stackPointer ) ; <nl> - } <nl> + return glGetActiveUniformBlockName ( program , uniformBlockIndex , glGetActiveUniformBlocki ( program , uniformBlockIndex , GL_UNIFORM_BLOCK_NAME_LENGTH ) ) ; <nl> + } <nl> + <nl> 
mmm a / device / iothub - java - client / src / main / java / com / microsoft / azure / iothub / transport / amqps / AmqpsIotHubConnectionBaseHandler . java <nl> ppp b / device / iothub - java - client / src / main / java / com / microsoft / azure / iothub / transport / amqps / AmqpsIotHubConnectionBaseHandler . java <nl> public void shutdown ( ) { <nl> this . linkFlow = false ; <nl> - this . sender . close ( ) ; <nl> - this . receiver . close ( ) ; <nl> - this . session . close ( ) ; <nl> - this . connection . close ( ) ; <nl> + if ( this . sender ! = null ) { <nl> + this . sender . close ( ) ; <nl> + } <nl> + if ( this . receiver ! = null ) { <nl> + this . receiver . close ( ) ; <nl> + } <nl> + if ( this . session ! = null ) { <nl> + this . session . close ( ) ; <nl> + } <nl> + if ( this . connection ! = null ) { <nl> + this . connection . close ( ) ; <nl> + } <nl> } <nl> - <nl> - / ** <nl> 
mmm a / blade - engine - spine - plugin / src / main / java / com / bladecoder / engine / spine / SpineRenderer . java <nl> ppp b / blade - engine - spine - plugin / src / main / java / com / bladecoder / engine / spine / SpineRenderer . java <nl> - currentSource . skeleton . setY ( y / scale ) ; <nl> - currentSource . skeleton . getRootBone ( ) . setRotation ( rotation ) ; <nl> + private static final Matrix4 tmp = new Matrix4 ( ) ; <nl> + <nl> + @ Override <nl> + public void draw ( SpriteBatch batch , float x , float y , float scale , float rotation , Color tint ) { <nl>  <nl> - batch . setTransformMatrix ( batch . getTransformMatrix ( ) . scale ( scale , scale , 1 . 0f ) ) ; <nl> + if ( currentSource ! = null & & currentSource . skeleton ! = null ) { <nl> + Matrix4 tm = batch . getTransformMatrix ( ) ; <nl> + tmp . set ( tm ) ; <nl> + <nl> + currentSource . skeleton . setX ( x / scale ) ; <nl> + currentSource . skeleton . setY ( y / scale ) ; <nl> + <nl> + tm . rotate ( 0 , 0 , 1 , rotation ) . scale ( scale , scale , 1 ) ; <nl> + batch . setTransformMatrix ( tm ) ; <nl>  <nl> if ( tint ! = null ) <nl> currentSource . skeleton . setColor ( tint ) ; <nl>  <nl> if ( tint ! = null ) <nl> batch . setColor ( Color . WHITE ) ; <nl> - batch . setTransformMatrix ( batch . getTransformMatrix ( ) . scale ( 1 / scale , 1 / scale , 1 . 0f ) ) ; <nl> + batch . setTransformMatrix ( tmp ) ; <nl> } else { <nl> x = x - getWidth ( ) / 2 * scale ; <nl> RectangleRenderer . draw ( batch , x , y , getWidth ( ) * scale , getHeight ( ) * scale , Color . RED ) ; <nl> 
mmm a / src / test / java / org / sonar / plugins / findbugs / FindbugsSensorTest . java <nl> ppp b / src / test / java / org / sonar / plugins / findbugs / FindbugsSensorTest . java <nl> - @ Test <nl> - public void should_execute_findbugs_but_not_find_violation ( ) throws Exception { <nl> - Project project = createProject ( ) ; <nl> - FindbugsExecutor executor = mock ( FindbugsExecutor . class ) ; <nl> - <nl> - BugInstance bugInstance = getBugInstance ( " THIS_RULE_DOES_NOT_EXIST " , 107 ) ; <nl> - Collection & lt ; ReportedBug & gt ; collection = Arrays . asList ( new ReportedBug ( bugInstance ) ) ; <nl> - when ( executor . execute ( false , false ) ) . thenReturn ( collection ) ; <nl> - JavaResourceLocator javaResourceLocator = mockJavaResourceLocator ( ) ; <nl> when ( javaResourceLocator . classFilesToAnalyze ( ) ) . thenReturn ( Lists . newArrayList ( new File ( " file " ) ) ) ; <nl>  <nl> - FindbugsSensor analyser = new FindbugsSensor ( createRulesProfileWithActiveRules ( false , false , false , false ) , <nl> - FakeRuleFinder . createWithAllRules ( ) , perspectives , executor , <nl> - javaResourceLocator , fs , byteCodeResourceLocator ) ; <nl> - analyser . analyse ( project , context ) ; <nl> + pico . addComponent ( createRulesProfileWithActiveRules ( false , false , false , false ) ) ; <nl> + <nl> + FindbugsSensor analyser = pico . getComponent ( FindbugsSensor . class ) ; <nl> + analyser . execute ( sensorContext ) ; <nl>  <nl> verify ( executor ) . execute ( false , false ) ; <nl> - verify ( issuable , never ( ) ) . addIssue ( any ( Issue . class ) ) ; <nl> + verify ( sensorContext , never ( ) ) . newIssue ( ) ; <nl> 
mmm a / thymeleaf - spring3 / src / main / java / org / thymeleaf / spring3 / view / ThymeleafViewResolver . java <nl> ppp b / thymeleaf - spring3 / src / main / java / org / thymeleaf / spring3 / view / ThymeleafViewResolver . java <nl> - beanFactory . applyBeanPropertyValues ( view , viewName ) ; <nl> - view = ( AbstractThymeleafView ) beanFactory . initializeBean ( view , viewName ) ; <nl> + <nl> + final BeanDefinition viewBeanDefinition = <nl> + ( beanFactory instanceof ConfigurableListableBeanFactory ? <nl> + ( ( ConfigurableListableBeanFactory ) beanFactory ) . getBeanDefinition ( viewName ) : <nl> + null ) ; <nl> + <nl> + if ( viewBeanDefinition == null || ! viewBeanDefinition . isPrototype ( ) ) { <nl> + final AbstractThymeleafView viewInstance = BeanUtils . instantiateClass ( getViewClass ( ) ) ; <nl> + view = ( AbstractThymeleafView ) beanFactory . configureBean ( viewInstance , viewName ) ; <nl> + } else { <nl> + view = ( AbstractThymeleafView ) beanFactory . getBean ( viewName ) ; <nl> + } <nl>  <nl> } else { <nl>  <nl> - beanFactory . autowireBeanProperties ( view , AutowireCapableBeanFactory . AUTOWIRE_NO , false ) ; <nl> - view = ( AbstractThymeleafView ) beanFactory . initializeBean ( view , viewName ) ; <nl> + final AbstractThymeleafView viewInstance = BeanUtils . instantiateClass ( getViewClass ( ) ) ; <nl> + <nl> + if ( viewBeanExists & & viewBeanType == null ) { <nl> + <nl> + beanFactory . autowireBeanProperties ( viewInstance , AutowireCapableBeanFactory . AUTOWIRE_NO , false ) ; <nl> + beanFactory . applyBeanPropertyValues ( viewInstance , viewName ) ; <nl> + view = ( AbstractThymeleafView ) beanFactory . initializeBean ( viewInstance , viewName ) ; <nl> + <nl> + } else { <nl> + <nl> + beanFactory . autowireBeanProperties ( viewInstance , AutowireCapableBeanFactory . AUTOWIRE_NO , false ) ; <nl> + view = ( AbstractThymeleafView ) beanFactory . initializeBean ( viewInstance , viewName ) ; <nl>  <nl> - } <nl> + } <nl> 
mmm a / admobadapter / src / main / java / com / clockbyte / admobadapter / expressads / AdmobExpressAdapterWrapper . java <nl> ppp b / admobadapter / src / main / java / com / clockbyte / admobadapter / expressads / AdmobExpressAdapterWrapper . java <nl> - } <nl> - <nl> public int getAdsCountToPublish ( ) { <nl> - int noOfAds = Math . min ( adFetcher . getFetchedAdsCount ( ) , <nl> - mAdapter . getCount ( ) / getNoOfDataBetweenAds ( ) ) ; <nl> - return Math . min ( noOfAds , getLimitOfAds ( ) ) ; <nl> + int expected = 0 ; <nl> + if ( mAdapter . getCount ( ) & gt ; 0 & & mAdapter . getCount ( ) & gt ; = getOffsetValue ( ) +1 ) <nl> + expected = ( mAdapter . getCount ( ) - getOffsetValue ( ) ) / getNoOfDataBetweenAds ( ) + 1 ; <nl> + expected = Math . max ( 0 , expected ) ; <nl> + return Math . min ( expected , getLimitOfAds ( ) ) ; <nl> } <nl> 
mmm a / sentry - binding / sentry - binding - hive / src / main / java / org / apache / sentry / binding / metastore / SentryMetastorePostEventListener . java <nl> ppp b / sentry - binding / sentry - binding - hive / src / main / java / org / apache / sentry / binding / metastore / SentryMetastorePostEventListener . java <nl> - tableEvent . getOldTable ( ) . getTableName ( ) , <nl> - tableEvent . getOldTable ( ) . getSd ( ) . getLocation ( ) , <nl> - tableEvent . getNewTable ( ) . getDbName ( ) , <nl> - tableEvent . getNewTable ( ) . getTableName ( ) , <nl> - tableEvent . getNewTable ( ) . getSd ( ) . getLocation ( ) ) ; <nl> - } <nl> + return ; <nl> + } <nl> + <nl> + String oldLoc = null , newLoc = null ; <nl> + <nl> + org . apache . hadoop . hive . metastore . api . Table oldTal = tableEvent . getOldTable ( ) ; <nl> + org . apache . hadoop . hive . metastore . api . Table newTal = tableEvent . getNewTable ( ) ; <nl> + <nl> + if ( oldTal ! = null & & oldTal . getSd ( ) ! =null ) { <nl> + oldLoc = oldTal . getSd ( ) . getLocation ( ) ; <nl> + } <nl> + if ( newTal ! = null & & newTal . getSd ( ) ! = null ) { <nl> + newLoc = newTal . getSd ( ) . getLocation ( ) ; <nl> + } <nl> + if ( oldLoc ! = null & & newLoc ! = null & & ! oldLoc . equals ( newLoc ) ) { <nl> + String oldDbName = tableEvent . getOldTable ( ) . getDbName ( ) ; <nl> + String oldTbName = tableEvent . getOldTable ( ) . getTableName ( ) ; <nl> + String newTbName = tableEvent . getNewTable ( ) . getTableName ( ) ; <nl> + String newDbName = tableEvent . getNewTable ( ) . getDbName ( ) ; <nl> + renameSentryTablePrivilege ( oldDbName , oldTbName , oldLoc , newDbName , newTbName , newLoc ) ; <nl> + } <nl> 
mmm a / demos / Eclipse / AppMenuDemo / src / com / example / appmenudemo / Controls . java <nl> ppp b / demos / Eclipse / AppMenuDemo / src / com / example / appmenudemo / Controls . java <nl> - public void ShareFromSdCardFile ( String _filename ) { <nl> - File file = new File ( Environment . getExternalStorageDirectory ( ) , _filename ) ; <nl> - intent . putExtra ( Intent . EXTRA_STREAM , Uri . fromFile ( file ) ) ; <nl> - controls . activity . startActivity ( intent ) ; <nl> - } <nl> - <nl> + } <nl> + } <nl> + <nl> + public void ShareFromInternalAppStorage ( String _filename , String _mimetype ) { <nl> + String srcPath = controls . activity . getFilesDir ( ) . getAbsolutePath ( ) + " / " + _filename ; /  / Result : / data / data / com / MyApp / files <nl> + String destPath = mTransitoryEnvironmentDirectoryPath + " / " + _filename ; <nl> + CopyFile ( srcPath , destPath ) ; <nl> + ShareFrom ( destPath , _mimetype ) ; <nl> + } <nl> + <nl> + public void ShareFrom ( String _fullFilename , String _mimetype ) { <nl> 
mmm a / Android / CRIMP / app / src / main / java / com / nusclimb / live / crimp / hello / route / RouteFragment . java <nl> ppp b / Android / CRIMP / app / src / main / java / com / nusclimb / live / crimp / hello / route / RouteFragment . java <nl> @ Override <nl> public void onViewCreated ( View view , Bundle savedInstanceState ) { <nl> - TextView textView = ( TextView ) view . findViewById ( R . id . text ) ; <nl> - textView . setText ( getArguments ( ) . getString ( ARGS_TITLE ) ) ; <nl> - } <nl> + mSwipeLayout = ( SwipeRefreshLayout ) view . findViewById ( R . id . swipe_layout ) ; <nl> + mLoadWheel = ( ProgressBar ) view . findViewById ( R . id . route_wheel_progressbar ) ; <nl> + mStatusText = ( TextView ) view . findViewById ( R . id . route_request_status_text ) ; <nl> + mRetryButton = ( Button ) view . findViewById ( R . id . route_retry_button ) ; <nl> + mHelloText = ( TextView ) view . findViewById ( R . id . route_hello_text ) ; <nl> + mCategorySpinner = ( Spinner ) view . findViewById ( R . id . route_category_spinner ) ; <nl> + mRouteSpinner = ( Spinner ) view . findViewById ( R . id . route_route_spinner ) ; <nl> + mRouteNextButton = ( Button ) view . findViewById ( R . id . route_next_button ) ; <nl> + mRouteReplaceText = ( TextView ) view . findViewById ( R . id . route_replace_text ) ; <nl> + mYesNoGroup = ( LinearLayout ) view . findViewById ( R . id . route_yes_no_viewgroup ) ; <nl> + <nl> + mCategorySpinner . setAdapter ( mCategoryAdapter ) ; <nl> + mRouteSpinner . setAdapter ( mRouteAdapter ) ; <nl> 
mmm a / src / test / java / reactor / core / publisher / FluxPublishOnTest . java <nl> ppp b / src / test / java / reactor / core / publisher / FluxPublishOnTest . java <nl> @ Test <nl> public void normalSyncFusedBackpressured ( ) throws Exception { <nl> - AssertSubscriber & lt ; Integer & gt ; ts = AssertSubscriber . create ( 0 ) ; <nl> + StepVerifier . create ( Flux . range ( 1 , 1_000_000 ) <nl> + . publishOn ( Schedulers . fromExecutorService ( exec ) ) , 0 ) <nl> + . thenRequest ( 500_000 ) <nl> + . expectNextCount ( 500_000 ) <nl> + . thenRequest ( 500_000 ) <nl> + . expectNextCount ( 500_000 ) <nl> + . verifyComplete ( ) ; <nl> + } <nl>  <nl> - Flux . range ( 1 , 1_000_000 ) <nl> - . publishOn ( Schedulers . fromExecutorService ( exec ) ) <nl> - . subscribe ( ts ) ; <nl> - <nl> - ts . assertNoValues ( ) <nl> - . assertNoError ( ) <nl> - . assertNotComplete ( ) ; <nl> - <nl> - ts . request ( 500_000 ) ; <nl> - <nl> - Thread . sleep ( 500 ) ; <nl> - <nl> - ts . assertValueCount ( 500_000 ) <nl> - . assertNoError ( ) <nl> - . assertNotComplete ( ) ; <nl> - <nl> - ts . request ( 500_000 ) ; <nl> - <nl> - ts . await ( Duration . ofSeconds ( 10 ) ) ; <nl> - ts . assertTerminated ( ) ; <nl> - <nl> - ts . assertValueCount ( 1_000_000 ) <nl> + @ Test <nl> 
mmm a / src / main / java / com / mycompany / myapp / web / rest / UserResource . java <nl> ppp b / src / main / java / com / mycompany / myapp / web / rest / UserResource . java <nl> public ResponseEntity & lt ; ManagedUserDTO & gt ; updateUser ( @ RequestBody ManagedUserDTO managedUserDTO ) throws URISyntaxException { <nl> log . debug ( " REST request to update User : { } " , managedUserDTO ) ; <nl> Optional & lt ; User & gt ; existingUser = userRepository . findOneByEmail ( managedUserDTO . getEmail ( ) ) ; <nl> - if ( existingUser . isPresent ( ) & & ( ! existingUser . get ( ) . getLogin ( ) . equalsIgnoreCase ( managedUserDTO . getLogin ( ) ) ) ) { <nl> + if ( existingUser . isPresent ( ) & & ( ! existingUser . get ( ) . getId ( ) . equals ( managedUserDTO . getId ( ) ) ) ) { <nl> return ResponseEntity . badRequest ( ) . headers ( HeaderUtil . createFailureAlert ( " user - management " , " emailexists " , " Email already in use " ) ) . body ( null ) ; <nl> } <nl> + existingUser = userRepository . findOneByLogin ( managedUserDTO . getLogin ( ) ) ; <nl> + if ( existingUser . isPresent ( ) & & ( ! existingUser . get ( ) . getId ( ) . equals ( managedUserDTO . getId ( ) ) ) ) { <nl> + return ResponseEntity . badRequest ( ) . headers ( HeaderUtil . createFailureAlert ( " user - management " , " userexists " , " Login name already used " ) ) . body ( null ) ; <nl> + } <nl> return userRepository <nl> + . findOneById ( managedUserDTO . getId ( ) ) <nl> 
mmm a / splice_machine / src / test / java / com / splicemachine / derby / impl / sql / execute / operations / JoinSelectionIT . java <nl> ppp b / splice_machine / src / test / java / com / splicemachine / derby / impl / sql / execute / operations / JoinSelectionIT . java <nl> @ Test <nl> public void testInnerJoinWithSubqueryFilterExactCriteria ( ) throws Exception { <nl> - fourthRowContainsQuery ( <nl> + ResultSet rs = methodWatcher . executeQuery ( <nl> format ( " explain select a2 . pid from % s a2 join " + <nl> " ( select person . pid from % s ) as a3 " + <nl> " on a2 . pid = a3 . pid " + <nl> - " where a2 . pid = 100 " , spliceTableWatcher2 , spliceTableWatcher ) , <nl> - BROADCAST_JOIN , methodWatcher ) ; <nl> + " where a2 . pid = 100 " , spliceTableWatcher2 , spliceTableWatcher ) ) ; <nl> + int count = 0 ; <nl> + while ( rs . next ( ) ) { <nl> + count++ ; <nl> + if ( count == 4 ) { <nl> + String row = rs . getString ( 1 ) ; <nl> + String joinStrategy = row . substring ( row . indexOf ( PLAN_LINE_LEADER ) + PLAN_LINE_LEADER . length ( ) , <nl> + row . indexOf ( JOIN_STRATEGY_TERMINATOR ) ) ; <nl> + Assert . assertThat ( " Join strategy must be either NESTED_LOOP_JOIN or BROADCAST_JOIN " , joinStrategy , <nl> + anyOf ( equalTo ( NESTED_LOOP_JOIN ) , equalTo ( BROADCAST_JOIN ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> } <nl>  <nl> - @ Test <nl> 
mmm a / app / src / main / java / moe / feng / nhentai / api / BookApi . java <nl> ppp b / app / src / main / java / moe / feng / nhentai / api / BookApi . java <nl> public static Bitmap getThumb ( Context context , Book book ) { <nl> String url = book . previewImageUrl ; <nl> - FileCacheManager m = FileCacheManager . getInstance ( context ) ; <nl>  <nl> - if ( ! m . cacheExistsUrl ( CACHE_THUMB , url , book . title ) & & ! m . createCacheFromNetwork ( CACHE_THUMB , url , book . title ) ) { <nl> - return null ; <nl> + if ( FileCacheManager . getInstance ( context ) . cacheExistsUrl ( CACHE_THUMB , url , book . title ) ) { <nl> + Log . d ( TAG , " Thumb : Loaded from cache " ) ; <nl> + return FileCacheManager . getInstance ( context ) . getBitmapUrl ( CACHE_THUMB , url , book . title ) ; <nl> } <nl> - <nl> - return m . getBitmapUrl ( CACHE_THUMB , url , book . title ) ; <nl> - } <nl> - <nl> - public static Bitmap getPageThumb ( Context context , Book book , int position ) { <nl> + else if ( FileCacheManager . getInstance ( context ) . createCacheFromNetwork ( CACHE_THUMB , url , book . title ) ) { <nl> + Log . d ( TAG , " Thumb : Downloaded from web " ) ; <nl> + return FileCacheManager . getInstance ( context ) . getBitmapUrl ( CACHE_THUMB , url , book . title ) ; <nl> + } <nl> + else { <nl> + return null ; <nl> 
mmm a / tcap / tcap - impl / src / main / java / org / mobicents / protocols / ss7 / tcap / TCAPProviderImpl . java <nl> ppp b / tcap / tcap - impl / src / main / java / org / mobicents / protocols / ss7 / tcap / TCAPProviderImpl . java <nl> private Long getAvailableTxIdPreview ( ) throws TCAPException { <nl> while ( true ) { <nl> - if ( this . curDialogId & lt ; this . stack . getDialogIdRangeStart ( ) ) <nl> - this . curDialogId = this . stack . getDialogIdRangeStart ( ) - 1 ; <nl> - if ( ++this . curDialogId & gt ; this . stack . getDialogIdRangeEnd ( ) ) <nl> - this . curDialogId = this . stack . getDialogIdRangeStart ( ) ; <nl> - Long id = this . curDialogId ; <nl> + Long id ; <nl> + if ( ! currentDialogId . compareAndSet ( this . stack . getDialogIdRangeEnd ( ) , this . stack . getDialogIdRangeStart ( ) + 1 ) ) { <nl> + id = currentDialogId . getAndIncrement ( ) ; <nl> + } else { <nl> + id = this . stack . getDialogIdRangeStart ( ) ; <nl> + } <nl> return id ; <nl> - } <nl> 
mmm a / de . prob2 . kernel / src / main / java / de / prob / model / eventb / translate / MachineXmlHandler . java <nl> ppp b / de . prob2 . kernel / src / main / java / de / prob / model / eventb / translate / MachineXmlHandler . java <nl> + } <nl> + <nl> + private void endContextExtraction ( ) throws SAXException { <nl> + ModelElementList & lt ; EventBAxiom & gt ; axms = new ModelElementList & lt ; EventBAxiom & gt ; ( inheritedAxioms ) ; <nl> + axms . addMultiple ( axioms ) ; <nl> + internalContext = internalContext . set ( Axiom . class , axms ) ; <nl> + internalContext = internalContext . set ( Constant . class , new ModelElementList & lt ; EventBConstant & gt ; ( constants ) ) ; <nl> + internalContext = internalContext . set ( Context . class , new ModelElementList & lt ; Context & gt ; ( Extends ) ) ; <nl> + internalContext = internalContext . set ( de . prob . model . representation . Set . class , new ModelElementList & lt ; de . prob . model . representation . Set & gt ; ( sets ) ) ; <nl> + <nl> ProofExtractor extractor = new ProofExtractor ( internalContext , <nl> directoryPath + File . separatorChar + internalContext . getName ( ) ) ; <nl> - internalContext . addProofs ( extractor . getProofs ( ) ) ; <nl> + internalContext = internalContext . set ( ProofObligation . class , extractor . getProofs ( ) ) ; <nl>  <nl> - extractingContext = false ; <nl> - } <nl> + model = model . addContext ( internalContext ) ; <nl> + if ( seesNames . contains ( internalContext . getName ( ) ) ) { <nl> + sees . add ( internalContext ) ; <nl> + } <nl> 
mmm a / src / main / java / org / apache / commons / net / smtp / SMTPSClient . java <nl> ppp b / src / main / java / org / apache / commons / net / smtp / SMTPSClient . java <nl> initSSLContext ( ) ; <nl>  <nl> SSLSocketFactory ssf = context . getSocketFactory ( ) ; <nl> - String ip = getRemoteAddress ( ) . getHostAddress ( ) ; <nl> + String host = ( _hostname_ ! = null ) ? _hostname_ : getRemoteAddress ( ) . getHostAddress ( ) ; <nl> int port = getRemotePort ( ) ; <nl> SSLSocket socket = <nl> - ( SSLSocket ) ssf . createSocket ( _socket_ , ip , port , true ) ; <nl> + ( SSLSocket ) ssf . createSocket ( _socket_ , host , port , true ) ; <nl> + socket . setEnableSessionCreation ( true ) ; <nl> + socket . setUseClientMode ( true ) ; <nl> + <nl> + if ( tlsEndpointChecking ) { <nl> + SSLSocketUtils . enableEndpointNameVerification ( socket ) ; <nl> + } <nl> + if ( protocols ! = null ) { <nl> + socket . setEnabledProtocols ( protocols ) ; <nl> + } <nl> + if ( suites ! = null ) { <nl> + socket . setEnabledCipherSuites ( suites ) ; <nl> + } <nl> + socket . startHandshake ( ) ; <nl> + <nl> + _socket_ = socket ; <nl> + _input_ = socket . getInputStream ( ) ; <nl> + _output_ = socket . getOutputStream ( ) ; <nl> + _reader = new CRLFLineReader ( <nl> + new InputStreamReader ( _input_ , encoding ) ) ; <nl> + _writer = new BufferedWriter ( <nl> + new OutputStreamWriter ( _output_ , encoding ) ) ; <nl> + <nl> + if ( hostnameVerifier ! = null & & ! hostnameVerifier . verify ( host , socket . getSession ( ) ) ) { <nl> + throw new SSLHandshakeException ( " Hostname does n't match certificate " ) ; <nl> + } <nl> + } <nl> 
mmm a / samples / iotfdeviceclient / src / com / ibm / iotf / sample / client / gateway / SampleRasPiGateway . java <nl> ppp b / samples / iotfdeviceclient / src / com / ibm / iotf / sample / client / gateway / SampleRasPiGateway . java <nl> - * / <nl> - private void addDeviceType ( ) throws IoTFCReSTException { <nl> - try { <nl> - JsonObject response = this . apiClient . addDeviceType ( DEVICE_TYPE , null , null , null ) ; <nl> - System . out . println ( response ) ; <nl> + return ; <nl> + } <nl> } catch ( IoTFCReSTException e ) { <nl> - System . out . println ( " HttpCode : " + e . getHttpCode ( ) + " ErrorMessage : : " + e . getMessage ( ) ) ; <nl> - System . out . println ( e . getResponse ( ) ) ; <nl> + if ( e . getHttpCode ( ) == 404 ) { <nl> + apiClient . addDeviceType ( deviceType , deviceType , null , null ) ; <nl> + } else { <nl> + System . err . println ( " ERROR : unable to add manually device type " + e . getMessage ( ) ) ; <nl> + e . printStackTrace ( ) ; <nl> + } <nl> } <nl> } <nl> - <nl> 
mmm a / letschat / src / main / java / io / fabric8 / app / letschat / LetschatModelProcessor . java <nl> ppp b / letschat / src / main / java / io / fabric8 / app / letschat / LetschatModelProcessor . java <nl> + . withContainerPort ( 5000 ) <nl> . withProtocol ( " TCP " ) <nl> . endPort ( ) <nl> . addNewEnv ( ) . withName ( " LETSCHAT_CREATE_HUBOT_USER " ) . withValue ( " true " ) . endEnv ( ) <nl> . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_TOKEN " ) . withValue ( " $ { LETSCHAT_HUBOT_TOKEN } " ) . endEnv ( ) <nl> - . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_PASSWORD " ) . withValue ( " $ { LETSCHAT_HUBOT_PASSWORD } " ) . endEnv ( ) <nl> - . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_USERNAME " ) . withValue ( " fabric8 " ) . endEnv ( ) <nl> + . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_PASSWORD " ) . withValue ( " $ { HUBOT_PASSWORD } " ) . endEnv ( ) <nl> + . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_USERNAME " ) . withValue ( " $ { HUBOT_USERNAME } " ) . endEnv ( ) <nl> . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_EMAIL " ) . withValue ( " fabric8 - admin @ googlegroups . com " ) . endEnv ( ) <nl> . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_FIRST_NAME " ) . withValue ( " fabric8 " ) . endEnv ( ) <nl> . addNewEnv ( ) . withName ( " LETSCHAT_HUBOT_LAST_NAME " ) . withValue ( " rocks " ) . endEnv ( ) <nl> 
mmm a / src / main / java / com / deutscheboerse / risk / dave / ers / processor / MarginShortfallSurplusProcessor . java <nl> ppp b / src / main / java / com / deutscheboerse / risk / dave / ers / processor / MarginShortfallSurplusProcessor . java <nl> + private JsonObject processMarginRequirementReport ( MarginRequirementReportMessageT mrrMessage ) <nl> + { <nl> + JsonObject mss = new JsonObject ( ) ; <nl> + mss . put ( " received " , new JsonObject ( ) . put ( " $ date " , ZonedDateTime . now ( ZoneOffset . UTC ) . format ( DateTimeFormatter . ISO_OFFSET_DATE_TIME ) ) ) ; <nl> mss . put ( " reqId " , mrrMessage . getID ( ) ) ; <nl> mss . put ( " sesId " , mrrMessage . getSetSesID ( ) . toString ( ) ) ; <nl> mss . put ( " rptId " , mrrMessage . getRptID ( ) ) ; <nl> - mss . put ( " txnTm " , new JsonObject ( ) . put ( " $ date " , timestampFormatter . format ( mrrMessage . getTxnTm ( ) . toGregorianCalendar ( ) . getTime ( ) ) ) ) ; <nl> - mss . put ( " bizDt " , new JsonObject ( ) . put ( " $ date " , timestampFormatter . format ( mrrMessage . getBizDt ( ) . toGregorianCalendar ( ) . getTime ( ) ) ) ) ; <nl> + mss . put ( " txnTm " , new JsonObject ( ) . put ( " $ date " , mrrMessage . getTxnTm ( ) . toGregorianCalendar ( ) . toZonedDateTime ( ) . withZoneSameInstant ( ZoneOffset . UTC ) . format ( DateTimeFormatter . ISO_OFFSET_DATE_TIME ) ) ) ; <nl> + mss . put ( " bizDt " , mrrMessage . getBizDt ( ) . toGregorianCalendar ( ) . toZonedDateTime ( ) . format ( DateTimeFormatter . ISO_LOCAL_DATE ) ) ; <nl> mss . put ( " clearingCcy " , mrrMessage . getCcy ( ) ) ; <nl>  <nl> processParties ( mrrMessage . getPty ( ) , mss ) ; <nl> 
mmm a / squidlib - util / src / main / java / squidpony / squidmath / CrossHash . java <nl> ppp b / squidlib - util / src / main / java / squidpony / squidmath / CrossHash . java <nl> + public static long hash64 ( final char [ ] [ ] data ) { <nl> + if ( data == null ) <nl> return 0 ; <nl> - long result = 0x632BE59BD9B4E019L ; <nl> - for ( int i = 0 ; i & lt ; data . length ; ) { <nl> - result ^= 0x8329C6EB9E6AD3E3L * ( hash64 ( data [ i ] ) * ++i ) ; <nl> + long result = 0x9E3779B97F4A7C94L , a = 0x632BE59BD9B4E019L ; <nl> + final int len = data . length ; <nl> + for ( int i = 0 ; i & lt ; len ; i++ ) { <nl> + result += ( a ^= 0x8329C6EB9E6AD3E3L * hash64 ( data [ i ] ) ) ; <nl> } <nl> - return ( result ^ 0xC6BC25963AB56C93L * data . length ) ; <nl> + return result * ( a & lt ; & lt ; 1 | 1 ) ; <nl> } <nl>  <nl> public static long hash64 ( final long [ ] [ ] data ) { <nl> 
mmm a / api / src / main / java / org / xnio / AbstractIoFuture . java <nl> ppp b / api / src / main / java / org / xnio / AbstractIoFuture . java <nl> * { @ inheritDoc } <nl> * / <nl> public Status await ( ) { <nl> - synchronized ( lock ) { <nl> - boolean intr = Thread . interrupted ( ) ; <nl> - try { <nl> - if ( status == Status . WAITING ) { <nl> - Xnio . checkBlockingAllowed ( ) ; <nl> + final Thread thread = Thread . currentThread ( ) ; <nl> + State & lt ; T & gt ; state ; <nl> + for ( ; ; ) { <nl> + state = getState ( ) ; <nl> + if ( state . getStatus ( ) ! = Status . WAITING ) { <nl> + return state . getStatus ( ) ; <nl> + } <nl> + Xnio . checkBlockingAllowed ( ) ; <nl> + State & lt ; T & gt ; withWaiter = state . withWaiter ( thread ) ; <nl> + if ( compareAndSetState ( state , withWaiter ) ) { <nl> + boolean intr = Thread . interrupted ( ) ; <nl> + try { <nl> do { <nl> - try { <nl> - lock . wait ( ) ; <nl> - } catch ( InterruptedException e ) { <nl> - intr = true ; <nl> - } <nl> - } while ( status == Status . WAITING ) ; <nl> - } <nl> - } finally { <nl> - if ( intr ) { <nl> - Thread . currentThread ( ) . interrupt ( ) ; <nl> + LockSupport . park ( this ) ; <nl> + if ( Thread . interrupted ( ) ) intr = true ; <nl> + state = getState ( ) ; <nl> + } while ( state . getStatus ( ) == Status . WAITING ) ; <nl> + return state . getStatus ( ) ; <nl> + } finally { <nl> + if ( intr ) thread . interrupt ( ) ; <nl> } <nl> - } <nl> - return status ; <nl> - } <nl> - } <nl> 
mmm a / modern - jogl - examples / src / tut09 / basicLighting / BasicLighting . java <nl> ppp b / modern - jogl - examples / src / tut09 / basicLighting / BasicLighting . java <nl> - public void reshape ( GLAutoDrawable glad , int x , int y , int w , int h ) { <nl> - System . out . println ( " reshape ( ) x : " + x + " y : " + y + " width : " + w + " height : " + h ) ; <nl> + @ Override <nl> + public void reshape ( GL3 gl3 , int w , int h ) { <nl>  <nl> - GL3 gl3 = glad . getGL ( ) . getGL3 ( ) ; <nl> + float zNear = 1 . 0f , zFar = 1_000f ; <nl> + MatrixStack_ perspMatrix = new MatrixStack_ ( ) ; <nl>  <nl> - MatrixStack perspectiveMatrix = new MatrixStack ( ) ; <nl> + perspMatrix . perspective ( 45 . 0f , ( float ) w / h , zNear , zFar ) ; <nl>  <nl> - perspectiveMatrix . setTop ( Jglm . perspective ( 45 . 0f , ( float ) w / ( float ) h , zNear , zFar ) ) ; <nl> - <nl> - perspectiveMatrix . top ( ) . print ( " perspectiveMatrix . top ( ) " ) ; <nl> - <nl> - gl3 . glBindBuffer ( GL3 . GL_UNIFORM_BUFFER , projectionUBO [ 0 ] ) ; <nl> - { <nl> - gl3 . glBufferSubData ( GL3 . GL_UNIFORM_BUFFER , 0 , 16 * 4 , GLBuffers . newDirectFloatBuffer ( perspectiveMatrix . top ( ) . toFloatArray ( ) ) ) ; <nl> - } <nl> - gl3 . glBindBuffer ( GL3 . GL_UNIFORM_BUFFER , 0 ) ; <nl> + gl3 . glBindBuffer ( GL_UNIFORM_BUFFER , projectionUniformBuffer . get ( 0 ) ) ; <nl> + gl3 . glBufferSubData ( GL_UNIFORM_BUFFER , 0 , Mat4 . SIZE , perspMatrix . top ( ) . toDfb ( matrixBuffer ) ) ; <nl> 
mmm a / useragent - generic - java / src / main / java / com / temenos / useragent / generic / http / DefaultHttpClient . java <nl> ppp b / useragent - generic - java / src / main / java / com / temenos / useragent / generic / http / DefaultHttpClient . java <nl> } <nl>  <nl> - private void logHttpRequest ( String url , HttpRequest request ) { <nl> - logger . info ( " \ nURL : { } \ nHEADERS : { } \ nREQUEST : { } " , url , <nl> - request . headers ( ) , <nl> - DefaultHttpClientHelper . prettyPrintXml ( request . payload ( ) ) ) ; <nl> - } <nl> - <nl> - private void logHttpResponse ( HttpResponse response ) { <nl> + private void logHttpRequest ( String url , HttpRequest request ) { <nl> + if ( logger . isInfoEnabled ( ) ) { <nl> + String payload = request . payload ( ) ; <nl> + if ( payload ! = null & & ! payload . isEmpty ( ) ) { <nl> + logger . info ( " \ nURL : { } \ nHEADERS : { } \ nREQUEST : { } " , url , <nl> + request . headers ( ) , <nl> + DefaultHttpClientHelper . prettyPrintXml ( payload ) ) ; <nl> + } else { <nl> + logger . info ( " \ nURL : { } \ nHEADERS : { } \ nNO REQUEST BODY " , url , <nl> + request . headers ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / impl / src / main / java / javax / faces / component / MethodExpressionMethodBindingAdapter . java <nl> ppp b / impl / src / main / java / javax / faces / component / MethodExpressionMethodBindingAdapter . java <nl> - Class toRestoreClass = null ; <nl> - if ( null ! = className ) { <nl> - try { <nl> - toRestoreClass = loadClass ( className , this ) ; <nl> - } <nl> - catch ( ClassNotFoundException e ) { <nl> - throw new IllegalStateException ( e . getMessage ( ) ) ; <nl> - } <nl> - <nl> - if ( null ! = toRestoreClass ) { <nl> - try { <nl> - result = <nl> - ( MethodBinding ) toRestoreClass . newInstance ( ) ; <nl> - } <nl> - catch ( InstantiationException e ) { <nl> - throw new IllegalStateException ( e . getMessage ( ) ) ; <nl> - } <nl> - catch ( IllegalAccessException a ) { <nl> - throw new IllegalStateException ( a . getMessage ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - if ( null ! = result & & null ! = savedState ) { <nl> - ( ( StateHolder ) result ) . restoreState ( context , savedState ) ; <nl> + if ( ! ( state instanceof MethodBinding ) ) { <nl> + Object [ ] stateStruct = ( Object [ ] ) state ; <nl> + Object savedState = stateStruct [ 0 ] ; <nl> + String className = stateStruct [ 1 ] . toString ( ) ; <nl> + MethodBinding result = null ; <nl> + <nl> + if ( className ! = null ) { <nl> + Class & lt ; ? & gt ; toRestoreClass = loadClass2 ( className , this ) ; <nl> + <nl> + if ( toRestoreClass ! = null ) { <nl> + result = newInstance ( toRestoreClass ) ; <nl> + } <nl> + <nl> + if ( ! isAnyNull ( result , savedState ) ) { <nl> + ( ( StateHolder ) result ) . restoreState ( context , savedState ) ; <nl> 
mmm a / jackson1 / src / main / java / com / webcohesion / enunciate / modules / jackson1 / model / util / JacksonUtil . java <nl> ppp b / jackson1 / src / main / java / com / webcohesion / enunciate / modules / jackson1 / model / util / JacksonUtil . java <nl> if ( typeAdapterInfo ! = null ) { <nl> final XmlJavaTypeAdapter finalInfo = typeAdapterInfo ; <nl> - DecoratedDeclaredType adapterTypeMirror = ( DecoratedDeclaredType ) Annotations . mirrorOf ( new Callable & lt ; Class & lt ; ? & gt ; & gt ; ( ) { <nl> + DecoratedTypeMirror adapterTypeMirror = Annotations . mirrorOf ( new Callable & lt ; Class & lt ; ? & gt ; & gt ; ( ) { <nl> @ Override <nl> public Class & lt ; ? & gt ; call ( ) throws Exception { <nl> return finalInfo . value ( ) ; <nl> } <nl> } , env ) ; <nl> - <nl> - AdapterType adapterType = new AdapterType ( adapterTypeMirror , context ) ; <nl> - if ( ( adaptedType instanceof DeclaredType & & adapterType . canAdapt ( adaptedType , context . getContext ( ) ) ) || <nl> - ( maybeContainedAdaptedType ! = adaptedType & & adapterType . canAdapt ( maybeContainedAdaptedType , context . getContext ( ) ) ) ) { <nl> - return adapterType ; <nl> + if ( adapterTypeMirror instanceof DecoratedDeclaredType ) { <nl> + return new AdapterType ( ( DecoratedDeclaredType ) adapterTypeMirror , context ) ; <nl> } <nl> - <nl> - throw new EnunciateException ( referer + " : adapter " + adapterTypeMirror + " does not adapt " + maybeContainedAdaptedType ) ; <nl> } <nl> } <nl> 
mmm a / sejda - sambox / src / main / java / org / sejda / impl / sambox / SplitDownTheMiddleTask . java <nl> ppp b / sejda - sambox / src / main / java / org / sejda / impl / sambox / SplitDownTheMiddleTask . java <nl> + importPage ( page , lookup , trimBox . getWidth ( ) , topSideHeight , 0 , - bottomSideHeight ) ; <nl> } <nl>  <nl> - private void importBottomPage ( PDPage page , LookupTable & lt ; PDPage & gt ; lookup , double ratio ) { <nl> - PDRectangle trimBox = page . getTrimBox ( ) ; <nl> + private void importBottomPage ( PDPage page , LookupTable & lt ; PDPage & gt ; lookup , double ratio ) throws TaskIOException { <nl> + PDRectangle trimBox = page . getTrimBox ( ) . rotate ( page . getRotation ( ) ) ; <nl> float h = trimBox . getHeight ( ) ; <nl> float r = ( float ) ratio ; <nl> float bottomSideHeight = h / ( r + 1 ) ; <nl>  <nl> - PDPage bottomPage = destinationHandler . importPage ( page ) ; <nl> - lookup . addLookupEntry ( page , bottomPage ) ; <nl> - PDRectangle lowerSide = new PDRectangle ( ) ; <nl> - lowerSide . setUpperRightY ( trimBox . getLowerLeftY ( ) + bottomSideHeight ) ; <nl> - lowerSide . setUpperRightX ( trimBox . getUpperRightX ( ) ) ; <nl> - lowerSide . setLowerLeftY ( trimBox . getLowerLeftY ( ) ) ; <nl> - lowerSide . setLowerLeftX ( trimBox . getLowerLeftX ( ) ) ; <nl> - <nl> - bottomPage . setCropBox ( lowerSide ) ; <nl> - bottomPage . setTrimBox ( lowerSide ) ; <nl> - bottomPage . setMediaBox ( lowerSide ) ; <nl> + importPage ( page , lookup , trimBox . getWidth ( ) , bottomSideHeight , 0 , 0 ) ; <nl> } <nl> - <nl> - @ Override <nl> 
mmm a / groovy - language - server / src / test / java / com / palantir / ls / groovy / GroovycWrapperTest . java <nl> ppp b / groovy - language - server / src / test / java / com / palantir / ls / groovy / GroovycWrapperTest . java <nl> + createSymbolInformation ( " friend " , SymbolKind . Variable , <nl> + createLocation ( scriptFile . getAbsolutePath ( ) , Ranges . createRange ( 0 , 7 , 0 , 13 ) ) , <nl> + Optional . of ( " MyScript " ) ) , <nl> + createSymbolInformation ( " friend " , SymbolKind . Variable , <nl> + createLocation ( scriptFile . getAbsolutePath ( ) , Ranges . createRange ( 0 , 7 , 0 , 13 ) ) , <nl> + Optional . of ( " run " ) ) , <nl> + createSymbolInformation ( " animal " , SymbolKind . Variable , <nl> + createLocation ( scriptFile . getAbsolutePath ( ) , Ranges . createRange ( 2 , 11 , 2 , 24 ) ) , <nl> + Optional . of ( " pet " ) ) , <nl> + createSymbolInformation ( " myAnimal " , SymbolKind . Variable , <nl> + createLocation ( scriptFile . getAbsolutePath ( ) , Ranges . createRange ( 3 , 10 , 3 , 18 ) ) , <nl> Optional . of ( " pet " ) ) , <nl> createSymbolInformation ( " pet " , SymbolKind . Method , <nl> - createLocation ( scriptFile . getAbsolutePath ( ) , Ranges . createRange ( 2 , 0 , 5 , 1 ) ) , <nl> + createLocation ( scriptFile . getAbsolutePath ( ) , Ranges . createRange ( 2 , 0 , 6 , 1 ) ) , <nl> Optional . of ( " MyScript " ) ) , <nl> createSymbolInformation ( " valueOf " , SymbolKind . Method , <nl> 
mmm a / jenkins / src / main / java / io / fabric8 / apps / jenkins / JenkinsModelProcessor . java <nl> ppp b / jenkins / src / main / java / io / fabric8 / apps / jenkins / JenkinsModelProcessor . java <nl> + . withContainerPort ( 8080 ) <nl> . endPort ( ) <nl> + . addNewEnv ( ) <nl> + . withName ( " DOMAIN " ) <nl> + . withValue ( " $ { DOMAIN } " ) <nl> + . endEnv ( ) <nl> . addNewEnv ( ) <nl> . withName ( " JENKINS_WORKFLOW_GIT_REPOSITORY " ) <nl> . withValue ( " $ { JENKINS_WORKFLOW_GIT_REPOSITORY } " ) <nl> 
mmm a / src / test / java / hudson / plugins / parameterizedtrigger / test / RenameJobTest . java <nl> ppp b / src / test / java / hudson / plugins / parameterizedtrigger / test / RenameJobTest . java <nl> } <nl> - <nl> + <nl> public void testRenameAndDeleteJobInParentFolder ( ) throws Exception { <nl> - MockFolder folder1 = ( MockFolder ) jenkins . createProject ( <nl> - ( TopLevelItemDescriptor ) jenkins . getDescriptor ( MockFolder . class ) , <nl> - " Folder1 " , <nl> - true <nl> - ) ; <nl> - MockFolder folder2 = ( MockFolder ) folder1 . createProject ( <nl> - ( TopLevelItemDescriptor ) jenkins . getDescriptor ( MockFolder . class ) , <nl> - " Folder2 " , <nl> - true <nl> - ) ; <nl> - FreeStyleProject p1 = ( FreeStyleProject ) folder2 . createProject ( <nl> - ( TopLevelItemDescriptor ) jenkins . getDescriptor ( FreeStyleProject . class ) , <nl> - " ProjectA " , <nl> - true <nl> - ) ; <nl> - FreeStyleProject p2 = ( FreeStyleProject ) folder1 . createProject ( <nl> - ( TopLevelItemDescriptor ) jenkins . getDescriptor ( FreeStyleProject . class ) , <nl> - " ProjectB " , <nl> - true <nl> - ) ; <nl> - <nl> + MockFolder folder1 = createProject ( MockFolder . class , jenkins , " Folder1 " ) ; <nl> + MockFolder folder2 = createProject ( MockFolder . class , folder1 , " Folder2 " ) ; <nl> + FreeStyleProject p1 = createProject ( FreeStyleProject . class , folder2 , " ProjectA " ) ; <nl> + FreeStyleProject p2 = createProject ( FreeStyleProject . class , folder1 , " ProjectB " ) ; <nl> + <nl> p1 . getPublishersList ( ) . add ( new BuildTrigger ( new BuildTriggerConfig ( <nl> String . format ( " .  .  / % s " , p2 . getName ( ) ) , <nl> 
mmm a / src / main / java / uk / co / coen / capsulecrm / client / COpportunity . java <nl> ppp b / src / main / java / uk / co / coen / capsulecrm / client / COpportunity . java <nl> } <nl>  <nl> - public static F . Promise & lt ; COpportunities & gt ; listByTag ( String tag , long time , TimeUnit unit ) { <nl> - return WS . url ( capsuleUrl + " / api / opportunity " ) <nl> - . setTimeout ( ( int ) unit . toMillis ( time ) ) <nl> - . setQueryParameter ( " tag " , tag ) <nl> - . setHeader ( " Content - Type " , " text / xml ; charset=utf - 8 " ) <nl> - . setAuth ( capsuleToken , " " ) <nl> - . get ( ) . map ( new F . Function & lt ; WS . Response , COpportunities & gt ; ( ) { <nl> - @ Override <nl> - public COpportunities apply ( WS . Response response ) throws Throwable { <nl> - return ( COpportunities ) xstream . unmarshal ( new DomReader ( response . asXml ( ) ) ) ; <nl> - } <nl> - } ) ; <nl> + public static Future & lt ; COpportunities & gt ; listByTag ( String tag , long time , TimeUnit unit ) throws IOException { <nl> + return transform ( new ListenableFutureAdapter & lt ; & gt ; ( asyncHttpClient . prepareGet ( capsuleUrl + " / api / opportunity " ) <nl> + . addQueryParameter ( " tag " , tag ) <nl> + . addHeader ( " Accept " , " application / xml " ) <nl> + . setRealm ( realm ) <nl> + . execute ( ) ) , new TransformHttpResponse & lt ; COpportunities & gt ; ( xstream ) ) ; <nl> } <nl>  <nl> - public static F . Promise & lt ; COpportunities & gt ; listModifiedSince ( DateTime modifiedSince ) { <nl> + public static Future & lt ; COpportunities & gt ; listModifiedSince ( DateTime modifiedSince ) throws IOException { <nl> 
mmm a / src / me / libraryaddict / disguise / disguisetypes / TargetedDisguise . java <nl> ppp b / src / me / libraryaddict / disguise / disguisetypes / TargetedDisguise . java <nl> - { <nl> + if ( ! disguiseViewers . contains ( playername ) ) { <nl> disguiseViewers . add ( playername ) ; <nl>  <nl> - if ( DisguiseAPI . isDisguiseInUse ( this ) ) <nl> - { <nl> + if ( DisguiseAPI . isDisguiseInUse ( this ) ) { <nl> DisguiseUtilities . checkConflicts ( this , playername ) ; <nl> DisguiseUtilities . refreshTracker ( this , playername ) ; <nl> + <nl> + if ( isHidePlayer ( ) & & getEntity ( ) instanceof Player ) { <nl> + try { <nl> + Player player = Bukkit . getPlayerExact ( playername ) ; <nl> + <nl> + if ( player ! = null ) { <nl> + PacketContainer deleteTab = new PacketContainer ( PacketType . Play . Server . PLAYER_INFO ) ; <nl> + <nl> + deleteTab . getPlayerInfoAction ( ) . write ( 0 , <nl> + canSee ( player ) ? PlayerInfoAction . REMOVE_PLAYER : PlayerInfoAction . ADD_PLAYER ) ; <nl> + deleteTab . getPlayerInfoDataLists ( ) . write ( 0 , <nl> + Arrays . asList ( new PlayerInfoData ( ReflectionManager . getGameProfile ( ( Player ) getEntity ( ) ) , 0 , <nl> + NativeGameMode . SURVIVAL , <nl> + WrappedChatComponent . fromText ( ( ( Player ) getEntity ( ) ) . getDisplayName ( ) ) ) ) ) ; <nl> + <nl> + ProtocolLibrary . getProtocolManager ( ) . sendServerPacket ( player , deleteTab ) ; <nl> + } <nl> + } <nl> + catch ( InvocationTargetException e ) { <nl> + e . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / bobas . businessobjectscommon / src / main / java / org / colorcoding / ibas / bobas / rules / BusinessRulesFactory . java <nl> ppp b / bobas . businessobjectscommon / src / main / java / org / colorcoding / ibas / bobas / rules / BusinessRulesFactory . java <nl> - * / <nl> - public synchronized static IBusinessRulesManager createManager ( ) throws BusinessRuleException { <nl> - if ( defaultManager == null ) { <nl> - synchronized ( BusinessRulesFactory . class ) { <nl> - if ( defaultManager == null ) { <nl> - try { <nl> - defaultManager = newManager ( MyConfiguration <nl> - . getConfigValue ( MyConfiguration . CONFIG_ITEM_BUSINESS_RULES_WAY , " " ) . toLowerCase ( ) ) ; <nl> - } catch ( Exception e ) { <nl> - throw new BusinessRuleException ( i18n . prop ( " msg_bobas_create_business_rules_manager_falid " ) , e ) ; <nl> - } <nl> - if ( defaultManager == null ) { <nl> - throw new BusinessRuleException ( i18n . prop ( " msg_bobas_create_business_rules_manager_falid " ) ) ; <nl> - } <nl> - } <nl> - } <nl> + * / <nl> + public synchronized IBusinessRulesManager createManager ( ) throws BusinessRuleException { <nl> + if ( defaultManager == null ) { <nl> + defaultManager = this . create ( MyConfiguration . CONFIG_ITEM_BUSINESS_RULES_WAY , " BusinessRulesManager " ) ; <nl> + } <nl> + return defaultManager ; <nl> 
mmm a / jfixby - cmns - api / jfixby - commons - api / com / jfixby / cmns / ver / Version . java <nl> ppp b / jfixby - cmns - api / jfixby - commons - api / com / jfixby / cmns / ver / Version . java <nl> + public String getVersionString ( ) { <nl> Debug . checkNull ( " packageName " , this . packageName ) ; <nl> Debug . checkEmpty ( " packageName " , this . packageName ) ; <nl> - Debug . checkNull ( " stage " , this . stage ) ; <nl> - Debug . checkTrue ( " major is invalid : " + this . major , this . major & gt ; = 0 ) ; <nl> - Debug . checkTrue ( " minor is invalid : " + this . minor , this . minor & gt ; = 0 ) ; <nl> - Debug . checkTrue ( " build is invalid : " + this . build , this . build & gt ; = 0 ) ; <nl> - return this . major + " . " + this . minor + " . " + this . stage . tagName + " . " + this . build ; <nl> + Debug . checkEmpty ( " major is invalid " , this . major ) ; <nl> + Debug . checkEmpty ( " minor is invalid " , this . minor ) ; <nl> + Debug . checkEmpty ( " build is invalid " , this . build ) ; <nl> + Debug . checkNull ( " major is invalid " , this . major ) ; <nl> + Debug . checkNull ( " minor is invalid " , this . minor ) ; <nl> + Debug . checkNull ( " build is invalid " , this . build ) ; <nl> + return this . major + " . " + this . minor + " . " + this . build ; <nl> } <nl> - <nl> - public String getPackageVersionString ( ) { <nl> 
mmm a / stroom - query - api / src / main / java / stroom / query / shared / Search . java <nl> ppp b / stroom - query - api / src / main / java / stroom / query / shared / Search . java <nl> - Search search = ( Search ) o ; <nl> + final Search search = ( Search ) o ; <nl>  <nl> - return new EqualsBuilder ( ) <nl> - . append ( incremental , search . incremental ) <nl> - . append ( dataSourceRef , search . dataSourceRef ) <nl> - . append ( expression , search . expression ) <nl> - . append ( componentSettingsMap , search . componentSettingsMap ) <nl> - . append ( paramMap , search . paramMap ) <nl> - . isEquals ( ) ; <nl> + if ( incremental ! = search . incremental ) return false ; <nl> + if ( dataSourceRef ! = null ? ! dataSourceRef . equals ( search . dataSourceRef ) : search . dataSourceRef ! = null ) <nl> + return false ; <nl> + if ( expression ! = null ? ! expression . equals ( search . expression ) : search . expression ! = null ) return false ; <nl> + if ( componentSettingsMap ! = null ? ! componentSettingsMap . equals ( search . componentSettingsMap ) : search . componentSettingsMap ! = null ) <nl> + return false ; <nl> + if ( paramMap ! = null ? ! paramMap . equals ( search . paramMap ) : search . paramMap ! = null ) return false ; <nl> + return dateTimeLocale ! = null ? dateTimeLocale . equals ( search . dateTimeLocale ) : search . dateTimeLocale == null ; <nl> } <nl> 
mmm a / src / main / java / pcl / OpenFM / TileEntity / TileEntityRadio . java <nl> ppp b / src / main / java / pcl / OpenFM / TileEntity / TileEntityRadio . java <nl> + } <nl> + } <nl> + } <nl> + if ( ( Minecraft . getMinecraft ( ) . thePlayer ! = null ) & & ( mp3Player ! = null || oggPlayer ! = null ) & & ( ! isInvalid ( ) ) ) { <nl> + vol = getClosest ( ) ; <nl> + if ( vol & gt ; 10000 . 0F * volume ) { <nl> + if ( mp3Player ! = null ) <nl> + mp3Player . setVolume ( 0 . 0F ) ; <nl> + else if ( oggPlayer ! = null ) <nl> + oggPlayer . setVolume ( 0 . 0f ) ; <nl> + } else { <nl> + float v2 = 10000 . 0F / vol / 100 . 0F ; <nl> if ( v2 & gt ; 1 . 0F ) { <nl> - mp3Player . setVolume ( 1 . 0F * volume * volume ) ; <nl> + if ( mp3Player ! = null ) <nl> + mp3Player . setVolume ( 1 . 0F * volume * volume ) ; <nl> + else if ( oggPlayer ! = null ) <nl> + oggPlayer . setVolume ( 1 . 0F * volume * volume ) ; <nl> } else { <nl> - mp3Player . setVolume ( v2 * volume * volume ) ; <nl> + if ( mp3Player ! = null ) <nl> + mp3Player . setVolume ( v2 * volume * volume ) ; <nl> + else if ( oggPlayer ! = null ) <nl> + oggPlayer . setVolume ( v2 * volume * volume ) ; <nl> } <nl> } <nl> if ( vol == 0 . 0F ) { <nl> 
mmm a / jdbc - lib / src / test / java / com / streamsets / pipeline / stage / origin / jdbc / table / BasicIT . java <nl> ppp b / jdbc - lib / src / test / java / com / streamsets / pipeline / stage / origin / jdbc / table / BasicIT . java <nl> . tableConfigBeans ( ImmutableList . of ( tableConfigBean ) ) <nl> . build ( ) ; <nl>  <nl> - SourceRunner runner = new SourceRunner . Builder ( TableJdbcDSource . class , tableJdbcSource ) <nl> - . addOutputLane ( " a " ) . build ( ) ; <nl> + PushSourceRunner runner = new PushSourceRunner . Builder ( TableJdbcDSource . class , tableJdbcSource ) <nl> + . addOutputLane ( " a " ) <nl> + . setOnRecordError ( OnRecordError . TO_ERROR ) <nl> + . build ( ) ; <nl> runner . runInit ( ) ; <nl> try { <nl> - StageRunner . Output output = runner . runProduce ( " " , 5 ) ; <nl> - List & lt ; Record & gt ; records = output . getRecords ( ) . get ( " a " ) ; <nl> - Assert . assertEquals ( 5 , records . size ( ) ) ; <nl> - checkRecords ( EXPECTED_CRICKET_STARS_RECORDS . subList ( 0 , 5 ) , records ) ; <nl> + JdbcPushSourceTestCallback callback = new JdbcPushSourceTestCallback ( runner , 2 ) ; <nl> + runner . runProduce ( Collections . emptyMap ( ) , 5 , callback ) ; <nl>  <nl> - output = runner . runProduce ( output . getNewOffset ( ) , 5 ) ; <nl> - records = output . getRecords ( ) . get ( " a " ) ; <nl> + List & lt ; List & lt ; Record & gt ; & gt ; batchRecords = callback . waitForAllBatchesAndReset ( ) ; <nl> + <nl> + List & lt ; Record & gt ; records = batchRecords . get ( 0 ) ; <nl> Assert . assertEquals ( 5 , records . size ( ) ) ; <nl> - checkRecords ( EXPECTED_CRICKET_STARS_RECORDS . subList ( 5 , 10 ) , records ) ; <nl> + checkRecords ( EXPECTED_CRICKET_STARS_RECORDS . subList ( 0 , 5 ) , records ) ; <nl> 
mmm a / src / main / java / com / livefyre / android / core / WriteClient . java <nl> ppp b / src / main / java / com / livefyre / android / core / WriteClient . java <nl> + public static void postContent ( String networkId , <nl> + String collectionId , <nl> + String parentId , <nl> + String token , <nl> String body , <nl> JsonHttpResponseHandler handler ) <nl> { <nl> - Builder paramsBuilder = new Builder ( ) ; <nl> - paramsBuilder . appendQueryParameter ( " lftoken " , token ) ; <nl>  <nl> - StringBuilder urlStringBuilder = new StringBuilder ( Config . scheme ) <nl> - . append ( Config . quillDomain ) . append ( " . " ) <nl> - . append ( Config . getHostname ( networkId ) ) <nl> - . append ( " / api / v3 . 0 / collection / " ) <nl> - . append ( collectionId ) <nl> - . append ( " / post / " ) <nl> - . append ( paramsBuilder . toString ( ) ) ; <nl> + final Builder uriBuilder = new Uri . Builder ( ) <nl> + . scheme ( Config . scheme ) <nl> + . authority ( Config . quillDomain + " . " + Config . getHostname ( networkId ) ) <nl> + . appendPath ( " api " ) <nl> + . appendPath ( " v3 . 0 " ) <nl> + . appendPath ( " collection " ) <nl> + . appendPath ( collectionId ) <nl> + . appendPath ( " post " ) <nl> + . appendPath ( " " ) <nl> + . appendQueryParameter ( " lftoken " , token ) ; <nl>  <nl> - RequestParams bodyParams = new RequestParams ( ) ; <nl> - bodyParams . put ( " body " , body ) ; <nl> 
mmm a / src / main / java / com / livefyre / android / core / PublicAPIClient . java <nl> ppp b / src / main / java / com / livefyre / android / core / PublicAPIClient . java <nl> throws MalformedURLException <nl> { <nl> - Builder paramsBuilder = new Builder ( ) ; <nl> - if ( userToken ! = null ) { <nl> - paramsBuilder . appendQueryParameter ( " lftoken " , userToken ) ; <nl> - } <nl> - if ( statuses ! = null ) { <nl> - paramsBuilder . appendQueryParameter ( " status " , TextUtils . join ( " , " , statuses ) ) ; <nl> - } <nl> - if ( offset ! = null ) { <nl> - paramsBuilder . appendQueryParameter ( " offset " , Integer . toString ( offset ) ) ; <nl> - } <nl> - <nl> - StringBuilder urlStringBuilder = new StringBuilder ( Config . scheme ) <nl> - . append ( Config . bootstrapDomain ) . append ( " . " ) <nl> - . append ( Config . getHostname ( networkId ) ) <nl> - . append ( " / api / v3 . 0 / author / " ) <nl> - . append ( userId ) <nl> - . append ( " / comments / " ) <nl> - . append ( paramsBuilder . toString ( ) ) ; <nl> + final Builder uriBuilder = new Uri . Builder ( ) <nl> + . scheme ( Config . scheme ) <nl> + . authority ( Config . bootstrapDomain + " . " + Config . getHostname ( networkId ) ) <nl> + . appendPath ( " api " ) <nl> + . appendPath ( " v3 . 0 " ) <nl> + . appendPath ( " author " ) <nl> + . appendPath ( userId ) <nl> + . appendPath ( " " ) <nl> + . appendPath ( " comments " ) <nl> + . appendPath ( " " ) ; <nl>  <nl> - return urlStringBuilder . toString ( ) ; <nl> - } <nl> + if ( userToken ! = null ) { <nl> 
mmm a / base / org . codehaus . groovy21 / src / org / codehaus / groovy / antlr / AntlrParserPlugin . java <nl> ppp b / base / org . codehaus . groovy21 / src / org / codehaus / groovy / antlr / AntlrParserPlugin . java <nl> } <nl> if ( target ! = null ) { <nl> + int off = Math . min ( locations . findOffset ( target . getLastLineNumber ( ) + 1 , 1 ) , locations . getEnd ( ) - 1 ) ; <nl> + int [ ] row_col = locations . getRowCol ( off ) ; <nl> + <nl> synthetic = new ReturnStatement ( ConstantExpression . NULL ) ; <nl> - synthetic . setStart ( target . getEnd ( ) +1 ) ; <nl> - synthetic . setEnd ( target . getEnd ( ) +1 ) ; <nl> - synthetic . setLineNumber ( target . getLastLineNumber ( ) ) ; <nl> - synthetic . setLastLineNumber ( target . getLineNumber ( ) ) ; <nl> - synthetic . setColumnNumber ( target . getLastColumnNumber ( ) +1 ) ; <nl> - synthetic . setLastColumnNumber ( target . getColumnNumber ( ) +1 ) ; <nl> + synthetic . setStart ( off ) ; <nl> + synthetic . setEnd ( off ) ; <nl> + synthetic . setLineNumber ( row_col [ 0 ] ) ; <nl> + synthetic . setColumnNumber ( row_col [ 1 ] ) ; <nl> + synthetic . setLastLineNumber ( row_col [ 0 ] ) ; <nl> + synthetic . setLastColumnNumber ( row_col [ 1 ] ) ; <nl> } <nl> return synthetic ; <nl> - } <nl> 
mmm a / mediation / mediatedviews / InMobi / src / com / appnexus / opensdk / mediatednativead / InMobiNativeAd . java <nl> ppp b / mediation / mediatedviews / InMobi / src / com / appnexus / opensdk / mediatednativead / InMobiNativeAd . java <nl> + * @ return native ad response from InMobi <nl> * / <nl> @ Override <nl> public void requestNativeAd ( Context context , String uid , MediatedNativeAdController mBC , TargetingParameters tp ) { <nl> - if ( InMobiSettings . INMOBI_APP_ID == null || InMobiSettings . INMOBI_APP_ID . isEmpty ( ) ) { <nl> - Clog . e ( Clog . mediationLogTag , " InMobi mediation failed . Call InMobiSettings . setInMobiAppId ( String key , Context context ) to set the app id . " ) ; <nl> - if ( mBC ! = null ) { <nl> + if ( mBC ! = null ) { <nl> + if ( StringUtil . isEmpty ( InMobiSettings . INMOBI_APP_ID ) ) { <nl> + Clog . e ( Clog . mediationLogTag , " InMobi mediation failed . Call InMobiSettings . setInMobiAppId ( String key , Context context ) to set the app id . " ) ; <nl> mBC . onAdFailed ( ResultCode . MEDIATED_SDK_UNAVAILABLE ) ; <nl> + return ; <nl> } <nl> - return ; <nl> - } <nl> - IMNative nativeAd ; <nl> - if ( uid == null || uid . isEmpty ( ) ) { <nl> - nativeAd = new IMNative ( InMobiSettings . INMOBI_APP_ID , new InMobiNativeAdListener ( mBC ) ) ; <nl> - } else { <nl> - nativeAd = new IMNative ( uid , new InMobiNativeAdListener ( mBC ) ) ; <nl> - } <nl> - InMobiSettings . setTargetingParams ( tp ) ; <nl> - nativeAd . loadAd ( ) ; <nl> + try { <nl> + long placementID = Long . parseLong ( uid ) ; <nl> + InMobiNativeAdListener nativeAdListener = new InMobiNativeAdListener ( mBC ) ; <nl> + InMobiNative nativeAd = new InMobiNative ( placementID , nativeAdListener ) ; <nl> + InMobiSettings . setTargetingParams ( tp ) ; <nl> + nativeAd . load ( ) ; <nl> + } catch ( NumberFormatException e ) { <nl> 
mmm a / java_point_to_point_example / app / src / main / java / com / projecttango / examples / java / pointtopoint / PointToPointRenderer . java <nl> ppp b / java_point_to_point_example / app / src / main / java / com / projecttango / examples / java / pointtopoint / PointToPointRenderer . java <nl> * NOTE : This must be called from the OpenGL render thread - it is not thread safe . <nl> * / <nl> - public void updateRenderCameraPose ( TangoPoseData devicePose , DeviceExtrinsics extrinsics ) { <nl> - Pose cameraPose = ScenePoseCalculator . toOpenGlCameraPose ( devicePose , extrinsics ) ; <nl> - getCurrentCamera ( ) . setRotation ( cameraPose . getOrientation ( ) ) ; <nl> - getCurrentCamera ( ) . setPosition ( cameraPose . getPosition ( ) ) ; <nl> + public void updateRenderCameraPose ( TangoPoseData cameraPose ) { <nl> + float [ ] rotation = cameraPose . getRotationAsFloats ( ) ; <nl> + float [ ] translation = cameraPose . getTranslationAsFloats ( ) ; <nl> + Quaternion quaternion = new Quaternion ( rotation [ 3 ] , rotation [ 0 ] , rotation [ 1 ] , rotation [ 2 ] ) ; <nl> + getCurrentCamera ( ) . setRotation ( quaternion . conjugate ( ) ) ; <nl> + getCurrentCamera ( ) . setPosition ( translation [ 0 ] , translation [ 1 ] , translation [ 2 ] ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / android - networking / src / main / java / com / androidnetworking / internal / InternalRunnable . java <nl> ppp b / android - networking / src / main / java / com / androidnetworking / internal / InternalRunnable . java <nl> - ANData data = null ; <nl> try { <nl> - data = InternalNetworking . performSimpleRequest ( request ) ; <nl> - if ( data == null ) { <nl> + okHttpResponse = InternalNetworking . performSimpleRequest ( request ) ; <nl> + <nl> + if ( okHttpResponse == null ) { <nl> + ANError anError = new ANError ( ) ; <nl> + anError = request . parseNetworkError ( anError ) ; <nl> + anError . setErrorDetail ( ANConstants . CONNECTION_ERROR ) ; <nl> + anError . setErrorCode ( 0 ) ; <nl> + deliverError ( request , anError ) ; <nl> return ; <nl> } <nl> - if ( data . code == 304 ) { <nl> - request . finish ( ) ; <nl> + <nl> + if ( request . getResponseAs ( ) == RESPONSE . OK_HTTP_RESPONSE ) { <nl> + request . deliverOkHttpResponse ( okHttpResponse ) ; <nl> return ; <nl> } <nl> - if ( data . code & gt ; = 400 ) { <nl> - ANError anError = new ANError ( data ) ; <nl> + if ( okHttpResponse . code ( ) & gt ; = 400 ) { <nl> + ANError anError = new ANError ( okHttpResponse ) ; <nl> anError = request . parseNetworkError ( anError ) ; <nl> - anError . setErrorCode ( data . code ) ; <nl> + anError . setErrorCode ( okHttpResponse . code ( ) ) ; <nl> anError . setErrorDetail ( ANConstants . RESPONSE_FROM_SERVER_ERROR ) ; <nl> deliverError ( request , anError ) ; <nl> return ; <nl> } <nl> + <nl> + ANResponse response = request . parseResponse ( okHttpResponse ) ; <nl> + if ( ! response . isSuccess ( ) ) { <nl> 
mmm a / android - networking / src / main / java / com / androidnetworking / internal / InternalRunnable . java <nl> ppp b / android - networking / src / main / java / com / androidnetworking / internal / InternalRunnable . java <nl> - ANData data = null ; <nl> + private void goForUploadRequest ( ) { <nl> + Response okHttpResponse = null ; <nl> try { <nl> - data = InternalNetworking . performUploadRequest ( request ) ; <nl> - if ( data == null ) { <nl> + okHttpResponse = InternalNetworking . performUploadRequest ( request ) ; <nl> + <nl> + if ( okHttpResponse == null ) { <nl> + ANError anError = new ANError ( ) ; <nl> + anError = request . parseNetworkError ( anError ) ; <nl> + anError . setErrorDetail ( ANConstants . CONNECTION_ERROR ) ; <nl> + anError . setErrorCode ( 0 ) ; <nl> + deliverError ( request , anError ) ; <nl> return ; <nl> } <nl> - if ( data . code == 304 ) { <nl> - request . finish ( ) ; <nl> + <nl> + if ( request . getResponseAs ( ) == RESPONSE . OK_HTTP_RESPONSE ) { <nl> + request . deliverOkHttpResponse ( okHttpResponse ) ; <nl> return ; <nl> } <nl> - if ( data . code & gt ; = 400 ) { <nl> - ANError anError = new ANError ( data ) ; <nl> + <nl> + if ( okHttpResponse . code ( ) & gt ; = 400 ) { <nl> + ANError anError = new ANError ( okHttpResponse ) ; <nl> anError = request . parseNetworkError ( anError ) ; <nl> - anError . setErrorCode ( data . code ) ; <nl> + anError . setErrorCode ( okHttpResponse . code ( ) ) ; <nl> anError . setErrorDetail ( ANConstants . RESPONSE_FROM_SERVER_ERROR ) ; <nl> deliverError ( request , anError ) ; <nl> return ; <nl> } <nl> - ANResponse response = request . parseResponse ( data ) ; <nl> + ANResponse response = request . parseResponse ( okHttpResponse ) ; <nl> + if ( ! response . isSuccess ( ) ) { <nl> + deliverError ( request , response . getError ( ) ) ; <nl> 
mmm a / ds3_java_cli / src / test / java / com / spectralogic / ds3cli / Ds3Cli_Test . java <nl> ppp b / ds3_java_cli / src / test / java / com / spectralogic / ds3cli / Ds3Cli_Test . java <nl> " } " ; <nl>  <nl> final Arguments args = new Arguments ( new String [ ] { " ds3_java_cli " , " - e " , " localhost : 8080 " , " - k " , " key ! " , " - a " , " access " , " - c " , " delete_bucket " , " - b " , " bucketName " , " -  - output - format " , " json " } ) ; <nl> - final Ds3Client client = mock ( Ds3Client . class ) ; <nl> - final WebResponse webResponse = mock ( WebResponse . class ) ; <nl> - final Headers headers = mock ( Headers . class ) ; <nl> - when ( webResponse . getStatusCode ( ) ) . thenReturn ( 204 ) ; <nl> - when ( webResponse . getHeaders ( ) ) . thenReturn ( headers ) ; <nl> - <nl> - final DeleteBucketResponse deleteBucketResponse = new DeleteBucketResponse ( webResponse ) ; <nl> - when ( client . deleteBucket ( any ( DeleteBucketRequest . class ) ) ) . thenReturn ( deleteBucketResponse ) ; <nl> - <nl> - final CliCommand command = CliCommandFactory . getCommandExecutor ( args . getCommand ( ) ) . withProvider ( new Ds3ProviderImpl ( client , null ) , null ) ; <nl> + final CliCommand command = CliCommandFactory . getCommandExecutor ( args . getCommand ( ) ) ; <nl> command . init ( args ) ; <nl> - final CommandResponse result = command . render ( ) ; <nl> - assertTrue ( result . getMessage ( ) . endsWith ( expected ) ) ; <nl> + assertTrue ( command instanceof DeleteBucket ) ; <nl> + final View view = command . getView ( ) ; <nl> + final String result = view . render ( new DefaultResult ( " Success : Deleted bucket 'bucketName ' . " ) ) ; <nl> + assertTrue ( result . endsWith ( expected ) ) ; <nl> + } <nl> 
mmm a / test / se / hiflyer / fettle / builder / StateMachineBuilderTest . java <nl> ppp b / test / se / hiflyer / fettle / builder / StateMachineBuilderTest . java <nl> machine . fireEvent ( " " ) ; <nl>  <nl> - verifyOnce ( ) . on ( entryAction ) . perform ( ) ; <nl> - verifyNever ( ) . on ( exitAction ) . perform ( ) ; <nl> + verifyOnce ( ) . on ( entryAction ) . perform ( any ( States . class ) , any ( States . class ) , any ( String . class ) , Arguments . NO_ARGS ) ; <nl> + verifyNever ( ) . on ( exitAction ) . perform ( any ( States . class ) , any ( States . class ) , any ( String . class ) , Arguments . NO_ARGS ) ; <nl>  <nl> machine . fireEvent ( " " ) ; <nl>  <nl> - verifyOnce ( ) . on ( entryAction ) . perform ( ) ; <nl> - verifyOnce ( ) . on ( exitAction ) . perform ( ) ; <nl> + verifyOnce ( ) . on ( entryAction ) . perform ( any ( States . class ) , any ( States . class ) , any ( String . class ) , Arguments . NO_ARGS ) ; <nl> + verifyOnce ( ) . on ( exitAction ) . perform ( any ( States . class ) , any ( States . class ) , any ( String . class ) , Arguments . NO_ARGS ) ; <nl> } <nl>  <nl> } <nl> 
mmm a / src / org / jgroups / protocols / pbcast / NAKACK2 . java <nl> ppp b / src / org / jgroups / protocols / pbcast / NAKACK2 . java <nl> + * Benefit : fewer threads blocked on the same lock , these threads can be returned to the thread pool <nl> + * / <nl> + protected void removeAndDeliver ( Table & lt ; Message & gt ; buf , Address sender , boolean loopback , AsciiString cluster_name ) { <nl> + AtomicInteger adders=buf . getAdders ( ) ; <nl> + if ( adders . getAndIncrement ( ) ! = 0 ) <nl> + return ; <nl> boolean remove_msgs=discard_delivered_msgs & & ! loopback ; <nl> - MessageBatch batch=new MessageBatch ( max_msg_batch_size ) . dest ( null ) . sender ( sender ) . clusterName ( cluster_name ) . multicast ( true ) ; <nl> + MessageBatch batch=new MessageBatch ( buf . size ( ) ) . dest ( null ) . sender ( sender ) . clusterName ( cluster_name ) . multicast ( true ) ; <nl> Supplier & lt ; MessageBatch & gt ; batch_creator= ( ) - & gt ; batch ; <nl> - while ( true ) { <nl> - batch . reset ( ) ; <nl> - buf . removeMany ( processing , remove_msgs , max_msg_batch_size , <nl> - no_dummy_and_no_oob_delivered_msgs_and_no_dont_loopback_msgs , <nl> - batch_creator , BATCH_ACCUMULATOR , BATCH_VALIDATOR ) ; <nl> - if ( batch . isEmpty ( ) ) { <nl> - if ( rebroadcasting ) <nl> - checkForRebroadcasts ( ) ; <nl> - return ; <nl> + do { <nl> + try { <nl> + batch . reset ( ) ; <nl> + buf . removeMany ( remove_msgs , 0 , no_dummy_and_no_oob_delivered_msgs_and_no_dont_loopback_msgs , <nl> + batch_creator , BATCH_ACCUMULATOR ) ; <nl> } <nl> - deliverBatch ( batch ) ; <nl> + catch ( Throwable t ) { <nl> + log . error ( " failed removing messages from table for " + sender , t ) ; <nl> + } <nl> + if ( ! batch . isEmpty ( ) ) <nl> + deliverBatch ( batch ) ; <nl> } <nl> - <nl> + while ( adders . decrementAndGet ( ) ! = 0 ) ; <nl> + if ( rebroadcasting ) <nl> + checkForRebroadcasts ( ) ; <nl> } <nl> 
mmm a / src / main / java / org / eclipselabs / garbagecat / domain / jdk / G1MixedPauseEvent . java <nl> ppp b / src / main / java / org / eclipselabs / garbagecat / domain / jdk / G1MixedPauseEvent . java <nl> + if ( logEntry . matches ( REGEX ) ) { <nl> + Pattern pattern = Pattern . compile ( REGEX ) ; <nl> Matcher matcher = pattern . matcher ( logEntry ) ; <nl> if ( matcher . find ( ) ) { <nl> timestamp = JdkMath . convertSecsToMillis ( matcher . group ( 1 ) ) . longValue ( ) ; <nl> - combined = JdkMath . calcKilobytes ( Integer . parseInt ( matcher . group ( 2 ) ) , matcher . group ( 3 ) . charAt ( 0 ) ) ; <nl> - combinedEnd = JdkMath . calcKilobytes ( Integer . parseInt ( matcher . group ( 4 ) ) , matcher . group ( 5 ) . charAt ( 0 ) ) ; <nl> - combinedAvailable = JdkMath . calcKilobytes ( Integer . parseInt ( matcher . group ( 6 ) ) , <nl> - matcher . group ( 7 ) . charAt ( 0 ) ) ; <nl> - duration = JdkMath . convertSecsToMillis ( matcher . group ( 8 ) ) . intValue ( ) ; <nl> + combined = JdkMath . calcKilobytes ( Integer . parseInt ( matcher . group ( 2 ) ) , matcher . group ( 4 ) . charAt ( 0 ) ) ; <nl> + combinedEnd = JdkMath . calcKilobytes ( Integer . parseInt ( matcher . group ( 5 ) ) , matcher . group ( 7 ) . charAt ( 0 ) ) ; <nl> + combinedAvailable = JdkMath . calcKilobytes ( Integer . parseInt ( matcher . group ( 8 ) ) , <nl> + matcher . group ( 10 ) . charAt ( 0 ) ) ; <nl> + duration = JdkMath . convertSecsToMillis ( matcher . group ( 11 ) ) . intValue ( ) ; <nl> } <nl> } else if ( logEntry . matches ( REGEX_PREPROCESSED ) ) { <nl> 
mmm a / nginx - admin - ui / src / main / java / com / jslsolucoes / nginx / admin / repository / impl / UpstreamRepositoryImpl . java <nl> ppp b / nginx - admin - ui / src / main / java / com / jslsolucoes / nginx / admin / repository / impl / UpstreamRepositoryImpl . java <nl> @ Override <nl> public Upstream hasEquals ( Upstream upstream ) { <nl> - try { <nl> - StringBuilder hql = new StringBuilder ( " from Upstream where name = : name " ) ; <nl> - if ( upstream . getId ( ) ! = null ) { <nl> - hql . append ( " and id & lt ; & gt ; : id " ) ; <nl> - } <nl> - Query query = entityManager . createQuery ( hql . toString ( ) ) . setParameter ( " name " , upstream . getName ( ) ) ; <nl> - if ( upstream . getId ( ) ! = null ) { <nl> - query . setParameter ( " id " , upstream . getId ( ) ) ; <nl> - } <nl> - return ( Upstream ) query . getSingleResult ( ) ; <nl> - } catch ( NoResultException e ) { <nl> - return null ; <nl> + Criteria criteria = session . createCriteria ( Upstream . class ) ; <nl> + criteria . add ( Restrictions . eq ( " name " , upstream . getName ( ) ) ) ; <nl> + if ( upstream . getId ( ) ! = null ) { <nl> + criteria . add ( Restrictions . ne ( " id " , upstream . getId ( ) ) ) ; <nl> } <nl> + return ( Upstream ) criteria . uniqueResult ( ) ; <nl> } <nl> + <nl> + @ Override <nl> 
mmm a / src / test / java / innovimax / quixproc / datamodel / generator / test / TestGenerator . java <nl> ppp b / src / test / java / innovimax / quixproc / datamodel / generator / test / TestGenerator . java <nl> - } else { <nl> - <nl> - <nl> - for ( ATreeGenerator . Type gtype : EnumSet . of ( ATreeGenerator . Type . HIGH_NODE_NAME_SIZE , <nl> - ATreeGenerator . Type . HIGH_NODE_NAME_SIZE , ATreeGenerator . Type . HIGH_NODE_DENSITY , <nl> - ATreeGenerator . Type . HIGH_NODE_DEPTH ) ) { <nl> - for ( SpecialType stype : SpecialType . allowedModifiers ( gtype ) ) { <nl> - for ( Variation variation : Variation . values ( ) ) { <nl> - AGenerator generator = AXMLGenerator . instance ( gtype , stype ) ; <nl> - System . out . println ( gtype+ " , " +stype+ " , " +variation ) ; <nl> - InputStream is = generator . getInputStream ( 10 , Unit . MBYTE , variation ) ; <nl> - QuiXEventStreamReader xqesr = new QuiXEventStreamReader ( new StreamSource ( is ) ) ; <nl> - ValidQuiXTokenStream vqxs = new ValidQuiXTokenStream ( xqesr ) ; <nl> - while ( vqxs . hasNext ( ) ) { <nl> - vqxs . next ( ) ; <nl> - } <nl> - } <nl> + public static void main ( String [ ] args ) throws QuiXException , IOException { <nl> + for ( Process process : Process . values ( ) ) { <nl> + testAll ( process , 10 , Unit . MBYTE ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / src / Grepolis / IO / Loader . java <nl> ppp b / src / Grepolis / IO / Loader . java <nl> - public static void loadDocksTroops ( ) { <nl> - BufferedReader reader = null ; <nl> + } <nl>  <nl> - CodeSource codeSource = GrepolisBot . class . getProtectionDomain ( ) . getCodeSource ( ) ; <nl> - File jarFile = null ; <nl> - try { <nl> - jarFile = new File ( codeSource . getLocation ( ) . toURI ( ) . getPath ( ) ) ; <nl> - } catch ( URISyntaxException e ) { <nl> - e . printStackTrace ( ) ; <nl> - } <nl> - String jarDir = null ; <nl> - if ( jarFile ! = null ) { <nl> - jarDir = jarFile . getParentFile ( ) . getPath ( ) ; <nl> - } <nl> - String fileName = jarDir + File . separator + " Saves " + File . separator + " DocksSave . txt " ; <nl> - try { <nl> - reader = new BufferedReader ( new FileReader ( fileName ) ) ; <nl> - } catch ( Exception ignored ) { / *Error checked inside of loadAccount with creating an account . * / } <nl> + public static void loadDocksTroops ( String directory ) { <nl> + BufferedReader reader = getBufferedReader ( directory , " DocksSave . txt " ) ; <nl> String line ; <nl>  <nl> try { <nl> if ( reader ! = null ) { <nl> while ( ( line = reader . readLine ( ) ) ! = null ) { <nl> String text [ ] = line . split ( " , " ) ; <nl> - ArrayList & lt ; Town & gt ; towns = Grepolis . GrepolisBot . getTowns ( ) ; <nl> + ArrayList & lt ; Town & gt ; towns ; <nl> + if ( directory . equals ( " Saves " ) ) { <nl> + towns = Grepolis . GrepolisBot . getTowns ( ) ; <nl> + } else { <nl> + towns = QueuePanel . getTemplateTowns ( ) ; <nl> + } <nl> Town town ; <nl> Docks docks = null ; <nl> - for ( String string : text ) { <nl> 
mmm a / library / src / main / java / org / dbtools / android / domain / RxAndroidBaseManagerWritable . java <nl> ppp b / library / src / main / java / org / dbtools / android / domain / RxAndroidBaseManagerWritable . java <nl> - } <nl> + DatabaseWrapper & lt ; ? super AndroidBaseRecord , ? super DBToolsContentValues & lt ; ? & gt ; & gt ; db = getWritableDatabase ( databaseName ) ; <nl> + <nl> + int rowsAffectedCount = 0 ; <nl> + <nl> + checkDB ( db ) ; <nl> + boolean success = false ; <nl> + for ( int tryCount = 0 ; tryCount & lt ; MAX_TRY_COUNT & & ! success ; tryCount++ ) { <nl> + try { <nl> + rowsAffectedCount = db . update ( getTableName ( ) , contentValues , where , whereArgs ) ; <nl> + success = true ; <nl> + } catch ( Exception ex ) { <nl> + ex . printStackTrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + if ( success & & rowsAffectedCount & gt ; 0 ) { <nl> + notifyTableListeners ( false , db , new DatabaseTableChange ( getTableName ( ) , false , true , false ) ) ; <nl> + } <nl>  <nl> - public int update ( @ Nonnull String databaseName , @ Nonnull DBToolsContentValues contentValues , @ Nullable String where , @ Nullable String [ ] whereArgs ) { <nl> - return update ( getWritableDatabase ( databaseName ) , contentValues , where , whereArgs ) ; <nl> + return rowsAffectedCount ; <nl> } <nl>  <nl> - public int update ( @ Nonnull DatabaseWrapper db , @ Nonnull DBToolsContentValues contentValues , @ Nullable String where , @ Nullable String [ ] whereArgs ) { <nl> + public int delete ( @ Nullable T e ) { <nl> 
mmm a / openam - federation / openam - federation - library / src / main / java / com / sun / identity / federation / services / termination / FSFedTerminationHandler . java <nl> ppp b / openam - federation / openam - federation - library / src / main / java / com / sun / identity / federation / services / termination / FSFedTerminationHandler . java <nl> - cookieDomainList ) ; <nl> + FSUtils . debug . message ( " Setting Age to " + <nl> + IFSConstants . PERSISTENT_COOKIE_AGE + " Age " ) ; <nl> } <nl> - Iterator iter = null ; <nl> - if ( cookieDomainList ! = null ) { <nl> - iter = cookieDomainList . iterator ( ) ; <nl> - while ( iter ! = null & & iter . hasNext ( ) ) { <nl> - fedCookie = CookieUtils . newCookie ( FEDERATE_COOKIE_NAME , <nl> - cookieValue , <nl> - IFSConstants . PERSISTENT_COOKIE_AGE , <nl> - " / " , ( String ) iter . next ( ) ) ; <nl> - CookieUtils . addCookieToResponse ( response , fedCookie ) ; <nl> - } <nl> - } else { <nl> - fedCookie = CookieUtils . newCookie ( FEDERATE_COOKIE_NAME , <nl> - cookieValue , <nl> - IFSConstants . PERSISTENT_COOKIE_AGE , <nl> - " / " , null ) ; <nl> - CookieUtils . addCookieToResponse ( response , fedCookie ) ; <nl> + Set & lt ; String & gt ; domains = SystemConfigurationUtil . getCookieDomainsForRequest ( request ) ; <nl> + if ( FSUtils . debug . messageEnabled ( ) ) { <nl> + FSUtils . debug . message ( " Provider cookie domain list is " + domains ) ; <nl> + } <nl> + for ( String domain : domains ) { <nl> + CookieUtils . addCookieToResponse ( response , CookieUtils . newCookie ( FEDERATE_COOKIE_NAME , cookieValue , <nl> + IFSConstants . PERSISTENT_COOKIE_AGE , " / " , domain ) ) ; <nl> } <nl> } <nl> } catch ( FSAccountMgmtException e ) { <nl> 
mmm a / hadoop - mini - clusters - hbase / src / test / java / com / github / sakserv / minicluster / impl / HbaseLocalClusterTest . java <nl> ppp b / hadoop - mini - clusters - hbase / src / test / java / com / github / sakserv / minicluster / impl / HbaseLocalClusterTest . java <nl> . setHbaseWalReplicationEnabled ( <nl> Boolean . parseBoolean ( propertyParser . getProperty ( ConfigVars . HBASE_WAL_REPLICATION_ENABLED_KEY ) ) ) <nl> . setHbaseConfiguration ( new Configuration ( ) ) <nl> + . activeRestGateway ( ) <nl> + . setHbaseRestHost ( propertyParser . getProperty ( ConfigVars . HBASE_REST_HOST_KEY ) ) <nl> + . setHbaseRestPort ( <nl> + Integer . valueOf ( propertyParser . getProperty ( ConfigVars . HBASE_REST_PORT_KEY ) ) ) <nl> + . setHbaseRestInfoPort ( <nl> + Integer . valueOf ( propertyParser . getProperty ( ConfigVars . HBASE_REST_INFO_PORT_KEY ) ) ) <nl> + . setHbaseRestReadOnly ( <nl> + Boolean . valueOf ( propertyParser . getProperty ( ConfigVars . HBASE_REST_READONLY_KEY ) ) ) <nl> + . setHbaseRestThreadMax ( <nl> + Integer . valueOf ( propertyParser . getProperty ( ConfigVars . HBASE_REST_THREADMAX_KEY ) ) ) <nl> + . setHbaseRestThreadMin ( <nl> + Integer . valueOf ( propertyParser . getProperty ( ConfigVars . HBASE_REST_THREADMIN_KEY ) ) ) <nl> + . build ( ) <nl> . build ( ) ; <nl> } <nl>  <nl> 
mmm a / carbon / src / main / java / carbon / widget / FrameLayout . java <nl> ppp b / carbon / src / main / java / carbon / widget / FrameLayout . java <nl> super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; <nl> if ( percentLayoutHelper . handleMeasuredStateTooSmall ( ) ) <nl> super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; <nl> - setMeasuredDimension ( Math . min ( getMeasuredWidth ( ) , maxWidth ) , Math . min ( getMeasuredHeight ( ) , maxHeight ) ) ; <nl> + if ( getMeasuredWidth ( ) & gt ; maxWidth || getMeasuredHeight ( ) & gt ; maxHeight ) { <nl> + if ( getMeasuredWidth ( ) & gt ; maxWidth ) <nl> + widthMeasureSpec = MeasureSpec . makeMeasureSpec ( maxWidth , MeasureSpec . EXACTLY ) ; <nl> + if ( getMeasuredHeight ( ) & gt ; maxHeight ) <nl> + heightMeasureSpec = MeasureSpec . makeMeasureSpec ( maxHeight , MeasureSpec . EXACTLY ) ; <nl> + super . onMeasure ( widthMeasureSpec , heightMeasureSpec ) ; <nl> + } <nl> } <nl> - } <nl> 
mmm a / src / main / java / org / warcbase / analysis / graph / ExtractSiteLinks . java <nl> ppp b / src / main / java / org / warcbase / analysis / graph / ExtractSiteLinks . java <nl> job . setNumReduceTasks ( reduceTasks ) ; /  / no reducers <nl>  <nl> if ( isHDFSInput ) { /  / HDFS input <nl> - FileInputFormat . setInputPaths ( job , new Path ( HDFSPath ) ) ; <nl> + Path path = new Path ( HDFSPath ) ; <nl> + RemoteIterator & lt ; LocatedFileStatus & gt ; itr = fs . listFiles ( path , true ) ; <nl> + LocatedFileStatus fileStatus ; <nl> + while ( itr . hasNext ( ) ) { <nl> + fileStatus = itr . next ( ) ; <nl> + Path p = fileStatus . getPath ( ) ; <nl> + if ( ( p . getName ( ) . endsWith ( " . warc . gz " ) ) || ( p . getName ( ) . endsWith ( " . warc " ) ) ) { <nl> + MultipleInputs . addInputPath ( job , p , WacWarcInputFormat . class , ExtractSiteLinksWarcMapper . class ) ; <nl> + } else { <nl> + MultipleInputs . addInputPath ( job , p , WacArcInputFormat . class , ExtractSiteLinksArcMapper . class ) ; <nl> + } <nl> + } <nl>  <nl> - job . setInputFormatClass ( WacArcInputFormat . class ) ; <nl> job . setMapOutputKeyClass ( IntWritable . class ) ; <nl> job . setMapOutputValueClass ( IntWritable . class ) ; <nl> - <nl> - job . setMapperClass ( ExtractSiteLinksMapper . class ) ; <nl> } else { /  / HBase input <nl> throw new UnsupportedOperationException ( " HBase not supported yet ! " ) ; <nl> } <nl> 
mmm a / src / main / java / com / builtbroken / militarybasedecor / core / MilitaryBaseDecor . java <nl> ppp b / src / main / java / com / builtbroken / militarybasedecor / core / MilitaryBaseDecor . java <nl> + super . preInit ( event ) ; <nl> + getManager ( ) . setTab ( MAIN_TAB ) ; <nl> ConfigManager . initConfig ( ) ; <nl> - <nl> - if ( ConfigManager . VANILLA_ENABLED ) <nl> - { <nl> - loader . applyModule ( new VanillaModule ( ) ) ; <nl> - } <nl> - <nl> - if ( ConfigManager . GUNPOWDER_ERA_ENABLED ) <nl> - { <nl> - loader . applyModule ( new GunpowderModule ( ) ) ; <nl> - } <nl> - <nl> - if ( ConfigManager . WORLD_WAR_ONE_ENABLED ) <nl> - { <nl> - loader . applyModule ( new WorldWar1Module ( ) ) ; <nl> - } <nl> - <nl> - if ( ConfigManager . WORLD_WAR_TWO_ENABLED ) <nl> - { <nl> - loader . applyModule ( new WorldWar2Module ( ) ) ; <nl> - } <nl> - <nl> - if ( ConfigManager . COLD_WAR_ENABLED ) <nl> - { <nl> - loader . applyModule ( new ColdWarModule ( ) ) ; <nl> - } <nl> - <nl> - if ( ConfigManager . FUTURE_ENABLED ) <nl> - { <nl> - loader . applyModule ( new FutureModule ( ) ) ; <nl> - } <nl> - if ( ConfigManager . BLASTCRAFT_ENABLED ) <nl> - { <nl> - loader . applyModule ( new Blastcraft ( ) ) ; <nl> - } <nl> + loader . applyModule ( VanillaModule . class , ConfigManager . VANILLA_ENABLED ) ; <nl> + loader . applyModule ( GunpowderModule . class , ConfigManager . GUNPOWDER_ERA_ENABLED ) ; <nl> + loader . applyModule ( WorldWar1Module . class , ConfigManager . WORLD_WAR_ONE_ENABLED ) ; <nl> + loader . applyModule ( WorldWar2Module . class , ConfigManager . WORLD_WAR_TWO_ENABLED ) ; <nl> + loader . applyModule ( ColdWarModule . class , ConfigManager . COLD_WAR_ENABLED ) ; <nl> + loader . applyModule ( Blastcraft . class , ConfigManager . BLASTCRAFT_ENABLED ) ; <nl> } <nl> + <nl> + @ Override <nl> 
mmm a / jme3 - terrain - editor / src / com / jme3 / gde / terraineditor / sky / SkyboxVisualPanel2 . java <nl> ppp b / jme3 - terrain - editor / src / com / jme3 / gde / terraineditor / sky / SkyboxVisualPanel2 . java <nl> Component view = editorBottom . getCustomEditor ( ) ; <nl> view . setVisible ( true ) ; <nl> - if ( editorBottom . getValue ( ) ! = null ) { <nl> - Texture tex = ( Texture ) editorBottom . getValue ( ) ; <nl> - String selected = tex . getKey ( ) . getName ( ) ; <nl> - <nl> - if ( selected . toLowerCase ( ) . endsWith ( " . dds " ) ) { <nl> - if ( ddsPreview == null ) { <nl> - ddsPreview = new DDSPreview ( ( ProjectAssetManager ) SceneApplication . getApplication ( ) . getAssetManager ( ) ) ; <nl> - } <nl> - ddsPreview . requestPreview ( selected , " " , 80 , 80 , bottomPic , null ) ; <nl> - <nl> - } else { <nl> - Icon newicon = ImageUtilities . image2Icon ( ImageToAwt . convert ( tex . getImage ( ) , false , true , 0 ) ) ; <nl> - bottomPic . setIcon ( newicon ) ; <nl> - } <nl> + if ( editorBottom . getAsText ( ) ! = null ) { <nl> + String selected = editorBottom . getAsText ( ) ; <nl> + getTexturePreview ( ) . requestPreview ( selected , " " , 80 , 80 , bottomPic , null ) ; <nl> } <nl> } /  / GEN - LAST : event_multipleTexBottomLoadButtonActionPerformed <nl> 
mmm a / http / src / test / java / ro / polak / http / ProtocolIT . java <nl> ppp b / http / src / test / java / ro / polak / http / ProtocolIT . java <nl> @ Test <nl> public void shouldReturn400BadRequestOnTooLongMethod ( ) throws IOException { <nl> - String requestBody = RequestBuilder . defaultBuilder ( ) <nl> + RequestBuilder requestBuilder = RequestBuilder . defaultBuilder ( ) <nl> . method ( " ABCABCABCABCABC " , " / " ) <nl> - . withCloseConnection ( ) <nl> - . toString ( ) ; <nl> + . withCloseConnection ( ) ; <nl>  <nl> - Socket socket = null ; <nl> - OutputStream out ; <nl> - socket = getSocket ( ) ; <nl> - out = socket . getOutputStream ( ) ; <nl> - out . write ( requestBody . getBytes ( ) ) ; <nl> - BufferedReader in = new BufferedReader ( new InputStreamReader ( socket . getInputStream ( ) ) ) ; <nl> - String line ; <nl> - int numberOfLinesRead = 0 ; <nl> - while ( ( line = in . readLine ( ) ) ! = null ) { <nl> - if ( ++numberOfLinesRead == 1 ) { <nl> - assertThat ( line , startsWith ( " HTTP / 1 . 1 400 " ) ) ; <nl> - break ; <nl> - } <nl> - } <nl> - <nl> - if ( numberOfLinesRead == 0 ) { <nl> - fail ( " No server response was read " ) ; <nl> - } <nl> - <nl> - socket . close ( ) ; <nl> + expectCode ( requestBuilder , 400 ) ; <nl> } <nl>  <nl> @ Test <nl> 
mmm a / src / main / java / net / hasor / rsf / center / server / manager / ServiceManager . java <nl> ppp b / src / main / java / net / hasor / rsf / center / server / manager / ServiceManager . java <nl> - public Result & lt ; Boolean & gt ; requestProviders ( InterAddress rsfAddress , String registerID , String serviceID ) { <nl> - Result & lt ; String & gt ; objectIDResult = this . checkAndEvalObjectID ( rsfAddress , registerID , serviceID ) ; <nl> - String oriObjectKey = null ; <nl> - if ( ! objectIDResult . isSuccess ( ) ) { <nl> + Result & lt ; ObjectDO & gt ; consumerResult = this . dataAdapter . queryObjectByID ( registerID ) ; <nl> + if ( consumerResult == null || ! consumerResult . isSuccess ( ) || consumerResult . getResult ( ) == null ) { <nl> + return buildFailedResult ( consumerResult ) ; <nl> + } <nl> + if ( ! StringUtils . equals ( RsfCenterConstants . Center_DataKey_Consumer , consumerResult . getResult ( ) . getType ( ) ) ) { <nl> ResultDO & lt ; Boolean & gt ; result = new ResultDO & lt ; Boolean & gt ; ( ) ; <nl> + result . setErrorInfo ( ErrorCode . ServiceTypeFailed_Error ) ; <nl> result . setSuccess ( false ) ; <nl> - result . setResult ( false ) ; <nl> - result . setErrorInfo ( objectIDResult . getErrorInfo ( ) ) ; <nl> return result ; <nl> - } else { <nl> - oriObjectKey = objectIDResult . getResult ( ) ; <nl> } <nl> 
mmm a / src / net / rithms / riot / api / LeagueApi . java <nl> ppp b / src / net / rithms / riot / api / LeagueApi . java <nl> + return dto ; <nl> } <nl>  <nl> public static Map & lt ; String , List & lt ; League & gt ; & gt ; getLeagueByTeams ( Region region , String key , String teamIds ) throws RiotApiException { <nl> - String url = region . getEndpoint ( ) + VERSION + " league / by - team / " + teamIds + " ? api_key= " + key ; <nl> - <nl> - Map & lt ; String , List & lt ; League & gt ; & gt ; leagues = null ; <nl> - try { <nl> - leagues = new Gson ( ) . fromJson ( Request . sendGet ( url ) , new TypeToken & lt ; Map & lt ; String , List & lt ; League & gt ; & gt ; & gt ; ( ) { <nl> - } . getType ( ) ) ; <nl> - } catch ( JsonSyntaxException e ) { <nl> - throw new RiotApiException ( RiotApiException . PARSE_FAILURE ) ; <nl> - } <nl> - if ( leagues == null ) { <nl> - throw new RiotApiException ( RiotApiException . PARSE_FAILURE ) ; <nl> - } <nl> - <nl> - return leagues ; <nl> + Request request = new Request ( ) ; <nl> + request . addToUrl ( region . getEndpoint ( ) , VERSION , " league / by - team / " , teamIds , " ? api_key= " , key ) ; <nl> + request . execute ( ) ; <nl> + Map & lt ; String , List & lt ; League & gt ; & gt ; dto = request . getDto ( new TypeToken & lt ; Map & lt ; String , List & lt ; League & gt ; & gt ; & gt ; ( ) { <nl> + } . getType ( ) ) ; <nl> + return dto ; <nl> + } <nl> 
mmm a / src / org / lwjgl / demo / vulkan / ClearScreenDemo . java <nl> ppp b / src / org / lwjgl / demo / vulkan / ClearScreenDemo . java <nl> } <nl>  <nl> private static VkImageMemoryBarrier . Buffer createPrePresentBarrier ( long presentImage ) { <nl> - VkImageMemoryBarrier . Buffer imageMemoryBarrier = VkImageMemoryBarrier . calloc ( 1 ) ; <nl> - imageMemoryBarrier . sType ( VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER ) ; <nl> - imageMemoryBarrier . pNext ( NULL ) ; <nl> - imageMemoryBarrier . srcAccessMask ( VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT ) ; <nl> - imageMemoryBarrier . dstAccessMask ( 0 ) ; <nl> - imageMemoryBarrier . oldLayout ( VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL ) ; <nl> - imageMemoryBarrier . newLayout ( VK_IMAGE_LAYOUT_PRESENT_SRC_KHR ) ; <nl> - imageMemoryBarrier . srcQueueFamilyIndex ( VK_QUEUE_FAMILY_IGNORED ) ; <nl> - imageMemoryBarrier . dstQueueFamilyIndex ( VK_QUEUE_FAMILY_IGNORED ) ; <nl> - VkImageSubresourceRange subresourceRange = imageMemoryBarrier . subresourceRange ( ) ; <nl> - subresourceRange . aspectMask ( VK_IMAGE_ASPECT_COLOR_BIT ) ; <nl> - subresourceRange . baseMipLevel ( 0 ) ; <nl> - subresourceRange . levelCount ( 1 ) ; <nl> - subresourceRange . baseArrayLayer ( 0 ) ; <nl> - subresourceRange . layerCount ( 1 ) ; <nl> + VkImageMemoryBarrier . Buffer imageMemoryBarrier = VkImageMemoryBarrier . calloc ( 1 ) <nl> + . sType ( VK_STRUCTURE_TYPE_IMAGE_MEMORY_BARRIER ) <nl> + . pNext ( NULL ) <nl> + . srcAccessMask ( VK_ACCESS_COLOR_ATTACHMENT_WRITE_BIT ) <nl> + . dstAccessMask ( 0 ) <nl> + . oldLayout ( VK_IMAGE_LAYOUT_COLOR_ATTACHMENT_OPTIMAL ) <nl> + . newLayout ( VK_IMAGE_LAYOUT_PRESENT_SRC_KHR ) <nl> + . srcQueueFamilyIndex ( VK_QUEUE_FAMILY_IGNORED ) <nl> + . dstQueueFamilyIndex ( VK_QUEUE_FAMILY_IGNORED ) ; <nl> + imageMemoryBarrier . subresourceRange ( ) <nl> + . aspectMask ( VK_IMAGE_ASPECT_COLOR_BIT ) <nl> + . baseMipLevel ( 0 ) <nl> + . levelCount ( 1 ) <nl> + . baseArrayLayer ( 0 ) <nl> + . layerCount ( 1 ) ; <nl> imageMemoryBarrier . image ( presentImage ) ; <nl> return imageMemoryBarrier ; <nl> } <nl> 
mmm a / jdt - patch / e43 / org . eclipse . jdt . core / compiler / org / eclipse / jdt / internal / compiler / ast / MemberValuePair . java <nl> ppp b / jdt - patch / e43 / org . eclipse . jdt . core / compiler / org / eclipse / jdt / internal / compiler / ast / MemberValuePair . java <nl> - private Expression repairClassLiteralReference ( Expression exp , BlockScope scope , TypeBinding [ ] valueType ) { <nl> - TypeBinding vtb = null ; <nl> + private static Expression repairClassLiteralReference ( Expression exp , BlockScope scope ) { <nl> if ( exp instanceof SingleNameReference ) { <nl> - vtb = exp . resolveType ( scope ) ; <nl> + if ( exp . resolveType ( scope ) ! = null ) { <nl> SingleNameReference ref = ( SingleNameReference ) exp ; <nl> - if ( vtb ! = null & & Arrays . equals ( ref . token , vtb . sourceName ( ) ) ) { <nl> return new ClassLiteralAccess ( ref . sourceEnd , new SingleTypeReference ( ref . token , ( ( long ) ref . sourceStart ) & lt ; & lt ; 32 | ref . sourceEnd ) ) ; <nl> } <nl> - } else if ( this . value instanceof QualifiedNameReference ) { <nl> - vtb = exp . resolveType ( scope ) ; <nl> + } else if ( exp instanceof QualifiedNameReference ) { <nl> + if ( exp . resolveType ( scope ) ! = null ) { <nl> QualifiedNameReference ref = ( QualifiedNameReference ) exp ; <nl> - if ( vtb ! = null & & Arrays . equals ( ref . tokens [ ref . tokens . length - 1 ] , vtb . sourceName ( ) ) ) { <nl> return new ClassLiteralAccess ( ref . sourceEnd , new QualifiedTypeReference ( ref . tokens , ref . sourcePositions ) ) ; <nl> } <nl> } <nl> - if ( valueType ! = null ) { <nl> + return exp ; <nl> 
mmm a / src / jwiki / core / CAction . java <nl> ppp b / src / jwiki / core / CAction . java <nl> + * @ param reason The edit summary . <nl> + * @ return True if we were successful . <nl> + * / <nl> private static boolean unstash ( Wiki wiki , String filekey , String title , String text , String reason ) <nl> { <nl> ColorLog . info ( wiki , String . format ( " Unstashing ' % s ' from temporary archive @ ' % s ' " , title , filekey ) ) ; <nl> - URLBuilder ub = wiki . makeUB ( " upload " ) ; <nl> - <nl> - String [ ] es = FString . massEnc ( title , text , reason , wiki . token , filekey ) ; <nl> - String posttext = URLBuilder . chainParams ( " filename " , es [ 0 ] , " text " , es [ 1 ] , " comment " , es [ 2 ] , " ignorewarnings " , " true " , <nl> - " filekey " , es [ 4 ] , " token " , es [ 3 ] ) ; <nl> - try <nl> - { <nl> - return CRequest . post ( ub . makeURL ( ) , posttext , wiki . cookiejar , CRequest . urlenc ) . resultIs ( " Success " ) ; <nl> - } <nl> - catch ( IOException e ) <nl> - { <nl> + Reply r = doAction ( wiki , wiki . makeUB ( " upload " ) , " filename " , title , " text " , text , " comment " , reason , " token " , <nl> + wiki . token , " filekey " , filekey , " ignorewarnings " , " true " ) ; <nl> + return r ! = null & & r . resultIs ( " Success " ) ; <nl> + } <nl> + } <nl> 
mmm a / src / java / org / jivesoftware / sparkimpl / plugin / systray / SysTrayPlugin . java <nl> ppp b / src / java / org / jivesoftware / sparkimpl / plugin / systray / SysTrayPlugin . java <nl> @ Override <nl> public void stopFlashing ( Window window ) { <nl> - trayIcon . setImage ( availableIcon . getImage ( ) ) ; <nl> + presence = Workspace . getInstance ( ) . getStatusBar ( ) . getPresence ( ) ; <nl> + if ( presence . getMode ( ) == Presence . Mode . available ) { <nl> + trayIcon . setImage ( availableIcon . getImage ( ) ) ; <nl> + } else if ( presence . getMode ( ) == Presence . Mode . away <nl> + || presence . getMode ( ) == Presence . Mode . xa ) { <nl> + trayIcon . setImage ( awayIcon . getImage ( ) ) ; <nl> + } else if ( presence . getMode ( ) == Presence . Mode . dnd ) { <nl> + trayIcon . setImage ( dndIcon . getImage ( ) ) ; <nl> + } else { <nl> + trayIcon . setImage ( availableIcon . getImage ( ) ) ; <nl> + } <nl> newMessage = false ; <nl> chatMessageHandler . clearUnreadMessages ( ) ; <nl> - } <nl> 
mmm a / src / main / java / edu / uncc / cs / bridges_vs1 / structure / ADTVisualizer . java <nl> ppp b / src / main / java / edu / uncc / cs / bridges_vs1 / structure / ADTVisualizer . java <nl> } <nl> } <nl>  <nl> - return " { " <nl> - + " \ " name \ " : \ " edu . uncc . cs . bridges \ " , " <nl> - + " \ " version \ " : \ " 0 . 4 . 0 \ " , " <nl> - + " \ " visual \ " : \ " " +visualizerType+ " \ " , " <nl> - + " \ " nodes \ " : [ " + DataFormatter . trimComma ( nodes ) + " ] , " <nl> - + " \ " links \ " : [ " + DataFormatter . trimComma ( links ) + " ] " <nl> - + " } " ; <nl> + StringBuilder s = new StringBuilder ( ) ; <nl> + <nl> + s . append ( " { " ) . <nl> + append ( " \ " name \ " : \ " edu . uncc . cs . bridges \ " , " ) . <nl> + append ( " \ " version \ " : \ " 0 . 4 . 0 \ " , " ) . <nl> + append ( " \ " visual \ " : \ " " +visualizerType+ " \ " , " ) . <nl> + append ( " \ " nodes \ " : [ " ) . append ( DataFormatter . trimComma ( nodes ) ) . append ( " ] , " ) . <nl> + append ( " \ " links \ " : [ " ) . append ( DataFormatter . trimComma ( links ) ) . append ( " ] " ) . <nl> + append ( " } " ) ; <nl> + if ( this . isVisualizeJSON ( ) ) <nl> + System . out . println ( s . toString ( ) ) ; <nl> + return s . toString ( ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / services / core / java / com / android / server / content / ContentService . java <nl> ppp b / services / core / java / com / android / server / content / ContentService . java <nl> final int pid = Binder . getCallingPid ( ) ; <nl> final int callingUserHandle = UserHandle . getCallingUserId ( ) ; <nl> - <nl> - userHandle = handleIncomingUser ( uri , pid , uid , <nl> - Intent . FLAG_GRANT_WRITE_URI_PERMISSION , userHandle ) ; <nl> - <nl> - final String msg = LocalServices . getService ( ActivityManagerInternal . class ) <nl> - . checkContentProviderAccess ( uri . getAuthority ( ) , userHandle ) ; <nl> - if ( msg ! = null ) { <nl> - Log . w ( TAG , " Ignoring notify for " + uri + " from " + uid + " : " + msg ) ; <nl> - return ; <nl> + if ( callingUserHandle ! = userHandle ) { <nl> + if ( checkUriPermission ( uri , pid , uid , Intent . FLAG_GRANT_WRITE_URI_PERMISSION , <nl> + userHandle ) ! = PackageManager . PERMISSION_GRANTED ) { <nl> + enforceCrossUserPermission ( userHandle , " no permission to notify other users " ) ; <nl> + } <nl> } <nl>  <nl> + if ( userHandle & lt ; 0 ) { <nl> + if ( userHandle == UserHandle . USER_CURRENT ) { <nl> + userHandle = ActivityManager . getCurrentUser ( ) ; <nl> + } else if ( userHandle ! = UserHandle . USER_ALL ) { <nl> + throw new InvalidParameterException ( " Bad user handle for notifyChange : " <nl> + + userHandle ) ; <nl> + } <nl> + } <nl> 
mmm a / src / main / java / org / literacyapp / web / content / multimedia / image / ImageCreateController . java <nl> ppp b / src / main / java / org / literacyapp / web / content / multimedia / image / ImageCreateController . java <nl> image . setTimeLastUpdate ( Calendar . getInstance ( ) ) ; <nl> imageDao . create ( image ) ; <nl>  <nl> - Contributor contributor = ( Contributor ) session . getAttribute ( " contributor " ) ; <nl> - <nl> - ContentCreationEvent contentCreationEvent = new ContentCreationEvent ( ) ; <nl> - contentCreationEvent . setContributor ( contributor ) ; <nl> - contentCreationEvent . setContent ( image ) ; <nl> - contentCreationEvent . setCalendar ( Calendar . getInstance ( ) ) ; <nl> - contentCreationEventDao . create ( contentCreationEvent ) ; <nl> - <nl> - if ( EnvironmentContextLoaderListener . env == Environment . PROD ) { <nl> - String text = URLEncoder . encode ( <nl> - contributor . getFirstName ( ) + " just added a new Image : \ n " + <nl> - " â¢ Language : " + image . getLocale ( ) . getLanguage ( ) + " \ n " + <nl> - " â¢ Title : \ " " + image . getTitle ( ) + " \ " \ n " + <nl> - " â¢ Image format : " + image . getImageFormat ( ) + " \ n " + <nl> - " See " ) + " http : /  / literacyapp . org / content / multimedia / image / list " ; <nl> - String iconUrl = contributor . getImageUrl ( ) ; <nl> - SlackApiHelper . postMessage ( Team . CONTENT_CREATION , text , iconUrl , " http : /  / literacyapp . org / image / " + image . getId ( ) + " . " + image . getImageFormat ( ) . toString ( ) . toLowerCase ( ) ) ; <nl> - } <nl> - <nl> return " redirect : / content / multimedia / image / list " ; <nl> 
mmm a / src / main / java / ldbc / snb / datagen / hadoop / HadoopMergeFriendshipFiles . java <nl> ppp b / src / main / java / ldbc / snb / datagen / hadoop / HadoopMergeFriendshipFiles . java <nl> + public void reduce ( TupleKey key , Iterable & lt ; Person & gt ; valueSet , Context context ) <nl> + throws IOException , InterruptedException { <nl> + <nl> + ArrayList & lt ; Knows & gt ; knows = new ArrayList & lt ; Knows & gt ; ( ) ; <nl> + Person person = null ; <nl> + int index = 0 ; <nl> + for ( Person p : valueSet ) { <nl> + if ( index == 0 ) { <nl> person = new Person ( p ) ; <nl> - } else { <nl> - for ( Knows k : p . knows ( ) ) { <nl> - person . knows ( ) . add ( k ) ; <nl> - } <nl> + } <nl> + for ( Knows k : p . knows ( ) ) { <nl> + knows . add ( k ) ; <nl> } <nl> index++ ; <nl> + } <nl> + person . knows ( ) . clear ( ) ; <nl> + Knows . FullComparator comparator = new Knows . FullComparator ( ) ; <nl> + Collections . sort ( knows , comparator ) ; <nl> + if ( knows . size ( ) & gt ; 0 ) { <nl> + long currentTo = knows . get ( 0 ) . to ( ) . accountId ( ) ; <nl> + person . knows ( ) . add ( knows . get ( 0 ) ) ; <nl> + for ( index = 1 ; index & lt ; knows . size ( ) ; ++index ) { <nl> + Knows nextKnows = knows . get ( index ) ; <nl> + if ( currentTo ! = knows . get ( index ) . to ( ) . accountId ( ) ) { <nl> + person . knows ( ) . add ( nextKnows ) ; <nl> + currentTo = nextKnows . to ( ) . accountId ( ) ; <nl> + } else { <nl> + numRepeated++ ; <nl> + } <nl> 
mmm a / src / example / org / deidentifier / arx / examples / Example49 . java <nl> ppp b / src / example / org / deidentifier / arx / examples / Example49 . java <nl> System . out . println ( " - Solution : " + Arrays . toString ( node . getTransformation ( ) ) ) ; <nl> System . out . println ( " * Optimal : " + result . getLattice ( ) . isComplete ( ) ) ; <nl> System . out . println ( " * Time needed : " + result . getTime ( ) + " [ ms ] " ) ; <nl> - System . out . println ( " * Minimal reduction in publisher benefit : " + result . getConfiguration ( ) . getQualityModel ( ) . createInstanceOfLowestScore ( ) ) ; <nl> - System . out . println ( " * Maximal reduction in publisher benefit : " + result . getConfiguration ( ) . getQualityModel ( ) . createInstanceOfHighestScore ( ) ) ; <nl> - System . out . println ( " * Reduction in publisher benefit : " + node . getLowestScore ( ) + " ( " + <nl> - node . getLowestScore ( ) . relativeTo ( result . getConfiguration ( ) . getQualityModel ( ) . createInstanceOfLowestScore ( ) , <nl> - result . getConfiguration ( ) . getQualityModel ( ) . createInstanceOfHighestScore ( ) ) * 100 + " % ) " ) ; <nl> + for ( QualityMetadata & lt ; ? & gt ; metadata : node . getLowestScore ( ) . getMetadata ( ) ) { <nl> + System . out . println ( " * " + metadata . getParameter ( ) + " : " + metadata . getValue ( ) ) ; <nl> + } <nl> System . out . println ( " * Suppressed records : " + handle . getStatistics ( ) . getEquivalenceClassStatistics ( ) . getNumberOfOutlyingTuples ( ) ) ; <nl>  <nl> - } <nl> 
mmm a / spark / src / main / java / edu / berkeley / cs / succinct / streams / SuccinctFileStream . java <nl> ppp b / spark / src / main / java / edu / berkeley / cs / succinct / streams / SuccinctFileStream . java <nl> - int m = buf . length ; <nl> - long c1 , c2 ; <nl> + int m = buf . length ; <nl> + long c1 , c2 ; <nl>  <nl> - if ( alphabetMap . containsKey ( buf [ m - 1 ] ) ) { <nl> - range . first = alphabetMap . get ( buf [ m - 1 ] ) . first ; <nl> - byte nextByte = alphabetMap . get ( buf [ m - 1 ] ) . second + 1 == getAlphabetSize ( ) ? <nl> - SuccinctCore . EOA : <nl> - alphabet [ alphabetMap . get ( buf [ m - 1 ] ) . second + 1 ] ; <nl> - range . second = alphabetMap . get ( nextByte ) . first - 1 ; <nl> - } else { <nl> - return new Range ( 0L , - 1L ) ; <nl> - } <nl> + int pos = findCharacter ( buf [ m - 1 ] ) ; <nl> + if ( pos & gt ; = 0 ) { <nl> + range . first = columnoffsets . get ( pos ) ; <nl> + range . second = <nl> + ( ( pos + 1 ) == getAlphabetSize ( ) ? getOriginalSize ( ) : columnoffsets . get ( pos + 1 ) ) - 1 ; <nl> + } else { <nl> + return new Range ( 0L , - 1L ) ; <nl> + } <nl> 
mmm a / jeta / src / main / java / org / brooth / jeta / metasitory / Criteria . java <nl> ppp b / jeta / src / main / java / org / brooth / jeta / metasitory / Criteria . java <nl> Criteria criteria = ( Criteria ) o ; <nl> - return Objects . equal ( masterEq , criteria . masterEq ) & & <nl> - Objects . equal ( masterEqDeep , criteria . masterEqDeep ) & & <nl> - Objects . equal ( usesAny , criteria . usesAny ) & & <nl> - Objects . equal ( usesAll , criteria . usesAll ) ; <nl> + <nl> + if ( masterEq ! = null ? ! masterEq . equals ( criteria . masterEq ) : criteria . masterEq ! = null ) <nl> + return false ; <nl> + if ( masterEqDeep ! = null ? ! masterEqDeep . equals ( criteria . masterEqDeep ) : criteria . masterEqDeep ! = null ) <nl> + return false ; <nl> + if ( usesAny ! = null ? ! usesAny . equals ( criteria . usesAny ) : criteria . usesAny ! = null ) <nl> + return false ; <nl> + return usesAll ! = null ? usesAll . equals ( criteria . usesAll ) : criteria . usesAll == null ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / nd4j - backends / nd4j - backend - impls / nd4j - cuda / src / main / java / org / nd4j / linalg / jcublas / ops / executioner / CudaExecutioner . java <nl> ppp b / nd4j - backends / nd4j - backend - impls / nd4j - cuda / src / main / java / org / nd4j / linalg / jcublas / ops / executioner / CudaExecutioner . java <nl> } <nl>  <nl> INDArray ret = null ; <nl> - if ( op . zeroDouble ( ) & gt ; - 0 . 01f & & op . zeroDouble ( ) & lt ; 0 . 01f ) { <nl> + if ( 0 . 0 + Math . abs ( op . zeroDouble ( ) ) & lt ; = Nd4j . EPS_THRESHOLD ) { <nl> ret = Nd4j . zeros ( retShape ) ; <nl> } else { <nl> - ret = Nd4j . valueArrayOf ( retShape , op . zeroDouble ( ) ) ; <nl> + if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . DOUBLE ) <nl> + ret = Nd4j . valueArrayOf ( retShape , op . zeroDouble ( ) ) ; <nl> + else if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . FLOAT ) <nl> + ret = Nd4j . valueArrayOf ( retShape , op . zeroFloat ( ) ) ; <nl> + else if ( op . x ( ) . data ( ) . dataType ( ) == DataBuffer . Type . HALF ) <nl> + ret = Nd4j . valueArrayOf ( retShape , op . zeroHalf ( ) ) ; <nl> + } <nl> + <nl> + op . setZ ( ret ) ; <nl> 
mmm a / src / main / java / ivorius / ivtoolkit / rendering / grid / CubeMesh . java <nl> ppp b / src / main / java / ivorius / ivtoolkit / rendering / grid / CubeMesh . java <nl> + renderer . pos ( x , y1 , z2 ) . tex ( icon . getMaxU ( ) , icon . getMinV ( ) ) . endVertex ( ) ; <nl> + } <nl> + <nl> public static void renderSouth ( double x1 , double y1 , double x2 , double y2 , double z , Icon icon ) <nl> { <nl> WorldRenderer renderer = Tessellator . getInstance ( ) . getWorldRenderer ( ) ; <nl> - renderer . addVertexWithUV ( x1 , y1 , z , icon . getMinU ( ) , icon . getMinV ( ) ) ; <nl> - renderer . addVertexWithUV ( x2 , y1 , z , icon . getMinU ( ) , icon . getMaxV ( ) ) ; <nl> - renderer . addVertexWithUV ( x2 , y2 , z , icon . getMaxU ( ) , icon . getMaxV ( ) ) ; <nl> - renderer . addVertexWithUV ( x1 , y2 , z , icon . getMaxU ( ) , icon . getMinV ( ) ) ; <nl> + renderer . pos ( x1 , y1 , z ) . tex ( icon . getMinU ( ) , icon . getMinV ( ) ) . endVertex ( ) ; <nl> + renderer . pos ( x2 , y1 , z ) . tex ( icon . getMinU ( ) , icon . getMaxV ( ) ) . endVertex ( ) ; <nl> + renderer . pos ( x2 , y2 , z ) . tex ( icon . getMaxU ( ) , icon . getMaxV ( ) ) . endVertex ( ) ; <nl> + renderer . pos ( x1 , y2 , z ) . tex ( icon . getMaxU ( ) , icon . getMinV ( ) ) . endVertex ( ) ; <nl> } <nl>  <nl> public static void renderWest ( double z1 , double y1 , double z2 , double y2 , double x , Icon icon ) <nl> 
mmm a / src / net / rithms / riot / api / StatsApi . java <nl> ppp b / src / net / rithms / riot / api / StatsApi . java <nl> private static final String VERSION = " / v1 . 3 / " ; <nl>  <nl> public static PlayerStatsSummaryList getPlayerStatsSummary ( Region region , Season season , String key , long summonerId ) throws RiotApiException { <nl> - String url = region . getEndpoint ( ) + VERSION + " stats / by - summoner / " + summonerId + " / summary ? api_key= " + key ; <nl> + Request request = new Request ( ) ; <nl> + request . addToUrl ( region . getEndpoint ( ) , VERSION , " stats / by - summoner / " , summonerId , " / summary ? api_key= " , key ) ; <nl> if ( season ! = null ) { <nl> - url += " & season= " + season ; <nl> + request . addToUrl ( " & season= " , season ) ; <nl> } <nl> - <nl> - PlayerStatsSummaryList summaryList = null ; <nl> - try { <nl> - summaryList = new Gson ( ) . fromJson ( Request . sendGet ( url ) , PlayerStatsSummaryList . class ) ; <nl> - } catch ( JsonSyntaxException e ) { <nl> - throw new RiotApiException ( RiotApiException . PARSE_FAILURE ) ; <nl> - } <nl> - if ( summaryList == null ) { <nl> - throw new RiotApiException ( RiotApiException . PARSE_FAILURE ) ; <nl> - } <nl> - <nl> - return summaryList ; <nl> + request . execute ( ) ; <nl> + PlayerStatsSummaryList dto = request . getDto ( PlayerStatsSummaryList . class ) ; <nl> + return dto ; <nl> + } <nl> 
mmm a / src / main / java / com / pantherman594 / gssentials / command / general / SlapCommand . java <nl> ppp b / src / main / java / com / pantherman594 / gssentials / command / general / SlapCommand . java <nl> @ Override <nl> public Iterable & lt ; String & gt ; onTabComplete ( CommandSender sender , String [ ] args ) { <nl> - if ( args . length & gt ; 1 || args . length == 0 ) { <nl> - return ImmutableSet . of ( ) ; <nl> - } <nl> - <nl> - Set & lt ; String & gt ; matches = new HashSet & lt ; & gt ; ( ) ; <nl> - String search = args [ 0 ] . toLowerCase ( ) ; <nl> - for ( ProxiedPlayer player : ProxyServer . getInstance ( ) . getPlayers ( ) ) { <nl> - if ( ! player . getName ( ) . equals ( sender . getName ( ) ) ) { <nl> - if ( player . getName ( ) . toLowerCase ( ) . startsWith ( search ) & & ! PlayerData . getData ( player . getUniqueId ( ) ) . isHidden ( ) ) { <nl> - matches . add ( player . getName ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - return matches ; <nl> + return args . length == 1 ? tabPlayers ( sender , args [ 0 ] ) : ImmutableSet . & lt ; String & gt ; of ( ) ; <nl> } <nl> } <nl> 
mmm a / source / net / malisis / doors / door / movement / SpinningAroundDoorMovement . java <nl> ppp b / source / net / malisis / doors / door / movement / SpinningAroundDoorMovement . java <nl> @ Override <nl> public AxisAlignedBB getBoundingBox ( DoorTileEntity tileEntity , boolean topBlock , BoundingBoxType type ) <nl> { <nl> - int dir = tileEntity . getDirection ( ) ; <nl> - boolean opened = tileEntity . isOpened ( ) ; <nl> - <nl> - if ( opened & & type ! = BoundingBoxType . RAYTRACE ) <nl> + if ( tileEntity . isOpened ( ) & & type ! = BoundingBoxType . RAYTRACE ) <nl> return null ; <nl>  <nl> - float x = 0 ; <nl> - float y = 0 ; <nl> - float z = 0 ; <nl> - float X = 1 ; <nl> - float Y = 1 ; <nl> - float Z = 1 ; <nl> - <nl> - if ( dir == DIR_NORTH ) <nl> - Z = DOOR_WIDTH ; <nl> - if ( dir == DIR_SOUTH ) <nl> - z = 1 - DOOR_WIDTH ; <nl> - if ( dir == DIR_WEST ) <nl> - X = DOOR_WIDTH ; <nl> - if ( dir == DIR_EAST ) <nl> - x = 1 - DOOR_WIDTH ; <nl> - <nl> + AxisAlignedBB aabb = AxisAlignedBB . getBoundingBox ( 0 , 0 , 0 , 1 , 1 , DOOR_WIDTH ) ; <nl> if ( type == BoundingBoxType . SELECTION ) <nl> { <nl> if ( ! topBlock ) <nl> - Y++ ; <nl> + aabb . maxY++ ; <nl> else <nl> - y -  - ; <nl> + aabb . minY -  - ; <nl> } <nl>  <nl> - return AxisAlignedBB . getBoundingBox ( x , y , z , X , Y , Z ) ; <nl> + return aabb ; <nl> } <nl>  <nl> @ Override <nl> 
mmm a / jwe / callout / src / main / java / com / apigee / callout / jwe / JweEncryptorCallout . java <nl> ppp b / jwe / callout / src / main / java / com / apigee / callout / jwe / JweEncryptorCallout . java <nl> private String resolvePropertyValue ( String spec , MessageContext msgCtxt ) { <nl> - if ( spec . startsWith ( " { " ) & & spec . endsWith ( " } " ) ) { <nl> - String varname = spec . substring ( 1 , spec . length ( ) - 1 ) ; <nl> - String value = msgCtxt . getVariable ( varname ) ; <nl> - return value ; <nl> + if ( spec . indexOf ( ' { ' ) & gt ; - 1 & & spec . indexOf ( ' } ' ) & gt ; - 1 ) { <nl> + TemplateString ts = new TemplateString ( spec ) ; <nl> + Map & lt ; String , String & gt ; valuesMap = new HashMap & lt ; String , String & gt ; ( ) ; <nl> + for ( String s : ts . variableNames ) { <nl> + valuesMap . put ( s , ( String ) msgCtxt . getVariable ( s ) ) ; <nl> + } <nl> + StrSubstitutor sub = new StrSubstitutor ( valuesMap ) ; <nl> + String resolvedString = sub . replace ( ts . template ) ; <nl> + return resolvedString ; <nl> } <nl> return spec ; <nl> } <nl> 
mmm a / library / src / test / java / org / chalup / microorm / tests / BasicTypesTest . java <nl> ppp b / library / src / test / java / org / chalup / microorm / tests / BasicTypesTest . java <nl> @ Test <nl> public void shouldUnpackBoxedIntFieldsFromCursor ( ) throws Exception { <nl> - Cursor c = mock ( Cursor . class ) ; <nl> - <nl> - when ( c . getColumnIndex ( BoxedIntegerDao . INTEGER_COLUMN ) ) . thenReturn ( 0 ) ; <nl> - when ( c . getColumnIndexOrThrow ( BoxedIntegerDao . INTEGER_COLUMN ) ) . thenReturn ( 0 ) ; <nl> - when ( c . isNull ( 0 ) ) . thenReturn ( Boolean . FALSE ) ; <nl> - when ( c . getInt ( 0 ) ) . thenReturn ( BoxedIntegerDao . TEST_INT ) ; <nl> - <nl> - when ( c . getColumnIndex ( BoxedIntegerDao . NULL_INTEGER_COLUMN ) ) . thenReturn ( 1 ) ; <nl> - when ( c . getColumnIndexOrThrow ( BoxedIntegerDao . NULL_INTEGER_COLUMN ) ) . thenReturn ( 1 ) ; <nl> - when ( c . isNull ( 1 ) ) . thenReturn ( Boolean . TRUE ) ; <nl> + Cursor c = TestCursorBuilder <nl> + . cursor ( BoxedIntegerDao . INTEGER_COLUMN , BoxedIntegerDao . NULL_INTEGER_COLUMN ) <nl> + . addRow ( BoxedIntegerDao . TEST_INT , null ) ; <nl>  <nl> BoxedIntegerDao boxedIntegerDao = testSubject . fromCursor ( c , BoxedIntegerDao . class ) ; <nl> assertThat ( boxedIntegerDao . mInt ) . isEqualTo ( BoxedIntegerDao . TEST_INT ) ; <nl> 
mmm a / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / messaging / coprocessor / hbase10cdh550 / MessageTableRegionObserver . java <nl> ppp b / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / messaging / coprocessor / hbase10cdh550 / MessageTableRegionObserver . java <nl> LOG . info ( " preCompact , filter using MessageDataFilter " ) ; <nl> TransactionVisibilityState txVisibilityState = txStateCache . getLatestState ( ) ; <nl>  <nl> - if ( pruneEnable == null ) { <nl> - CConfiguration cConf = topicMetadataCache . getCConfiguration ( ) ; <nl> - if ( cConf ! = null ) { <nl> - pruneEnable = cConf . getBoolean ( TxConstants . TransactionPruning . PRUNE_ENABLE , <nl> - TxConstants . TransactionPruning . DEFAULT_PRUNE_ENABLE ) ; <nl> - if ( Boolean . TRUE . equals ( pruneEnable ) ) { <nl> - String pruneTable = cConf . get ( TxConstants . TransactionPruning . PRUNE_STATE_TABLE , <nl> - TxConstants . TransactionPruning . DEFAULT_PRUNE_STATE_TABLE ) ; <nl> - long pruneFlushInterval = TimeUnit . SECONDS . toMillis ( <nl> - cConf . getLong ( TxConstants . TransactionPruning . PRUNE_FLUSH_INTERVAL , <nl> - TxConstants . TransactionPruning . DEFAULT_PRUNE_FLUSH_INTERVAL ) ) ; <nl> - compactionState = new CompactionState ( c . getEnvironment ( ) , TableName . valueOf ( pruneTable ) , pruneFlushInterval ) ; <nl> - LOG . debug ( " Automatic invalid list pruning is enabled . Compaction state will be recorded in table " + <nl> - pruneTable ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( Boolean . TRUE . equals ( pruneEnable ) ) { <nl> + reloadPruneState ( c . getEnvironment ( ) ) ; <nl> + if ( compactionState ! = null ) { <nl> compactionState . record ( request , txVisibilityState ) ; <nl> - } <nl> 
mmm a / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / client / perspectives / DroolsAuthoringPerspective . java <nl> ppp b / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / client / perspectives / DroolsAuthoringPerspective . java <nl> } <nl> } ) <nl> . endMenu ( ) <nl> - . newTopLevelMenu ( constants . explore ( ) ) <nl> - . menus ( ) <nl> - . menu ( constants . inboxIncomingChanges ( ) ) <nl> - . respondsWith ( new Command ( ) { <nl> - @ Override <nl> - public void execute ( ) { <nl> - placeManager . goTo ( " Inbox " ) ; <nl> - } <nl> - } ) <nl> - . endMenu ( ) <nl> - . menu ( constants . inboxRecentlyEdited ( ) ) <nl> - . respondsWith ( new Command ( ) { <nl> - @ Override <nl> - public void execute ( ) { <nl> - PlaceRequest p = new DefaultPlaceRequest ( " Inbox " ) ; <nl> - p . addParameter ( " inboxname " , InboxPresenter . RECENT_EDITED_ID ) ; <nl> - placeManager . goTo ( p ) ; <nl> - } <nl> - } ) <nl> - . endMenu ( ) <nl> - . menu ( constants . inboxRecentlyOpened ( ) ) <nl> - . respondsWith ( new Command ( ) { <nl> - @ Override <nl> - public void execute ( ) { <nl> - PlaceRequest p = new DefaultPlaceRequest ( " Inbox " ) ; <nl> - p . addParameter ( " inboxname " , InboxPresenter . RECENT_VIEWED_ID ) ; <nl> - placeManager . goTo ( p ) ; <nl> - } <nl> - } ) <nl> - . endMenu ( ) <nl> - . endMenus ( ) <nl> - . endMenu ( ) <nl> . newTopLevelMenu ( constants . newItem ( ) ) <nl> . withItems ( newResourcesMenu . getMenuItems ( ) ) <nl> . endMenu ( ) <nl> 
mmm a / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / queue / coprocessor / hbase10cdh550 / HBaseQueueRegionObserver . java <nl> ppp b / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / queue / coprocessor / hbase10cdh550 / HBaseQueueRegionObserver . java <nl> - } <nl> - <nl> LOG . info ( " preCompact , creates EvictionInternalScanner " ) ; <nl> - ConsumerConfigCache consumerConfigCache = getConfigCache ( e . getEnvironment ( ) ) ; <nl> TransactionVisibilityState txVisibilityState = txStateCache . getLatestState ( ) ; <nl>  <nl> - if ( pruneEnable == null ) { <nl> - CConfiguration cConf = consumerConfigCache . getCConf ( ) ; <nl> - if ( cConf ! = null ) { <nl> - pruneEnable = cConf . getBoolean ( TxConstants . TransactionPruning . PRUNE_ENABLE , <nl> - TxConstants . TransactionPruning . DEFAULT_PRUNE_ENABLE ) ; <nl> - if ( Boolean . TRUE . equals ( pruneEnable ) ) { <nl> - String pruneTable = cConf . get ( TxConstants . TransactionPruning . PRUNE_STATE_TABLE , <nl> - TxConstants . TransactionPruning . DEFAULT_PRUNE_STATE_TABLE ) ; <nl> - long pruneFlushInterval = TimeUnit . SECONDS . toMillis ( <nl> - cConf . getLong ( TxConstants . TransactionPruning . PRUNE_FLUSH_INTERVAL , <nl> - TxConstants . TransactionPruning . DEFAULT_PRUNE_FLUSH_INTERVAL ) ) ; <nl> - compactionState = new CompactionState ( e . getEnvironment ( ) , TableName . valueOf ( pruneTable ) , pruneFlushInterval ) ; <nl> - LOG . debug ( " Automatic invalid list pruning is enabled . Compaction state will be recorded in table " + <nl> - pruneTable ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( Boolean . TRUE . equals ( pruneEnable ) ) { <nl> + reloadPruneState ( e . getEnvironment ( ) ) ; <nl> + if ( compactionState ! = null ) { <nl> compactionState . record ( request , txVisibilityState ) ; <nl> - } <nl> 
mmm a / wsagent / che - core - api - project / src / main / java / org / eclipse / che / api / project / server / ProjectService . java <nl> ppp b / wsagent / che - core - api - project / src / main / java / org / eclipse / che / api / project / server / ProjectService . java <nl> + return projectServiceLinksInjector . injectFileLinks ( itemReference , getServiceContext ( ) ) ; <nl> } <nl>  <nl> private ItemReference injectFolderLinks ( ItemReference itemReference ) { <nl> - final UriBuilder uriBuilder = getServiceContext ( ) . getServiceUriBuilder ( ) ; <nl> - final List & lt ; Link & gt ; links = new ArrayList & lt ; & gt ; ( ) ; <nl> - final String relPath = itemReference . getPath ( ) . substring ( 1 ) ; <nl> - <nl> - links . add ( createLink ( GET , <nl> - uriBuilder . clone ( ) <nl> - . path ( ProjectService . class , " getChildren " ) <nl> - . build ( new String [ ] { relPath } , false ) <nl> - . toString ( ) , <nl> - APPLICATION_JSON , <nl> - LINK_REL_CHILDREN ) ) ; <nl> - links . add ( createLink ( GET , <nl> - uriBuilder . clone ( ) <nl> - . path ( ProjectService . class , " getTree " ) <nl> - . build ( new String [ ] { relPath } , false ) <nl> - . toString ( ) , <nl> - APPLICATION_JSON , <nl> - LINK_REL_TREE ) ) ; <nl> - links . add ( createLink ( DELETE , <nl> - uriBuilder . clone ( ) <nl> - . path ( ProjectService . class , " delete " ) <nl> - . build ( new String [ ] { relPath } , false ) <nl> - . toString ( ) , <nl> - LINK_REL_DELETE ) ) ; <nl> - <nl> - return itemReference . withLinks ( links ) ; <nl> + return projectServiceLinksInjector . injectFolderLinks ( itemReference , getServiceContext ( ) ) ; <nl> } <nl>  <nl> private ProjectConfigDto injectProjectLinks ( ProjectConfigDto projectConfig ) { <nl> 
mmm a / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / backend / server / AppSetup . java <nl> ppp b / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / backend / server / AppSetup . java <nl> } <nl>  <nl> - List & lt ; ConfigGroup & gt ; globalConfigGroups = configurationService . getConfiguration ( ConfigType . GLOBAL ) ; <nl> - boolean globalSettingsDefined = false ; <nl> - for ( ConfigGroup globalConfigGroup : globalConfigGroups ) { <nl> - if ( GLOBAL_SETTINGS . equals ( globalConfigGroup . getName ( ) ) ) { <nl> - globalSettingsDefined = true ; <nl> + final ConfigItem & lt ; String & gt ; supportRuntimeDeployConfigItem = new ConfigItem & lt ; & gt ; ( ) ; <nl> + supportRuntimeDeployConfigItem . setName ( " support . runtime . deploy " ) ; <nl> + supportRuntimeDeployConfigItem . setValue ( " false " ) ; <nl> + setupConfigurationGroup ( ConfigType . GLOBAL , <nl> + GLOBAL_SETTINGS , <nl> + getGlobalConfiguration ( ) , <nl> + supportRuntimeDeployConfigItem ) ; <nl>  <nl> - ConfigItem & lt ; String & gt ; runtimeDeployConfig = globalConfigGroup . getConfigItem ( " support . runtime . deploy " ) ; <nl> - if ( runtimeDeployConfig == null ) { <nl> - globalConfigGroup . addConfigItem ( configurationFactory . newConfigItem ( " support . runtime . deploy " , " false " ) ) ; <nl> - configurationService . updateConfiguration ( globalConfigGroup ) ; <nl> - } else if ( ! runtimeDeployConfig . getValue ( ) . equalsIgnoreCase ( " false " ) ) { <nl> - runtimeDeployConfig . setValue ( " false " ) ; <nl> - configurationService . updateConfiguration ( globalConfigGroup ) ; <nl> - } <nl> - break ; <nl> - } <nl> - } <nl> - if ( ! globalSettingsDefined ) { <nl> - configurationService . addConfiguration ( getGlobalConfiguration ( ) ) ; <nl> - } <nl> - <nl> + setupConfigurationGroup ( ConfigType . EDITOR , <nl> 
mmm a / src / main / java / org / sqlite / RS . java <nl> ppp b / src / main / java / org / sqlite / RS . java <nl> } <nl>  <nl> public Date getDate ( int col , Calendar cal ) throws SQLException { <nl> - if ( db . column_type ( stmt . pointer , markCol ( col ) ) == SQLITE_NULL ) <nl> + int data_type = db . column_type ( stmt . pointer , markCol ( col ) ) ; <nl> + if ( data_type == SQLITE_NULL ) <nl> return null ; <nl> if ( cal == null ) <nl> return getDate ( col ) ; <nl> - cal . setTimeInMillis ( db . column_long ( stmt . pointer , markCol ( col ) ) ) ; <nl> - return new Date ( cal . getTime ( ) . getTime ( ) ) ; <nl> + if ( data_type == SQLITE_INTEGER ) { <nl> + cal . setTimeInMillis ( db . column_long ( stmt . pointer , markCol ( col ) ) * DATE_INT_MULTIPLIER ) ; <nl> + return new Date ( cal . getTime ( ) . getTime ( ) ) ; <nl> + } <nl> + if ( data_type == SQLITE_TEXT ) { <nl> + try { <nl> + DateFormat df2 = ( DateFormat ) df . clone ( ) ; <nl> + df2 . setCalendar ( cal ) ; <nl> + return new java . sql . Date ( df2 . parse ( db . column_text ( stmt . pointer , markCol ( col ) ) ) . getTime ( ) ) ; <nl> + } catch ( Exception e ) { <nl> + return null ; <nl> + } <nl> + } <nl> + if ( data_type == SQLITE_FLOAT ) { <nl> + return new Date ( julianDateToCalendar ( db . column_double ( stmt . pointer , markCol ( col ) ) , cal ) . getTimeInMillis ( ) ) ; <nl> + } <nl> + return null ; <nl> } <nl> + <nl> + public Date getDate ( String col ) throws SQLException { <nl> 
mmm a / src / main / java / hellfirepvp / astralsorcery / client / gui / container / GuiAltarDiscovery . java <nl> ppp b / src / main / java / hellfirepvp / astralsorcery / client / gui / container / GuiAltarDiscovery . java <nl> Tuple & lt ; Double , Double & gt ; uvOffset = spriteStarlight . getUVOffset ( t ) ; <nl> drawRect ( guiLeft + 6 , guiTop + 69 , ( int ) ( 165 * percFilled ) , 10 , <nl> uvOffset . key , uvOffset . value , <nl> - spriteStarlight . getULength ( ) * percFilled , spriteStarlight . getVLength ( ) * percFilled ) ; <nl> - } <nl> + spriteStarlight . getULength ( ) * percFilled , spriteStarlight . getVLength ( ) ) ; <nl> + <nl> + AbstractAltarRecipe aar = findCraftableRecipe ( true ) ; <nl> + if ( aar ! = null ) { <nl> + int req = aar . getPassiveStarlightRequired ( ) ; <nl> + int has = containerAltarBase . tileAltar . getStarlightStored ( ) ; <nl> + if ( has & lt ; req ) { <nl> + int max = containerAltarBase . tileAltar . getMaxStarlightStorage ( ) ; <nl> + float percReq = ( float ) req / ( float ) max ; <nl> + int from = ( int ) ( 165 * percFilled ) ; <nl> + int to = ( int ) ( 165 * percReq ) ; <nl> + GL11 . glColor4f ( 0 . 2F , 0 . 5F , 1 . 0F , 0 . 4F ) ; <nl>  <nl> - GL11 . glColor4f ( 1 . 0F , 1 . 0F , 1 . 0F , 1 . 0F ) ; <nl> + drawRect ( guiLeft + 6 + from , guiTop + 69 , to , 10 , <nl> + uvOffset . key + spriteStarlight . getULength ( ) * percFilled , uvOffset . value , <nl> + spriteStarlight . getULength ( ) * percReq , spriteStarlight . getVLength ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / library - extensions / src / main / java / com / mikepenz / fastadapter_extensions / items / SingleLineItem . java <nl> ppp b / library - extensions / src / main / java / com / mikepenz / fastadapter_extensions / items / SingleLineItem . java <nl> public void bindView ( ViewHolder holder , List payloads ) { <nl> super . bindView ( holder , payloads ) ; <nl> mName . applyTo ( holder . name ) ; <nl> - if ( mAvatar ! = null ) { <nl> - if ( holder . avatar . getVisibility ( ) == View . GONE ) { <nl> - holder . avatar . setVisibility ( View . VISIBLE ) ; <nl> - } <nl> - mAvatar . applyTo ( holder . avatar ) ; <nl> - } else if ( holder . avatar . getVisibility ( ) == View . VISIBLE ) { <nl> - holder . avatar . setVisibility ( View . GONE ) ; <nl> - } <nl> - if ( mIcon ! = null ) { <nl> - if ( holder . icon . getVisibility ( ) == View . GONE ) { <nl> - holder . icon . setVisibility ( View . VISIBLE ) ; <nl> - } <nl> - mIcon . applyTo ( holder . icon ) ; <nl> - } else if ( holder . icon . getVisibility ( ) == View . VISIBLE ) { <nl> - holder . icon . setVisibility ( View . GONE ) ; <nl> - } <nl> + ImageHolder . applyToOrSetInvisible ( mAvatar , holder . avatar ) ; <nl> + ImageHolder . applyToOrSetInvisible ( mIcon , holder . icon ) ; <nl> } <nl> + <nl> + @ Override <nl> 
mmm a / bukkit / src / main / java / com / boydti / fawe / bukkit / v1_9 / BukkitQueue_1_9_R1 . java <nl> ppp b / bukkit / src / main / java / com / boydti / fawe / bukkit / v1_9 / BukkitQueue_1_9_R1 . java <nl> @ Override <nl> public void refreshChunk ( FaweChunk fc ) { <nl> BukkitChunk_1_9 fs = ( BukkitChunk_1_9 ) fc ; <nl> - ensureChunkLoaded ( fc . getX ( ) , fc . getZ ( ) ) ; <nl> - Chunk chunk = fs . getChunk ( ) ; <nl> - if ( ! chunk . isLoaded ( ) ) { <nl> - return ; <nl> - } <nl> - net . minecraft . server . v1_9_R2 . Chunk nmsChunk = ( ( CraftChunk ) chunk ) . getHandle ( ) ; <nl> - WorldServer w = ( WorldServer ) nmsChunk . getWorld ( ) ; <nl> - PlayerChunkMap chunkMap = w . getPlayerChunkMap ( ) ; <nl> - PlayerChunk playerChunk = chunkMap . getChunk ( nmsChunk . locX , nmsChunk . locZ ) ; <nl> - if ( playerChunk == null ) { <nl> - return ; <nl> - } <nl> - if ( playerChunk . c . isEmpty ( ) ) { <nl> + if ( ! isChunkLoaded ( fc . getX ( ) , fc . getZ ( ) ) ) { <nl> return ; <nl> } <nl> - int mask = fc . getBitMask ( ) ; <nl> - if ( mask == 0 || mask == 65535 & & hasEntities ( nmsChunk ) ) { <nl> - PacketPlayOutMapChunk packet = new PacketPlayOutMapChunk ( nmsChunk , 65280 ) ; <nl> - for ( EntityPlayer player : playerChunk . c ) { <nl> - player . playerConnection . sendPacket ( packet ) ; <nl> - } <nl> - mask = 255 ; <nl> - } <nl> - PacketPlayOutMapChunk packet = new PacketPlayOutMapChunk ( nmsChunk , mask ) ; <nl> - for ( EntityPlayer player : playerChunk . c ) { <nl> - player . playerConnection . sendPacket ( packet ) ; <nl> - } <nl> + Chunk chunk = fs . getChunk ( ) ; <nl> + sendChunk ( chunk , fs . getBitMask ( ) ) ; <nl> } <nl> + <nl> + public void sendChunk ( Chunk chunk , int mask ) { <nl> 
mmm a / carbon / src / main / java / carbon / widget / CheckBox . java <nl> ppp b / carbon / src / main / java / carbon / widget / CheckBox . java <nl> - } <nl> + * <nl> + * @ param d The Drawable to use as the button graphic <nl> + * / <nl> + public void setButtonDrawable ( CheckableDrawable d ) { <nl> + if ( drawable ! = d ) { <nl> + if ( drawable ! = null ) { <nl> + drawable . setCallback ( null ) ; <nl> + unscheduleDrawable ( drawable ) ; <nl> + } <nl>  <nl> - public void setRippleDrawable ( RippleDrawable newRipple ) { <nl> - if ( rippleDrawable ! = null ) { <nl> - rippleDrawable . setCallback ( null ) ; <nl> - if ( rippleDrawable . getStyle ( ) == RippleDrawable . Style . Background ) <nl> - super . setBackgroundDrawable ( rippleDrawable . getBackground ( ) ) ; <nl> - } <nl> + drawable = d ; <nl>  <nl> - if ( newRipple ! = null ) { <nl> - newRipple . setCallback ( this ) ; <nl> - newRipple . setBounds ( 0 , 0 , getWidth ( ) , getHeight ( ) ) ; <nl> - if ( newRipple . getStyle ( ) == RippleDrawable . Style . Background ) <nl> - super . setBackgroundDrawable ( ( Drawable ) newRipple ) ; <nl> + if ( d ! = null ) { <nl> + d . setCallback ( this ) ; <nl> + if ( d . isStateful ( ) ) { <nl> + d . setState ( getDrawableState ( ) ) ; <nl> + } <nl> + d . setVisible ( getVisibility ( ) == VISIBLE , false ) ; <nl> + setMinHeight ( d . getIntrinsicHeight ( ) ) ; <nl> + applyButtonTint ( ) ; <nl> + } <nl> } <nl> - <nl> - rippleDrawable = newRipple ; <nl> + } <nl> 
mmm a / client / src / main / java / net / luxvacuos / voxel / client / core / states / SPWorldState . java <nl> ppp b / client / src / main / java / net / luxvacuos / voxel / client / core / states / SPWorldState . java <nl> - c = BufferUtils . createFloatBuffer ( 3 ) ; <nl> - Window window = ClientInternalSubsystem . getInstance ( ) . getGameWindow ( ) ; <nl> + Matrix4d [ ] shadowProjectionMatrix = new Matrix4d [ 4 ] ; <nl>  <nl> - Matrix4d shadowProjectionMatrix = Maths . orthographic ( - ClientVariables . shadowMapDrawDistance , <nl> + shadowProjectionMatrix [ 0 ] = Maths . orthographic ( - ClientVariables . shadowMapDrawDistance / 32 , <nl> + ClientVariables . shadowMapDrawDistance / 32 , - ClientVariables . shadowMapDrawDistance / 32 , <nl> + ClientVariables . shadowMapDrawDistance / 32 , - ClientVariables . shadowMapDrawDistance , <nl> + ClientVariables . shadowMapDrawDistance , false ) ; <nl> + shadowProjectionMatrix [ 1 ] = Maths . orthographic ( - ClientVariables . shadowMapDrawDistance / 16 , <nl> + ClientVariables . shadowMapDrawDistance / 16 , - ClientVariables . shadowMapDrawDistance / 16 , <nl> + ClientVariables . shadowMapDrawDistance / 16 , - ClientVariables . shadowMapDrawDistance , <nl> + ClientVariables . shadowMapDrawDistance , false ) ; <nl> + shadowProjectionMatrix [ 2 ] = Maths . orthographic ( - ClientVariables . shadowMapDrawDistance / 4 , <nl> + ClientVariables . shadowMapDrawDistance / 4 , - ClientVariables . shadowMapDrawDistance / 4 , <nl> + ClientVariables . shadowMapDrawDistance / 4 , - ClientVariables . shadowMapDrawDistance , <nl> + ClientVariables . shadowMapDrawDistance , false ) ; <nl> + shadowProjectionMatrix [ 3 ] = Maths . orthographic ( - ClientVariables . shadowMapDrawDistance , <nl> ClientVariables . shadowMapDrawDistance , - ClientVariables . shadowMapDrawDistance , <nl> ClientVariables . shadowMapDrawDistance , - ClientVariables . shadowMapDrawDistance , <nl> ClientVariables . shadowMapDrawDistance , false ) ; <nl> 
mmm a / frontend - maven - plugin / src / main / java / com / github / eirslett / maven / plugins / frontend / mojo / GruntMojo . java <nl> ppp b / frontend - maven - plugin / src / main / java / com / github / eirslett / maven / plugins / frontend / mojo / GruntMojo . java <nl> } <nl>  <nl> private boolean shouldExecute ( ) { <nl> - if ( skip ) { <nl> - return false ; <nl> + if ( triggerfiles == null || triggerfiles . isEmpty ( ) ) { <nl> + triggerfiles = Arrays . asList ( new File ( workingDirectory , " Gruntfile . js " ) ) ; <nl> } <nl>  <nl> - if ( buildContext == null || ! buildContext . isIncremental ( ) ) { <nl> - return true ; <nl> - } <nl> - <nl> - if ( triggerfiles ! = null ) { <nl> - for ( int i = 0 ; i & lt ; triggerfiles . length ; i++ ) { <nl> - if ( buildContext . hasDelta ( triggerfiles [ i ] ) ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } else { <nl> - if ( buildContext . hasDelta ( new File ( workingDirectory , " Gruntfile . js " ) ) ) { <nl> - return true ; <nl> - } <nl> - } <nl> - <nl> - if ( srcdir == null ) { <nl> - getLog ( ) . info ( " grunt goal does n't have srcdir set : not checking for modified files " ) ; <nl> - return true ; <nl> - } <nl> - <nl> - Scanner scanner = buildContext . newScanner ( srcdir ) ; <nl> - scanner . scan ( ) ; <nl> - String [ ] includedFiles = scanner . getIncludedFiles ( ) ; <nl> - return ( includedFiles ! = null & & includedFiles . length & gt ; 0 ) ; <nl> + return MojoUtils . shouldExecute ( buildContext , triggerfiles , srcdir ) ; <nl> } <nl>  <nl> } <nl> 
