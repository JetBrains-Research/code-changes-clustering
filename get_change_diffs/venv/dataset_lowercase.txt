mmm a / src / spade / storage / sql . java <nl> ppp b / src / spade / storage / sql . java <nl> - try { <nl> dbconnection . commit ( ) ; <nl> - string query = " select dstvertexhash from edge where srcvertexhash = " + getvertexfromid ( vertexid ) . hashcode ( ) ; <nl> + string query = " select vertexid from vertex where hash in ( select dstvertexhash from edge where " + <nl> + " srcvertexhash = " + getvertexfromid ( vertexid ) . getannotation ( " hash " ) + " ) " ; <nl> statement statement = dbconnection . createstatement ( ) ; <nl> resultset result = statement . executequery ( query ) ; <nl> - while ( result . next ( ) ) { <nl> + while ( result . next ( ) ) <nl> 
mmm a / src / test / java / net / openhft / chronicle / queue / impl / single / singlechroniclequeuetest . java <nl> ppp b / src / test / java / net / openhft / chronicle / queue / impl / single / singlechroniclequeuetest . java <nl> + @ ignore ( " long running " ) <nl> public void testcountexceptsbetweencycles ( ) throws exception { <nl>  <nl> - final singlechroniclequeuebuilder builder = <nl> - binary ( gettmpdir ( ) ) <nl> - . testblocksize ( ) <nl> - . rollcycle ( rollcycles . test_secondly ) ; <nl> + final singlechroniclequeuebuilder builder = binary ( gettmpdir ( ) ) <nl> + . rollcycle ( rollcycles . test_secondly ) ; <nl> final rollingchroniclequeue queue = builder . build ( ) ; <nl> final excerptappender appender = queue . createappender ( ) ; <nl> 
mmm a / src / main / java / org / springframework / integration / kafka / inbound / kafkamessagedrivenchanneladapter . java <nl> ppp b / src / main / java / org / springframework / integration / kafka / inbound / kafkamessagedrivenchanneladapter . java <nl> - . withkeyvalue ( kafkaheaders . message_key , key ) <nl> - . withkeyvalue ( kafkaheaders . topic , metadata . getpartition ( ) . gettopic ( ) ) <nl> - . withkeyvalue ( kafkaheaders . partition_id , metadata . getpartition ( ) . getid ( ) ) <nl> - . withkeyvalue ( kafkaheaders . offset , metadata . getoffset ( ) ) <nl> - . withkeyvalue ( kafkaheaders . next_offset , metadata . getnextoffset ( ) ) ; <nl> + headers . put ( kafkaheaders . message_key , key ) ; <nl> + headers . put ( kafkaheaders . topic , metadata . getpartition ( ) . gettopic ( ) ) ; <nl> + headers . put ( kafkaheaders . partition_id , metadata . getpartition ( ) . getid ( ) ) ; <nl> + headers . put ( kafkaheaders . offset , metadata . getoffset ( ) ) ; <nl> + headers . put ( kafkaheaders . next_offset , metadata . getnextoffset ( ) ) ; <nl>  <nl> - if ( ! this . generatemessageid ) { <nl> 
mmm a / src / main / java / org / jooq / lambda / seq . java <nl> ppp b / src / main / java / org / jooq / lambda / seq . java <nl> * & lt ; / pre & gt ; & lt ; / code & gt ; <nl> * / <nl> - default seq & lt ; window & lt ; t , ? & gt ; & gt ; window ( comparator & lt ; ? super t & gt ; orderby , long lower , long upper ) { <nl> - return ( seq ) window ( t - & gt ; seqimpl . null , orderby , lower , upper ) ; <nl> + default seq & lt ; window & lt ; t & gt ; & gt ; window ( comparator & lt ; ? super t & gt ; orderby , long lower , long upper ) { <nl> + return window ( t - & gt ; seqimpl . null , orderby , lower , upper ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / src / test / java / com / elopteryx / paint / upload / uploadparsertest . java <nl> ppp b / src / test / java / com / elopteryx / paint / upload / uploadparsertest . java <nl> . onerror ( this ) <nl> . sizethreshold ( ( ) - & gt ; random . nextint ( 1024 * 1024 * 10 ) ) <nl> . maxpartsize ( ( ) - & gt ; random . nextint ( 1024 * 1024 * 50 ) ) <nl> - . maxrequestsize ( ( ) - & gt ; random . nextint ( 1024 * 1024 * 50 ) ) <nl> - . setup ( ) ; <nl> + . maxrequestsize ( ( ) - & gt ; random . nextint ( 1024 * 1024 * 50 ) ) ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / core / src / test / java / org / codice / imaging / nitf / core / nitf21headertest . java <nl> ppp b / core / src / test / java / org / codice / imaging / nitf / core / nitf21headertest . java <nl> final string testfile = " / jitcnitf21samples / ns3321a . nsf " ; <nl> assertnotnull ( " test file missing " , getclass ( ) . getresource ( testfile ) ) ; <nl>  <nl> - file resourcefile = new file ( getclass ( ) . getresource ( testfile ) . getfile ( ) ) ; <nl> + file resourcefile = new file ( getclass ( ) . getresource ( testfile ) . touri ( ) . getpath ( ) ) ; <nl> slottedparsestrategy parsestrategy = new slottedparsestrategy ( slottedparsestrategy . headers_only ) ; <nl> nitfreader reader = new filereader ( resourcefile ) ; <nl> nitfparser . parse ( reader , parsestrategy ) ; <nl> 
mmm a / testdata / generator / upperrules . expected . java <nl> ppp b / testdata / generator / upperrules . expected . java <nl> - static boolean file ( psibuilder builder_ , int level_ ) { <nl> - return root ( builder_ , level_ + 1 ) ; <nl> + if ( ! recursion_guard_ ( builder_ , level_ , " file " ) ) return false ; <nl> + boolean result_ ; <nl> + marker marker_ = enter_section_ ( builder_ ) ; <nl> + result_ = root ( builder_ , level_ + 1 ) ; <nl> + result_ = result_ & & file_1 ( builder_ , level_ + 1 ) ; <nl> + exit_section_ ( builder_ , marker_ , null , result_ ) ; <nl> + return result_ ; <nl> } <nl>  <nl> 
mmm a / src / test / java / net / imagej / ops / topology / eulercharacteristic / eulercharacteristic26ntest . java <nl> ppp b / src / test / java / net / imagej / ops / topology / eulercharacteristic / eulercharacteristic26ntest . java <nl> public void testedgecube ( ) throws exception { <nl> final img & lt ; bittype & gt ; img = drawcube ( 1 , 1 , 1 , 0 ) ; <nl>  <nl> - final double result = ops . topology ( ) . eulercharacteristic26n ( img ) ; <nl> + final double result = ops . topology ( ) . eulercharacteristic26n ( img ) . get ( ) ; <nl>  <nl> assertequals ( " euler characteristic ( ï ) is incorrect " , 0 . 0 , result , 1e - 12 ) ; <nl> } <nl> 
mmm a / app / src / main / java / de / maxr1998 / xposed / maxlock / ui / settingsactivity . java <nl> ppp b / app / src / main / java / de / maxr1998 / xposed / maxlock / ui / settingsactivity . java <nl> - if ( msettingsfragment == null ) { <nl> - msettingsfragment = maxlockpreferencefragment . screen . main . getscreen ( ) ; <nl> - fragmenttransaction ft = getsupportfragmentmanager ( ) . begintransaction ( ) ; <nl> - ft . setcustomanimations ( r . anim . fragment_in , r . anim . fragment_out ) ; <nl> - ft . replace ( r . id . fragment_container , msettingsfragment , tag_preference_fragment ) . commit ( ) ; <nl> + msettingsfragment = getintent ( ) . getaction ( ) . equals ( buildconfig . application_id + " . view_apps " ) ? <nl> + new applistfragment ( ) : maxlockpreferencefragment . screen . main . getscreen ( ) ; <nl> + getsupportfragmentmanager ( ) . begintransaction ( ) <nl> + . setcustomanimations ( r . anim . fragment_in , r . anim . fragment_out ) <nl> + . replace ( r . id . fragment_container , msettingsfragment , tag_preference_fragment ) <nl> + . commit ( ) ; <nl> if ( getsupportactionbar ( ) ! = null ) { <nl> getsupportactionbar ( ) . show ( ) ; <nl> 
mmm a / butterknife - compiler / src / main / java / butterknife / compiler / bindingclass . java <nl> ppp b / butterknife - compiler / src / main / java / butterknife / compiler / bindingclass . java <nl> - } else { <nl> - constructor . addstatement ( " super ( target , context ) " ) ; <nl> + } else { <nl> + constructor . addstatement ( " super ( target , context ) " ) ; <nl> + } <nl> + constructor . addcode ( " \ n " ) ; <nl> + } <nl> + if ( needstargetfield ( ) ) { <nl> + constructor . addstatement ( " this . target = target " ) ; <nl> + constructor . addcode ( " \ n " ) ; <nl> } <nl> - constructor . addcode ( " \ n " ) ; <nl>  <nl> if ( hasunqualifiedresourcebindings ( ) ) { <nl> 
mmm a / grobid - core / src / test / java / org / grobid / core / grobidmodelstest . java <nl> ppp b / grobid - core / src / test / java / org / grobid / core / grobidmodelstest . java <nl> - assertthat ( model . getfoldername ( ) , is ( " dictionaries - senses " ) ) ; <nl> assertthat ( model . getmodelname ( ) , is ( " dictionaries - senses " ) ) ; <nl> assertthat ( model . gettemplatename ( ) , is ( " dictionaries - senses . template " ) ) ; <nl> - assertthat ( model . getmodelpath ( ) , endswith ( " / grobid / grobid - home / models / dictionaries - senses / model . wapiti " ) ) ; <nl>  <nl> - grobidmodel model2 = grobidmodels . modelfor ( " dictionaries - lemma " ) ; <nl> - assertfalse ( model2 . equals ( model ) ) ; <nl> + string [ ] splittedpath = model . getmodelpath ( ) . split ( " [ /  \  \  \  \ ] " ) ; <nl> + assertthat ( splittedpath [ splittedpath . length - 1 ] , is ( " model . wapiti " ) ) ; <nl> + assertthat ( splittedpath [ splittedpath . length - 2 ] , is ( " dictionaries - senses " ) ) ; <nl> + assertthat ( splittedpath [ splittedpath . length - 3 ] , is ( " models " ) ) ; <nl> 
mmm a / src / main / java / org / jdc / template / model / database / main / individual / individualbaserecord . java <nl> ppp b / src / main / java / org / jdc / template / model / database / main / individual / individualbaserecord . java <nl> - statement . bindstring ( 11 , email ) ; <nl> - statement . bindlong ( 12 , available ? 1 : 0 ) ; <nl> - statement . binddouble ( 13 , amount1 ) ; <nl> - statement . binddouble ( 14 , amount2 ) ; <nl> - statement . bindlong ( 15 , enabled ? 1 : 0 ) ; <nl> + statement . bindstring ( 11 , phone ) ; <nl> + statement . bindstring ( 12 , email ) ; <nl> + statement . bindlong ( 13 , available ? 1 : 0 ) ; <nl> + statement . binddouble ( 14 , amount1 ) ; <nl> + statement . binddouble ( 15 , amount2 ) ; <nl> + statement . bindlong ( 16 , enabled ? 1 : 0 ) ; <nl> if ( spouseindividualid ! = null ) { <nl> - statement . bindlong ( 16 , spouseindividualid ) ; <nl> 
mmm a / guava / src / com / google / common / collect / abstractrangeset . java <nl> ppp b / guava / src / com / google / common / collect / abstractrangeset . java <nl> @ override <nl> public void removeall ( rangeset & lt ; c & gt ; other ) { <nl> - for ( range & lt ; c & gt ; range : other . asranges ( ) ) { <nl> - remove ( range ) ; <nl> - } <nl> + removeall ( other . asranges ( ) ) ; <nl> } <nl> + <nl> + @ override <nl> 
mmm a / assignments / assignment2 / app / src / androidtest / java / edu / vandy / view / palantiriactivitytest . java <nl> ppp b / assignments / assignment2 / app / src / androidtest / java / edu / vandy / view / palantiriactivitytest . java <nl> - startbutton . perform ( click ( ) ) ; <nl> + p . second . tostring ( ) ) ) ) ) ; <nl>  <nl> - setorientationlandscape ( 2000 ) ; <nl> + setorientationlandscape ( config_timeout ) ; <nl>  <nl> - systemclock . sleep ( 4000 ) ; <nl> + pairs . stream ( ) . foreach ( <nl> 
mmm a / ij / io / fileopener . java <nl> ppp b / ij / io / fileopener . java <nl> - if ( fi . url ! =null & & ! fi . url . equals ( " " ) & & ( fi . directory==null||fi . directory . equals ( " " ) ) ) <nl> - path = fi . url ; <nl> ij . showstatus ( " loading : " + path ) ; <nl> - imageplus imp2 = ij . openimage ( path ) ; <nl> + imageplus imp2 = null ; <nl> + if ( ! path . endswith ( " . raw " ) ) <nl> + imp2 = ij . openimage ( path ) ; <nl> if ( imp2 ! =null ) <nl> imp . setimage ( imp2 ) ; <nl> - } <nl> + else { <nl> 
mmm a / src / main / java / io / hgraphdb / hbasegraphutils . java <nl> ppp b / src / main / java / io / hgraphdb / hbasegraphutils . java <nl> - . settimetolive ( ttl ) ; <nl> tabledescriptor . addfamily ( columndescriptor ) ; <nl> int regioncount = config . getregioncount ( ) ; <nl> - admin . createtable ( tabledescriptor , getstartkey ( regioncount ) , getendkey ( regioncount ) , regioncount ) ; <nl> + if ( regioncount & lt ; = 1 ) { <nl> + admin . createtable ( tabledescriptor ) ; <nl> + } else { <nl> + admin . createtable ( tabledescriptor , getstartkey ( regioncount ) , getendkey ( regioncount ) , regioncount ) ; <nl> + } <nl> } <nl> - <nl> - public static void droptables ( hbasegraphconfiguration config , connection conn ) { <nl> 
mmm a / spring - test / src / test / java / org / springframework / test / web / reactive / server / samples / responseentitytests . java <nl> ppp b / spring - test / src / test / java / org / springframework / test / web / reactive / server / samples / responseentitytests . java <nl> + this . client . get ( ) . uri ( " / persons " ) <nl> . exchange ( ) <nl> - . decodeandcollect ( person . class ) <nl> - . assertthat ( ) <nl> - . status ( ) . isok ( ) <nl> - . header ( ) . contenttypeequals ( mediatype . application_json_utf8 ) <nl> - . bodyequals ( arrays . aslist ( new person ( " jane " ) , new person ( " jason " ) , new person ( " john " ) ) ) ; <nl> + . expectstatus ( ) . isok ( ) <nl> + . expectheader ( ) . contenttypeequals ( mediatype . application_json_utf8 ) <nl> + . expectbody ( person . class ) . list ( ) . isequalto ( expected ) ; <nl> } <nl> 
mmm a / android / luaviewsdk / src / com / taobao / luaview / fun / mapper / ui / uitextviewmethodmapper . java <nl> ppp b / android / luaviewsdk / src / com / taobao / luaview / fun / mapper / ui / uitextviewmethodmapper . java <nl> } <nl>  <nl> public luavalue gettextcolor ( u view , varargs varargs ) { <nl> - return valueof ( view . gettextcolor ( ) ) ; <nl> + return valueof ( colorutil . gethexcolor ( view . gettextcolor ( ) ) ) ; <nl> } <nl> 
mmm a / test / integration - tests / src / test / java / org / springframework / ldap / itest / ldaptemplatemodifyitest . java <nl> ppp b / test / integration - tests / src / test / java / org / springframework / ldap / itest / ldaptemplatemodifyitest . java <nl> tested . modifyattributes ( person4_dn , mods ) ; <nl>  <nl> dircontextadapter result = ( dircontextadapter ) tested . lookup ( person4_dn ) ; <nl> - string [ ] attributes = result . getstringattributes ( " description " ) ; <nl> - assertequals ( 2 , attributes . length ) ; <nl> - assertequals ( " some other description " , attributes [ 0 ] ) ; <nl> - assertequals ( " another description " , attributes [ 1 ] ) ; <nl> + list & lt ; string & gt ; attributes = arrays . aslist ( result . getstringattributes ( " description " ) ) ; <nl> + assertequals ( 2 , attributes . size ( ) ) ; <nl> + asserttrue ( attributes . contains ( " some other description " ) ) ; <nl> + asserttrue ( attributes . contains ( " another description " ) ) ; <nl> 
mmm a / src / org / rascalmpl / library / experiments / compiler / rvm / interpreter / rvmonjvm . java <nl> ppp b / src / org / rascalmpl / library / experiments / compiler / rvm / interpreter / rvmonjvm . java <nl> - @ override <nl> public ivalue executervmfunctioninvisit ( frame root ) { <nl> root . sp = root . function . getnlocals ( ) ; /  / todo : should be done at frame creation . <nl> - dynrun ( root . function . funid , root ) ; <nl> - <nl> - if ( returnvalue instanceof thrown ) { <nl> - frameobserver . exception ( root , ( thrown ) returnvalue ) ; <nl> + try { <nl> + root . function . handle . invoke ( this , root ) ; <nl> + } catch ( throwable e ) { <nl> + if ( e instanceof thrown ) { <nl> + throw ( thrown ) e ; <nl> 
mmm a / src / main / java / com / jetbrains / jetpad / vclang / core / expr / visitor / findbindingvisitor . java <nl> ppp b / src / main / java / com / jetbrains / jetpad / vclang / core / expr / visitor / findbindingvisitor . java <nl> @ override <nl> - public boolean visitlam ( lamexpression expr , void params ) { <nl> - return visitdependentlink ( expr . getparameters ( ) ) || expr . getbody ( ) . accept ( this , null ) ; <nl> + public referable visitlam ( lamexpression expr , void params ) { <nl> + referable result = visitdependentlink ( expr . getparameters ( ) ) ; <nl> + return result ! = null ? result : expr . getbody ( ) . accept ( this , null ) ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / catalog / spatial / registry / registry - schema - bindings / src / test / java / org / codice / ddf / registry / schemabindings / helper / internationalstringtypehelpertest . java <nl> ppp b / catalog / spatial / registry / registry - schema - bindings / src / test / java / org / codice / ddf / registry / schemabindings / helper / internationalstringtypehelpertest . java <nl> - @ test <nl> public void testgetstringwithnomatchinglocale ( ) throws exception { <nl> internationalstringtype ist = gettestinternationalstringtype ( ) ; <nl> - isthelper . setlocale ( locale . china ) ; <nl> + if ( locale . getdefault ( ) == locale . china ) { <nl> + isthelper . setlocale ( locale . korea ) ; <nl> + } else { <nl> + isthelper . setlocale ( locale . china ) ; <nl> + } <nl>  <nl> string iststring = isthelper . getstring ( ist ) ; <nl> - assertthat ( iststring , is ( equalto ( empty_string ) ) ) ; <nl> 
mmm a / src / main / java / redis / clients / jedis / jedis . java <nl> ppp b / src / main / java / redis / clients / jedis / jedis . java <nl> public set & lt ; tuple & gt ; zrevrangebyscorewithscores ( final string key , final double max , final double min ) { <nl> checkisinmulti ( ) ; <nl> client . zrevrangebyscorewithscores ( key , max , min ) ; <nl> - set & lt ; tuple & gt ; set = gettupledset ( ) ; <nl> - return set ; <nl> + return gettupledset ( ) ; <nl> } <nl>  <nl> public set & lt ; tuple & gt ; zrevrangebyscorewithscores ( final string key , final double max , <nl> 
mmm a / src / main / java / org / jboss / logmanager / handlers / ssltcpoutputstream . java <nl> ppp b / src / main / java / org / jboss / logmanager / handlers / ssltcpoutputstream . java <nl> - public class ssltcpoutputstream extends tcpoutputstream implements flushablecloseable { <nl> - <nl> + * @ throws ioexception if an i / o error occurs when creating the socket <nl> + * / <nl> public ssltcpoutputstream ( final inetaddress address , final int port ) throws ioexception { <nl> - super ( sslsocketfactory . getdefault ( ) . createsocket ( address , port ) ) ; <nl> + super ( sslsocketfactory . getdefault ( ) , address , port ) ; <nl> } <nl> - } <nl> + <nl> + / ** <nl> + * creates a ssl tcp output stream . <nl> 
mmm a / server / src / nl / tue / id / oocsi / server / model / channel . java <nl> ppp b / server / src / nl / tue / id / oocsi / server / model / channel . java <nl> public void addchannel ( channel channel ) { <nl> if ( ! token . equals ( channel . getname ( ) ) & & ! subchannels . containskey ( channel . getname ( ) ) ) { <nl> subchannels . put ( channel . getname ( ) , channel ) ; <nl> - oocsiserver . logconnection ( token , channel . getname ( ) , " added channel " , new date ( ) ) ; <nl> + if ( ! isprivate ( ) ) { <nl> + oocsiserver . logconnection ( token , channel . getname ( ) , " added channel " , new date ( ) ) ; <nl> + } <nl> } <nl> } <nl> 
mmm a / pippo - core / src / main / java / ro / pippo / core / route / defaultrouter . java <nl> ppp b / pippo - core / src / main / java / ro / pippo / core / route / defaultrouter . java <nl> - public list & lt ; route & gt ; getroutes ( string requestmethod ) { <nl> - list & lt ; route & gt ; routes = cache . get ( requestmethod ) ; <nl> - if ( routes ! = null ) { <nl> - routes = collections . unmodifiablelist ( routes ) ; <nl> - } else { <nl> - routes = collections . emptylist ( ) ; <nl> - } <nl> + allroutes . addall ( getcompiledroutes ( requestmethod ) ) ; <nl>  <nl> - return routes ; <nl> + return collections . unmodifiablelist ( allroutes ) ; <nl> } <nl>  <nl> - protected void validateroute ( route route ) { <nl> + @ override <nl> 
mmm a / aem - mock / src / main / java / io / wcm / testing / mock / aem / mockpage . java <nl> ppp b / aem - mock / src / main / java / io / wcm / testing / mock / aem / mockpage . java <nl> if ( type == resource . class ) { <nl> return ( adaptertype ) this . resource ; <nl> } <nl> - return super . adaptto ( type ) ; <nl> - } <nl> + adaptertype result = super . adaptto ( type ) ; <nl> + if ( result == null ) { <nl> + result = this . resource . adaptto ( type ) ; <nl> + } <nl> + return result ; <nl> 
mmm a / co . codewizards . cloudstore . core / src / main / java / co / codewizards / cloudstore / core / config / configimpl . java <nl> ppp b / co . codewizards . cloudstore . core / src / main / java / co / codewizards / cloudstore / core / config / configimpl . java <nl> - if ( isdirectory ) { <nl> - return new file [ ] { <nl> - createfile ( file , properties_file_name_for_directory_hidden ) , <nl> - createfile ( file , properties_file_name_for_directory_visible ) , <nl> - createfile ( file , properties_file_name_for_directory_local ) /  / overrides the settings of the shared file ! <nl> - } ; <nl> + files . add ( createfile ( metadir , properties_file_name_parent ) ) ; <nl> + <nl> + files . add ( createfile ( file , properties_file_name_for_directory ) ) ; <nl> + files . add ( createfile ( file , properties_file_name_for_directory_visible ) ) ; <nl> + files . add ( createfile ( file , properties_file_name_for_directory_local ) ) ; /  / overrides the settings of the shared file ! <nl> + return files . toarray ( new file [ files . size ( ) ] ) ; <nl> } <nl> 
mmm a / src / main / java / ru / yandex / qatools / allure / cucumberjvm / allurerunlistener . java <nl> ppp b / src / main / java / ru / yandex / qatools / allure / cucumberjvm / allurerunlistener . java <nl> - if ( description . istest ( ) ) { <nl> - string methodname = extractmethodname ( description ) ; <nl> testcasestartedevent event = new testcasestartedevent ( getsuiteuid ( description ) , methodname ) ; <nl> - annotationmanager am = new annotationmanager ( description . getannotations ( ) ) ; <nl> - am . update ( event ) ; <nl> - getlifecycle ( ) . fire ( event ) ; <nl> - } <nl> + <nl> + collection & lt ; annotation & gt ; annotations = new arraylist & lt ; & gt ; ( ) ; <nl> + for ( annotation annotation : description . getannotations ( ) ) { <nl> + annotations . add ( annotation ) ; <nl> + } <nl> + <nl> + title title = gettitleannotation ( description . getdisplayname ( ) ) ; <nl> 
mmm a / src / org / yaxim / androidclient / service / genericservice . java <nl> ppp b / src / org / yaxim / androidclient / service / genericservice . java <nl> mnotification = new notificationcompat . builder ( this ) <nl> . setcontenttitle ( title ) <nl> . setcontenttext ( message ) <nl> + . setstyle ( new notificationcompat . bigtextstyle ( ) . bigtext ( message ) ) <nl> . setticker ( ticker ) <nl> . setsmallicon ( r . drawable . sb_message ) <nl> . setcategory ( notification . category_message ) <nl> 
mmm a / src / main / java / org / icij / extract / tasks / tagtask . java <nl> ppp b / src / main / java / org / icij / extract / tasks / tagtask . java <nl> logger . info ( string . format ( " processed a total of % d documents . " , processed ) ) ; <nl> logger . info ( string . format ( " tagged % d documents . " , consumer . getconsumecount ( ) ) ) ; <nl>  <nl> - if ( options . get ( " soft - commit " ) . on ( ) ) { <nl> + if ( options . get ( " soft - commit " ) . parse ( ) . ison ( ) ) { <nl> client . commit ( true , true , true ) ; <nl> - } else if ( options . get ( " commit " ) . on ( ) ) { <nl> + } else if ( options . get ( " commit " ) . parse ( ) . ison ( ) ) { <nl> client . commit ( true , true , false ) ; <nl> } <nl> 
mmm a / library / src / main / java / com / google / android / media / tv / companionlibrary / service / basetvinputservice . java <nl> ppp b / library / src / main / java / com / google / android / media / tv / companionlibrary / service / basetvinputservice . java <nl> + contentresolver resolver = mcontext . getcontentresolver ( ) ; <nl> program program = tvcontractutils . getcurrentprogram ( resolver , mchanneluri ) ; <nl> if ( program ! = null ) { <nl> - list & lt ; advertisement & gt ; ads = internalproviderdatautil <nl> - . parseads ( program . getinternalproviderdata ( ) ) ; <nl> - collections . sort ( ads ) ; <nl> - long currenttimems = system . currenttimemillis ( ) ; <nl> - for ( advertisement ad : ads ) { <nl> + if ( program . getinternalproviderdata ( ) ! = null ) { <nl> + list & lt ; advertisement & gt ; ads = program . getinternalproviderdata ( ) . getads ( ) ; <nl> + collections . sort ( ads ) ; <nl> + long currenttimems = system . currenttimemillis ( ) ; <nl> + for ( advertisement ad : ads ) { <nl> 
mmm a / src / main / java / fr / pilato / elasticsearch / crawler / fs / client / elasticsearchclient . java <nl> ppp b / src / main / java / fr / pilato / elasticsearch / crawler / fs / client / elasticsearchclient . java <nl> - logger . trace ( " { } " , sbf ) ; <nl> + map & lt ; string , string & gt ; params ; <nl> + <nl> + if ( pipeline ! = null ) { <nl> + params = new hashmap & lt ; & gt ; ( 1 ) ; <nl> + params . put ( " pipeline " , pipeline ) ; <nl> + } else { <nl> + params = collections . emptymap ( ) ; <nl> + } <nl>  <nl> stringentity entity = new stringentity ( sbf . tostring ( ) , charset . defaultcharset ( ) ) ; <nl> - response restresponse = client . performrequest ( " post " , " / _bulk " , collections . emptymap ( ) , entity ) ; <nl> - bulkresponse response = jsonutil . deserialize ( restresponse , bulkresponse . class ) ; <nl> - logger . debug ( " bulk response : { } " , response ) ; <nl> - return response ; <nl> 
mmm a / app / src / main / java / com / kyletung / simplebookmovie / client / request / accountclient . java <nl> ppp b / app / src / main / java / com / kyletung / simplebookmovie / client / request / accountclient . java <nl> + * @ param code authorizationcode <nl> + * / <nl> + public observable & lt ; logindata & gt ; gettoken ( string code ) { <nl> + return maccountapi . gettoken ( <nl> + constants . app_key , <nl> + constants . app_secret , <nl> request_redirect_uri_mine , <nl> request_grant_type_get , <nl> code <nl> - ) . enqueue ( newcallback ( responseimpl ) ) ; <nl> + ) . compose ( flatresult ( ) ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / ui - tests / src / test / java / org / openmrs / reference / adddiagnosistovisitnotetest . java <nl> ppp b / ui - tests / src / test / java / org / openmrs / reference / adddiagnosistovisitnotetest . java <nl> @ category ( buildtests . class ) <nl> public void adddiagnosistovisitnotetest ( ) throws exception { <nl>  <nl> - activevisitspage = homepage . gotoactivevisitssearch ( ) ; <nl> + activevisitspage activevisitspage = homepage . gotoactivevisitssearch ( ) ; <nl> activevisitspage . search ( patient . identifier ) ; <nl>  <nl> - patientdashboardpage = activevisitspage . gotopatientdashboardoflastactivevisit ( ) ; <nl> - visitnotepage = patientdashboardpage . gotovisitnote ( ) ; <nl> + clinicianfacingpatientdashboardpage patientdashboardpage = activevisitspage . gotopatientdashboardoflastactivevisit ( ) ; <nl> + visitnotepage visitnotepage = patientdashboardpage . gotovisitnote ( ) ; <nl> visitnotepage . enterdiagnosis ( " pne " ) ; <nl> visitnotepage . entersecondarydiagnosis ( " bleed " ) ; <nl> 
mmm a / org . eclipse . virgo . web . war . deployer / src / main / java / org / eclipse / virgo / web / war / deployer / wardeployer . java <nl> ppp b / org . eclipse . virgo . web . war . deployer / src / main / java / org / eclipse / virgo / web / war / deployer / wardeployer . java <nl> - logger . error ( " can not start deployable with uri + [ " + uri + " ] . there is no bundle installed with this uri . " ) ; <nl> - return false ; <nl> - } <nl> - final string warname = extractdecodedwarnamefromstring ( uri . tostring ( ) ) ; <nl> - statusfilemodificator . deletestatusfile ( warname , this . pickupdir ) ; <nl> - final long lastmodified = new file ( uri ) . lastmodified ( ) ; <nl> - this . eventlogger . log ( wardeployerlogevents . nano_web_starting , bundle . getsymbolicname ( ) , bundle . getversion ( ) ) ; <nl> + @ override <nl> + public boolean start ( uri uri ) { <nl> + string extractionfoldername = webbundleutils . calculatecorrectsymbolicname ( extractdecodedwarnamefromstring ( uri . tostring ( ) ) ) ; <nl> + bundle bundle = getinstalledbundle ( extractionfoldername ) ; <nl> + if ( bundle == null ) { <nl> + this . eventlogger . log ( wardeployerlogevents . nano_starting_error , uri ) ; <nl> 
mmm a / src / main / java / eu / hansolo / medusa / skins / gaugeskin . java <nl> ppp b / src / main / java / eu / hansolo / medusa / skins / gaugeskin . java <nl> - } else if ( " lcd " . equals ( event_type ) ) { <nl> - if ( getskinnable ( ) . islcdvisible ( ) ) redraw ( ) ; <nl> - } else if ( " recalc " . equals ( event_type ) ) { <nl> - if ( getskinnable ( ) . isautoscale ( ) ) getskinnable ( ) . calcautoscale ( ) ; <nl> - startangle = getskinnable ( ) . getstartangle ( ) ; <nl> - anglerange = getskinnable ( ) . getanglerange ( ) ; <nl> - anglestep = getskinnable ( ) . getanglestep ( ) ; <nl> + if ( getskinnable ( ) . getvalue ( ) & gt ; maxvalue ) { oldvalue = maxvalue ; } <nl> + resize ( ) ; <nl> + redraw ( ) ; <nl> + rotateneedle ( getskinnable ( ) . getcurrentvalue ( ) ) ; <nl> + } else if ( " section " . equals ( event_type ) ) { <nl> + sections = getskinnable ( ) . getsections ( ) ; <nl> + highlightsections = getskinnable ( ) . ishighlightsections ( ) ; <nl> 
mmm a / app / src / main / java / com / waz / zclient / pages / basepreferencefragment . java <nl> ppp b / app / src / main / java / com / waz / zclient / pages / basepreferencefragment . java <nl> @ override <nl> public final istorefactory getstorefactory ( ) { <nl> - return getactivity ( ) ! = null ? zapplication . from ( getactivity ( ) ) . getstorefactory ( ) : null ; <nl> + return getactivity ( ) ! = null ? ( ( wireapplication ) getactivity ( ) . getapplication ( ) ) . storefactory ( ) : null ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / ardor3d - jogl / src / main / java / com / ardor3d / scene / state / jogl / joglshaderobjectsstateutil . java <nl> ppp b / ardor3d - jogl / src / main / java / com / ardor3d / scene / state / jogl / joglshaderobjectsstateutil . java <nl> - final intbuffer compiled = bufferutils . createintbuffer ( 1 ) ; <nl> - gl . getgl2 ( ) . glgetobjectparameterivarb ( programid , gl2es2 . gl_link_status , compiled ) ; <nl> + } <nl> + } <nl> if ( compiled . get ( 0 ) == gl . gl_false ) { <nl> - gl . getgl2 ( ) . glgetobjectparameterivarb ( programid , gl2es2 . gl_info_log_length , compiled ) ; <nl> - final int length = compiled . get ( 0 ) ; <nl> - string out = null ; <nl> - if ( length & gt ; 0 ) { <nl> + if ( gl . isgl2 ( ) ) { <nl> + gl . getgl2 ( ) . glgetobjectparameterivarb ( programid , gl2es2 . gl_info_log_length , compiled ) ; <nl> + } else { <nl> + if ( gl . isgl2es2 ( ) ) { <nl> + } <nl> + } <nl> 
mmm a / src / main / java / com / jjoe64 / graphview / series / linegraphseries . java <nl> ppp b / src / main / java / com / jjoe64 / graphview / series / linegraphseries . java <nl> - } <nl> - <nl> mpath . moveto ( startxanimated , starty ) ; <nl> - mpath . lineto ( endxanimated , endy ) ; <nl> - } <nl>  <nl> - if ( mstyles . drawbackground ) { <nl> + if ( math . abs ( endx - lastrenderedx ) & gt ; . 3f ) { <nl> + if ( mdrawaspath ) { <nl> + mpath . lineto ( endxanimated , endy ) ; <nl> + } else { <nl> + renderline ( canvas , new float [ ] { startxanimated , starty , endxanimated , endy } ) ; <nl> + } <nl> 
mmm a / sdk / src / main / java / com / braunster / chatsdk / dao / bmessagedao . java <nl> ppp b / sdk / src / main / java / com / braunster / chatsdk / dao / bmessagedao . java <nl> - entity . setresourcespath ( cursor . isnull ( offset + 4 ) ? null : cursor . getstring ( offset + 4 ) ) ; <nl> - entity . settext ( cursor . getstring ( offset + 5 ) ) ; <nl> - entity . settype ( cursor . getint ( offset + 6 ) ) ; <nl> - entity . setownerthread ( cursor . isnull ( offset + 7 ) ? null : cursor . getstring ( offset + 7 ) ) ; <nl> - entity . setsender ( cursor . isnull ( offset + 8 ) ? null : cursor . getstring ( offset + 8 ) ) ; <nl> + entity . setdate ( new java . util . date ( cursor . getlong ( offset + 2 ) ) ) ; <nl> + entity . setdirty ( cursor . isnull ( offset + 3 ) ? null : cursor . getshort ( offset + 3 ) ! = 0 ) ; <nl> + entity . setresources ( cursor . isnull ( offset + 4 ) ? null : cursor . getstring ( offset + 4 ) ) ; <nl> + entity . setresourcespath ( cursor . isnull ( offset + 5 ) ? null : cursor . getstring ( offset + 5 ) ) ; <nl> + entity . settext ( cursor . getstring ( offset + 6 ) ) ; <nl> + entity . settype ( cursor . getint ( offset + 7 ) ) ; <nl> + entity . setownerthread ( cursor . isnull ( offset + 8 ) ? null : cursor . getlong ( offset + 8 ) ) ; <nl> + entity . setsender ( cursor . isnull ( offset + 9 ) ? null : cursor . getlong ( offset + 9 ) ) ; <nl> } <nl>  <nl> 
mmm a / plugins / org . eclipse . emf . cdo . server / src / org / eclipse / emf / cdo / internal / server / repository . java <nl> ppp b / plugins / org . eclipse . emf . cdo . server / src / org / eclipse / emf / cdo / internal / server / repository . java <nl> - branchmanager . setbranchloader ( this ) ; <nl> + revisionmanager . setrevisionloader ( this ) ; <nl> + } <nl>  <nl> - revisionmanager . setrevisionloader ( this ) ; <nl> - sessionmanager . setrepository ( this ) ; <nl> - querymanager . setrepository ( this ) ; <nl> - commitinfomanager . setrepository ( this ) ; <nl> - commitinfomanager . setcommitinfoloader ( this ) ; <nl> + if ( sessionmanager . getrepository ( ) == null ) <nl> + { <nl> + sessionmanager . setrepository ( this ) ; <nl> + } <nl> + <nl> + if ( querymanager . getrepository ( ) == null ) <nl> 
mmm a / app / src / main / java / com / jrummyapps / packagemanager / fragments / installerfragment . java <nl> ppp b / app / src / main / java / com / jrummyapps / packagemanager / fragments / installerfragment . java <nl> + if ( binary . path . startswith ( " http " ) ) { <nl> file destination = new file ( getactivity ( ) . getcachedir ( ) , binary . name + " / " + binary . filename ) ; <nl> - <nl> - download download = new download . builder ( binary . path ) <nl> - . setdestination ( destination ) <nl> - . setshouldredownload ( false ) <nl> - . setmd5sum ( binary . md5sum ) <nl> - . build ( ) ; <nl> + if ( destination . exists ( ) & & destination . length ( ) == binary . size ) { <nl> + installer installer = new installer . builder ( ) <nl> + . setfilename ( binary . filename ) <nl> + . setbinary ( new afile ( destination ) ) <nl> + . setpath ( path ) <nl> + . setsymlink ( true ) <nl> + . setoverwrite ( false ) <nl> + . create ( ) ; <nl> + new thread ( installer ) . start ( ) ; <nl> + } else { <nl> + download = new download . builder ( binary . path ) <nl> + . setdestination ( destination ) <nl> + . setfilename ( binary . filename ) <nl> + . setshouldredownload ( true ) <nl> + . setmd5sum ( binary . md5sum ) <nl> + . build ( ) ; <nl> 
mmm a / app / src / main / java / com / money / manager / ex / search / searchparametersfragment . java <nl> ppp b / app / src / main / java / com / money / manager / ex / search / searchparametersfragment . java <nl> if ( searchparameters . datefrom ! = null ) { <nl> - where . addstatement ( queryalldata . date , " & gt ; = " , mmxdatetimeutils . getisostringfrom ( searchparameters . datefrom . todate ( ) ) ) ; <nl> + where . addstatement ( queryalldata . date , " & gt ; = " , new mmxdate ( searchparameters . datefrom ) . toisostring ( ) ) ; <nl> } <nl> if ( searchparameters . dateto ! = null ) { <nl> 
mmm a / opendaylight / md - sal / sal - distributed - datastore / src / test / java / org / opendaylight / controller / cluster / datastore / entityownership / distributedentityownershipintegrationtest . java <nl> ppp b / opendaylight / md - sal / sal - distributed - datastore / src / test / java / org / opendaylight / controller / cluster / datastore / entityownership / distributedentityownershipintegrationtest . java <nl> + boolean passed = false ; <nl> for ( int i = 0 ; i & lt ; 100 ; i++ ) { <nl> uninterruptibles . sleepuninterruptibly ( 50 , timeunit . milliseconds ) ; <nl> - if ( ! leaderentityownershipservice . getownershipstate ( entity1 ) . ispresent ( ) <nl> - || leaderentityownershipservice . getownershipstate ( entity1 ) . get ( ) == entityownershipstate . no_owner <nl> - & & follower1entityownershipservice . getownershipstate ( entity1 ) . ispresent ( ) <nl> - & & follower1entityownershipservice . getownershipstate ( entity1 ) <nl> - . get ( ) == entityownershipstate . no_owner <nl> - & & follower2entityownershipservice . getownershipstate ( entity1 ) . ispresent ( ) <nl> + final optional & lt ; entityownershipstate & gt ; leaderstate = leaderentityownershipservice . getownershipstate ( entity1 ) ; <nl> + final optional & lt ; entityownershipstate & gt ; follower1state = <nl> + follower1entityownershipservice . getownershipstate ( entity1 ) ; <nl> + final optional & lt ; entityownershipstate & gt ; follower2state = <nl> 
mmm a / src / fourthline / mabiicco / midi / mabidls . java <nl> ppp b / src / fourthline / mabiicco / midi / mabidls . java <nl> 0 ) ; <nl> track . add ( new midievent ( pcmessage , 0 ) ) ; <nl> boolean enablepart [ ] = instclass . getenablepartbyprogram ( program ) ; <nl> - insttype insttype = getinstbyprogram ( mmltrack . getprogram ( ) ) . gettype ( ) ; <nl> + instclass instclass = getinstbyprogram ( mmltrack . getprogram ( ) ) ; <nl>  <nl> mmlmiditrack miditrack = new mmlmiditrack ( mmltrack . getglobaltempolist ( ) ) ; <nl> for ( int i = 0 ; i & lt ; enablepart . length ; i++ ) { <nl> 
mmm a / 1 . 7 . 10 / src / main / java / net / geforcemods / securitycraft / gui / guiscmanual . java <nl> ppp b / 1 . 7 . 10 / src / main / java / net / geforcemods / securitycraft / gui / guiscmanual . java <nl> this . drawtexturedmodalrect ( k , 5 , 0 , 0 , 256 , 250 ) ; <nl>  <nl> if ( this . currentpage & gt ; - 1 ) { <nl> - this . fontrendererobj . drawstring ( mod_securitycraft . instance . manualpages . get ( currentpage ) . getitemname ( ) , k + 39 , 27 , 0 , false ) ; <nl> + this . fontrendererobj . drawstring ( statcollector . translatetolocal ( mod_securitycraft . instance . manualpages . get ( currentpage ) . getitem ( ) . getunlocalizedname ( ) + " . name " ) , k + 39 , 27 , 0 , false ) ; <nl> this . fontrendererobj . drawsplitstring ( mod_securitycraft . instance . manualpages . get ( currentpage ) . gethelpinfo ( ) , k + 18 , 45 , 225 , 0 ) ; <nl> } else { <nl> this . fontrendererobj . drawstring ( statcollector . translatetolocal ( " gui . scmanual . intro . 1 " ) , k + 39 , 27 , 0 , false ) ; <nl> 
mmm a / modules / unsupported / mbstyle / src / main / java / org / geotools / mbstyle / parse / mbobjectparser . java <nl> ppp b / modules / unsupported / mbstyle / src / main / java / org / geotools / mbstyle / parse / mbobjectparser . java <nl> - * / <nl> - public static expression percentage ( jsonobject json , string tag , number fallback ) throws mbformatexception { <nl> - if ( json . get ( tag ) == null ) { <nl> - return ff . literal ( fallback ) ; <nl> + public static expression percentage ( jsonobject json , string tag , number fallback ) <nl> + throws mbformatexception { <nl> + if ( json == null ) { <nl> + return fallback == null ? null : ff . literal ( fallback ) ; <nl> } <nl> object obj = json . get ( tag ) ; <nl> - <nl> 
mmm a / ttt - ttpe / src / main / java / com / skynav / ttpe / app / presenter . java <nl> ppp b / ttt - ttpe / src / main / java / com / skynav / ttpe / app / presenter . java <nl> return null ; <nl> } <nl> if ( d . exists ( ) ) { <nl> - string outputfilename = messageformat . format ( outputpatternisd , ++outputfilesequenceisd ) ; <nl> + string outputfilename = outputpatternisdformatter . format ( new object [ ] { integer . valueof ( ++outputfilesequenceisd ) } ) ; <nl> file outputfile = new file ( d , outputfilename ) . getcanonicalfile ( ) ; <nl> if ( retoutputfile ! = null ) <nl> retoutputfile [ 0 ] = outputfile ; <nl> 
mmm a / dalesbred / src / test / java / org / dalesbred / internal / instantiation / conversionmaptest . java <nl> ppp b / dalesbred / src / test / java / org / dalesbred / internal / instantiation / conversionmaptest . java <nl> @ test <nl> public void searchbasedonresultcovariance ( ) { <nl> - typeconversion conversion = dummyconversion ( integer . class , string . class ) ; <nl> - registry . register ( conversion ) ; <nl> + typeconversion conversion = dummyconversion ( ) ; <nl> + registry . register ( integer . class , string . class , conversion ) ; <nl>  <nl> assertsame ( conversion , registry . findconversion ( integer . class , object . class ) . orelse ( null ) ) ; <nl> } <nl> 
mmm a / core / src / main / java / com / tickaroo / tikxml / xmlreader . java <nl> ppp b / core / src / main / java / com / tickaroo / tikxml / xmlreader . java <nl> - * / <nl> - public double nexttextcontentasdouble ( ) throws ioexception { <nl> - return double . parsedouble ( nexttextcontent ( ) ) ; <nl> - } <nl>  <nl> - / ** <nl> + string content = nexttextcontent ( ) ; <nl> + if ( content . equals ( " " ) ) { <nl> + return 0 ; <nl> + } <nl> + <nl> + return double . parsedouble ( content ) ; <nl> 
mmm a / src / test / java / com / wikia / webdriver / testcases / visualeditor / text / visualeditoreditingtests . java <nl> ppp b / src / test / java / com / wikia / webdriver / testcases / visualeditor / text / visualeditoreditingtests . java <nl> ve . typetextinallformat ( text ) ; <nl> ve . typetextinallstyle ( text ) ; <nl> ve . typetextinalllist ( text ) ; <nl> - ve . clickpublishbutton ( ) ; <nl> - articlepageobject article = new articlepageobject ( ) ; <nl> + visualeditorsavechangesdialog savedialog = ve . clickpublishbutton ( ) ; <nl> + visualeditorreviewchangesdialog reviewdialog = savedialog . clickreviewyourchanges ( ) ; <nl> + reviewdialog . verifyaddeddiffs ( wikitexts ) ; <nl> + savedialog = reviewdialog . clickreturntosaveformbutton ( ) ; <nl> + articlepageobject article = savedialog . savepage ( ) ; <nl> article . verifyvepublishcomplete ( ) ; <nl> article . verifycontent ( " lorem ipsum dolor sit amet , consectetur adipiscing elit . " ) ; <nl> 
mmm a / misc / thutessentials / src / main / java / thut / essentials / land / landeventshandler . java <nl> ppp b / misc / thutessentials / src / main / java / thut / essentials / land / landeventshandler . java <nl> - string owner = landmanager . getinstance ( ) . getlandowner ( c ) ; <nl> + landteam owner = landmanager . getinstance ( ) . getlandowner ( c ) ; <nl> if ( owner == null || evt . getitemstack ( ) . getitem ( ) instanceof itemfood || ! configmanager . instance . landenabled ) <nl> return ; <nl> - landteam playerteam = landmanager . getteam ( evt . getentityplayer ( ) ) ; <nl> - string team = playerteam . teamname ; <nl> - if ( owner . equals ( team ) ) <nl> + if ( landmanager . owns ( evt . getentityplayer ( ) , c ) ) <nl> { <nl> return ; <nl> } <nl> 
mmm a / sqldelight - gradle - plugin / src / test / fixtures / works - fine - as - library / expected / com / test / usermodel . java <nl> ppp b / sqldelight - gradle - plugin / src / test / fixtures / works - fine - as - library / expected / com / test / usermodel . java <nl> cursor . isnull ( cursor . getcolumnindex ( middle_initial ) ) ? null : cursor . getstring ( cursor . getcolumnindex ( middle_initial ) ) , <nl> cursor . getstring ( cursor . getcolumnindex ( last_name ) ) , <nl> cursor . getint ( cursor . getcolumnindex ( age ) ) , <nl> - user . gender . valueof ( cursor . getstring ( cursor . getcolumnindex ( gender ) ) ) <nl> + genderadapter . map ( cursor , cursor . getcolumnindex ( gender ) ) <nl> ) ; <nl> } <nl>  <nl> 
mmm a / cepheus - ngsi / src / test / java / com / orange / ngsi / server / ngsibasecontrollertest . java <nl> ppp b / cepheus - ngsi / src / test / java / com / orange / ngsi / server / ngsibasecontrollertest . java <nl> notifycontext notifycontext = createnotifycontexttempsensor ( 0 ) ; <nl> notifycontext . setsubscriptionid ( null ) ; <nl>  <nl> - mockmvc . perform ( post ( " / ni / notifycontext " ) . content ( json ( jsonconverter , notifycontext ) ) . contenttype ( mediatype . application_json ) ) <nl> + mockmvc . perform ( post ( " / ni / notifycontext " ) . content ( json ( jsonconverter , notifycontext ) ) . contenttype ( mediatype . application_json ) . header ( " host " , " localhost " ) . accept ( mediatype . application_json ) ) <nl> . andexpect ( status ( ) . isok ( ) ) <nl> . andexpect ( mockmvcresultmatchers . jsonpath ( " $ . responsecode . code " ) . value ( codeenum . code_471 . getlabel ( ) ) ) <nl> . andexpect ( mockmvcresultmatchers . jsonpath ( " $ . responsecode . reasonphrase " ) . value ( codeenum . code_471 . getshortphrase ( ) ) ) <nl> 
mmm a / appcore / src / main / java / mobi / cangol / mobile / db / databaseutils . java <nl> ppp b / appcore / src / main / java / mobi / cangol / mobile / db / databaseutils . java <nl> object value=null ; <nl> for ( field field : obj . getclass ( ) . getdeclaredfields ( ) ) { <nl> field . setaccessible ( true ) ; <nl> - if ( field . isenumconstant ( ) ) continue ; <nl> + if ( field . isenumconstant ( ) ||modifier . isfinal ( field . getmodifiers ( ) ) ||modifier . istransient ( field . getmodifiers ( ) ) ) continue ; <nl> if ( field . isannotationpresent ( databasefield . class ) ) { <nl> databasefield dbfield = field . getannotation ( databasefield . class ) ; <nl> if ( dbfield . primarykey ( ) ==true ) { <nl> 
mmm a / enforcer - rules / src / test / java / org / apache / maven / plugins / enforcer / requireactiveprofiletest . java <nl> ppp b / enforcer - rules / src / test / java / org / apache / maven / plugins / enforcer / requireactiveprofiletest . java <nl> public void testtwoactiveprofileswhereoneprofileisrequiredtobeactivated ( ) <nl> throws enforcerruleexception <nl> { <nl> - list & lt ; profile & gt ; profiles = new arraylist & lt ; profile & gt ; ( ) ; <nl> - profiles . add ( createprofile ( " profile - 1 " ) ) ; <nl> - profiles . add ( createprofile ( " profile - 2 " ) ) ; <nl> + list & lt ; profile & gt ; profiles = arrays . aslist ( createprofile ( " profile - 1 " ) , createprofile ( " profile - 2 " ) ) ; <nl>  <nl> when ( project . getactiveprofiles ( ) ) . thenreturn ( profiles ) ; <nl> 
mmm a / rznw / game / maincharacter / maincharacterstepincrementer . java <nl> ppp b / rznw / game / maincharacter / maincharacterstepincrementer . java <nl> maincharacter . getsteps ( ) . sethpsteps ( maincharacter . getsteps ( ) . gethpsteps ( ) + 1 ) ; <nl> if ( maincharacter . getsteps ( ) . gethpsteps ( ) & gt ; = maincharacter . getsteps ( ) . getstepsforheal ( ) ) <nl> { <nl> - maincharacter . heal ( 10 ) ; <nl> + int hphealed = maincharacter . heal ( 10 ) ; <nl> maincharacter . getsteps ( ) . sethpsteps ( 0 ) ; <nl> + <nl> + logrendererfactory . instance ( ) . log ( " you healed " + hphealed + " hp via physical regeneration . " ) ; <nl> } <nl> } <nl> 
mmm a / sources / net . sf . j2s . java . org . eclipse . swt / src / org / eclipse / swt / widgets / menu . java <nl> ppp b / sources / net . sf . j2s . java . org . eclipse . swt / src / org / eclipse / swt / widgets / menu . java <nl> btnfocus = document . createelement ( " button " ) ; <nl> btnfocus . classname = " menu - focus " ; <nl> - handle . appendchild ( btnfocus ) ; <nl> + if ( beginspace ! = null ) { <nl> + handle . insertbefore ( btnfocus , beginspace ) ; <nl> + } else { <nl> + handle . appendchild ( btnfocus ) ; <nl> + } <nl> hmenukeydown = new runnablecompatibility ( ) { <nl> public void run ( ) { <nl> - htmlevent evt = ( htmlevent ) getevent ( ) ; <nl> 
mmm a / sdk / src / com / constellio / app / modules / rm / model / decommissioninglistacceptancetest . java <nl> ppp b / sdk / src / com / constellio / app / modules / rm / model / decommissioninglistacceptancetest . java <nl> public void givenfolderswithuniformruleandnonuniformcopyandcategorythennotuniform ( ) <nl> throws exception { <nl>  <nl> - decommissioninglist = saveandload ( newfilingspacealist ( ) . setfolderdetailsfor ( records . folders ( " a04 - a06 " ) ) ) ; <nl> + decommissioninglist = saveandload ( newfilingspacealist ( ) . setdecommissioninglisttype ( decommissioninglisttype . folders_to_transfer ) . setfolderdetailsfor ( records . folders ( " a04 - a06 " ) ) ) ; <nl> assertthat ( decommissioninglist . hasanalogicalmedium ( ) ) . isequalto ( true ) ; <nl> assertthat ( decommissioninglist . haselectronicmedium ( ) ) . isequalto ( true ) ; <nl> assertthat ( decommissioninglist . getfoldersmediatypes ( ) ) . containsonly ( hybrid , hybrid , hybrid ) ; <nl> assertthat ( decommissioninglist . getuniformrule ( ) ) . isequalto ( records . ruleid_1 ) ; <nl> assertthat ( decommissioninglist . isuniform ( ) ) . isequalto ( true ) ; <nl>  <nl> - decommissioninglist = saveandload ( newfilingspacealist ( ) . setfolderdetailsfor ( records . folders ( " a04 - a06 , a16 - a18 " ) ) ) ; <nl> + decommissioninglist = saveandload ( newfilingspacealist ( ) . setdecommissioninglisttype ( decommissioninglisttype . folders_to_transfer ) . setfolderdetailsfor ( records . folders ( " a04 - a06 , a16 - a18 " ) ) ) ; <nl> assertthat ( decommissioninglist . hasanalogicalmedium ( ) ) . isequalto ( true ) ; <nl> assertthat ( decommissioninglist . haselectronicmedium ( ) ) . isequalto ( true ) ; <nl> assertthat ( decommissioninglist . getfoldersmediatypes ( ) ) . containsonly ( hybrid , hybrid , hybrid , hybrid , hybrid , hybrid ) ; <nl> 
mmm a / scim2 - sdk - client / src / main / java / com / unboundid / scim2 / client / requests / retrieverequestbuilder . java <nl> ppp b / scim2 - sdk - client / src / main / java / com / unboundid / scim2 / client / requests / retrieverequestbuilder . java <nl> public & lt ; t & gt ; t invoke ( final class & lt ; t & gt ; cls ) throws scimexception <nl> { <nl> response response = buildrequest ( ) . get ( ) ; <nl> - if ( response . getstatusinfo ( ) . getfamily ( ) == <nl> - response . status . family . successful ) <nl> - { <nl> - t entity = response . readentity ( cls ) ; <nl> - response . close ( ) ; <nl> - return entity ; <nl> - } <nl> - else <nl> + try <nl> { <nl> + if ( response . getstatusinfo ( ) . getfamily ( ) == <nl> + response . status . family . successful ) <nl> + { <nl> + return response . readentity ( cls ) ; <nl> + } <nl> + else <nl> + { <nl> 
mmm a / src / main / java / jas / spawner / refactor / configsloader / biomespawnlistloader . java <nl> ppp b / src / main / java / jas / spawner / refactor / configsloader / biomespawnlistloader . java <nl> + entityvalueobject . addproperty ( living_handler_key , builder . getlivinghandlerid ( ) . get ( ) ) ; <nl> } <nl>  <nl> - if ( ! " " . equals ( builder . getcanspawn ( ) ) ) { <nl> - entityvalueobject . addproperty ( spawn_tag_key , builder . getcanspawn ( ) ) ; <nl> + if ( ! " " . equals ( builder . getcanspawn ( ) ) & & builder . getcanspawn ( ) . ispresent ( ) ) { <nl> + entityvalueobject . addproperty ( spawn_tag_key , builder . getcanspawn ( ) . get ( ) ) ; <nl> } <nl> - if ( ! " " . equals ( builder . getpostspawn ( ) ) ) { <nl> - entityvalueobject . addproperty ( postspawn_key , builder . getpostspawn ( ) ) ; <nl> + if ( ! " " . equals ( builder . getpostspawn ( ) ) & & builder . getpostspawn ( ) . ispresent ( ) ) { <nl> + entityvalueobject . addproperty ( postspawn_key , builder . getpostspawn ( ) . get ( ) ) ; <nl> } <nl> - if ( ! " " . equals ( builder . getentitytospawn ( ) ) ) { <nl> - entityvalueobject . addproperty ( entity_spawn , builder . getentitytospawn ( ) ) ; <nl> + tertobject . add ( tertkey , entityvalueobject ) ; <nl> 
mmm a / retrofit - adapters / rxjava / src / test / java / retrofit2 / adapter / rxjava / singletest . java <nl> ppp b / retrofit - adapters / rxjava / src / test / java / retrofit2 / adapter / rxjava / singletest . java <nl> @ test public void resultsuccess404 ( ) throws ioexception { <nl> server . enqueue ( new mockresponse ( ) . setresponsecode ( 404 ) . setbody ( " hi " ) ) ; <nl>  <nl> - blockingsingle & lt ; result & lt ; string & gt ; & gt ; o = service . result ( ) . toblocking ( ) ; <nl> - result & lt ; string & gt ; result = o . value ( ) ; <nl> + testsubscriber & lt ; result & lt ; string & gt ; & gt ; subscriber = new testsubscriber & lt ; & gt ; ( ) ; <nl> + service . result ( ) . subscribe ( subscriber ) ; <nl> + result & lt ; string & gt ; result = subscriber . getonnextevents ( ) . get ( 0 ) ; <nl> assertthat ( result . iserror ( ) ) . isfalse ( ) ; <nl> response & lt ; string & gt ; response = result . response ( ) ; <nl> assertthat ( response . issuccessful ( ) ) . isfalse ( ) ; <nl> 
mmm a / src / main / java / org / markdownwriterfx / editor / smartedit . java <nl> ppp b / src / main / java / org / markdownwriterfx / editor / smartedit . java <nl> - } <nl> + textarea . getundomanager ( ) . preventmerge ( ) ; <nl>  <nl> - public void insertbold ( ) { <nl> - surroundselectionincode ( " ** " ) ; <nl> + list & lt ; strongemphasis & gt ; nodes = findnodesatselection ( strongemphasis . class ) ; <nl> + if ( nodes . size ( ) & gt ; 0 ) { <nl> + removedelimiters ( nodes ) ; <nl> + } else <nl> + surroundselectionincode ( " ** " ) ; <nl> } <nl>  <nl> public void insertitalic ( ) { <nl> 
mmm a / time4j - android / src / main / java / net / time4j / format / expert / iso8601format . java <nl> ppp b / time4j - android / src / main / java / net / time4j / format / expert / iso8601format . java <nl> chronoformatter . builder & lt ; plaindate & gt ; builder = <nl> chronoformatter <nl> . setup ( plaindate . class , locale . root ) <nl> + . startsection ( attributes . number_system , numbersystem . arabic ) <nl> . startsection ( attributes . zero_digit , ' 0 ' ) <nl> . addinteger ( year_of_weekdate , 4 , 9 , signpolicy . show_when_big_number ) ; <nl>  <nl> builder . addliteral ( ' - ' ) ; <nl> } <nl>  <nl> - return builder . addfixednumerical ( day_of_week , 1 ) . endsection ( ) . build ( ) . with ( leniency . strict ) ; <nl> + return builder . addfixednumerical ( day_of_week , 1 ) . endsection ( ) . endsection ( ) . build ( ) . with ( leniency . strict ) ; <nl>  <nl> } <nl> 
mmm a / graylog2 - server / src / test / java / org / graylog2 / indexer / ranges / esindexrangeservicetest . java <nl> ppp b / graylog2 - server / src / test / java / org / graylog2 / indexer / ranges / esindexrangeservicetest . java <nl> . rotationstrategy ( messagecountrotationstrategyconfig . createdefault ( ) ) <nl> . retentionstrategyclass ( deletionretentionstrategy . class . getcanonicalname ( ) ) <nl> . retentionstrategy ( deletionretentionstrategyconfig . createdefault ( ) ) <nl> + . indexanalyzer ( " standard " ) <nl> + . indextemplatename ( " template - 1 " ) <nl> + . indexoptimizationmaxnumsegments ( 1 ) <nl> + . indexoptimizationdisabled ( false ) <nl> . build ( ) ; <nl> this . indexset = new testindexset ( indexsetconfig ) ; <nl> this . elasticsearchrule = newelasticsearchrule ( ) . defaultembeddedelasticsearch ( ) ; <nl> 
mmm a / src / main / java / org / gedcomx / conversion / gedcom / dq55 / personmapper . java <nl> ppp b / src / main / java / org / gedcomx / conversion / gedcom / dq55 / personmapper . java <nl> - gedxperson . setgender ( gender ) ; <nl> + } <nl> + } <nl> + <nl> + private void processsex ( person gedxperson , eventfact fact ) { <nl> + if ( gedxperson . getgender ( ) ! = null ) { <nl> + } <nl> + <nl> + if ( fact . getvalue ( ) . equalsignorecase ( " m " ) ) { <nl> + gedxperson . setgender ( new gender ( gendertype . male ) ) ; <nl> + } <nl> + else if ( fact . getvalue ( ) . equalsignorecase ( " f " ) ) { <nl> + gedxperson . setgender ( new gender ( gendertype . female ) ) ; <nl> } <nl> else if ( fact . getvalue ( ) . equalsignorecase ( " u " ) ) { <nl> - gender gender = new gender ( ) ; <nl> - gender . setknowntype ( gendertype . unknown ) ; <nl> - gedxperson . setgender ( gender ) ; <nl> + gedxperson . setgender ( new gender ( gendertype . unknown ) ) ; <nl> } <nl> else { <nl> 
mmm a / mobile / src / androidtest / java / com / kuxhausen / huemore / moodtest . java <nl> ppp b / mobile / src / androidtest / java / com / kuxhausen / huemore / moodtest . java <nl> event e1 = new event ( bs1 , 1 , 0 ) ; <nl> event e2 = new event ( bs2 , 1 , 5000l ) ; <nl>  <nl> - mood m = new mood ( ) ; <nl> - m . setevents ( new event [ ] { e1 , e2 } ) ; <nl> - m . setnumchannels ( 2 ) ; <nl> + mood m = new mood . builder ( ) <nl> + . setevents ( new event [ ] { e1 , e2 } ) <nl> + . setnumchannels ( 2 ) <nl> + . build ( ) ; <nl>  <nl> assertfalse ( m . gettimeaddressingrepeatpolicy ( ) ) ; <nl> assertfalse ( m . isinfinitelooping ( ) ) ; <nl> 
mmm a / hemesh 2014 / src / wblut / processing / wb_debugrender3d . java <nl> ppp b / hemesh 2014 / src / wblut / processing / wb_debugrender3d . java <nl> home . box ( ( float ) d ) ; <nl> home . popmatrix ( ) ; <nl> } else { <nl> - c = he . gethalfedgecenter ( ) ; <nl> - c . addself ( he . getpair ( ) . gethalfedgenormal ( ) . mulself ( - d ) ) ; <nl> + c = new wb_point ( he . gethalfedgecenter ( ) ) ; <nl> + c . addmulself ( - d , he . getpair ( ) . gethalfedgenormal ( ) ) ; <nl> home . stroke ( 255 , 0 , 0 ) ; <nl> home . line ( he . getvertex ( ) . xf ( ) , he . getvertex ( ) . yf ( ) , he <nl> . getvertex ( ) . zf ( ) , c . xf ( ) , c . yf ( ) , c . zf ( ) ) ; <nl> 
mmm a / src / main / java / modtweaker2 / mods / forestry / handlers / carpenter . java <nl> ppp b / src / main / java / modtweaker2 / mods / forestry / handlers / carpenter . java <nl> * / <nl> @ zenmethod <nl> public static void addrecipe ( iitemstack output , iingredient [ ] [ ] ingredients , int packagingtime , @ optional iitemstack box ) { <nl> - minetweakerapi . apply ( new add ( new recipe ( packagingtime , null , tostack ( box ) , shapedrecipecustom . createshapedrecipe ( tostack ( output ) , toshapedobjects ( ingredients ) ) ) ) ) ; <nl> + idescriptiverecipe craftrecipe = new descriptiverecipe ( 3 , 3 , toshapedobjects ( ingredients ) , tostack ( output ) , false ) ; <nl> + minetweakerapi . apply ( new add ( new carpenterrecipe ( packagingtime , null , tostack ( box ) , craftrecipe ) ) ) ; <nl> } <nl> - <nl> - / ** <nl> 
mmm a / src / test / java / org / jfaster / mango / exception / illegalstateexceptiontest . java <nl> ppp b / src / test / java / org / jfaster / mango / exception / illegalstateexceptiontest . java <nl> thrown . expect ( illegalstateexception . class ) ; <nl> thrown . expectmessage ( " if use cache , each method expected one or more " + <nl> " @ cacheby annotation on parameter but found 0 " ) ; <nl> - dao3 dao = mango . create ( dao3 . class , new localcachehandler ( ) ) ; <nl> + mango mango = mango . newinstance ( datasourceconfig . getdatasource ( ) ) ; <nl> + mango . setlazyinit ( true ) ; <nl> + mango . setcachehandler ( new localcachehandler ( ) ) ; <nl> + dao3 dao = mango . create ( dao3 . class ) ; <nl> dao . add ( ) ; <nl> } <nl> 
mmm a / core / src / main / java / org / fourthline / cling / transport / impl / datagramioimpl . java <nl> ppp b / core / src / main / java / org / fourthline / cling / transport / impl / datagramioimpl . java <nl> + } <nl> + <nl> synchronized public void send ( outgoingdatagrammessage message ) { <nl> - log . fine ( " sending message from address : " + localaddress ) ; <nl> + if ( log . isloggable ( level . fine ) ) { <nl> + log . fine ( " sending message from address : " + localaddress ) ; <nl> + } <nl> datagrampacket packet = datagramprocessor . write ( message ) ; <nl> - log . fine ( " sending udp datagram packet to : " + message . getdestinationaddress ( ) + " : " + message . getdestinationport ( ) ) ; <nl> + <nl> + if ( log . isloggable ( level . fine ) ) { <nl> + log . fine ( " sending udp datagram packet to : " + message . getdestinationaddress ( ) + " : " + message . getdestinationport ( ) ) ; <nl> + } <nl> + <nl> send ( packet ) ; <nl> - } <nl> 
mmm a / ding - impl / ding - presentation - impl / src / main / java / org / cytoscape / ding / impl / dedgedetails . java <nl> ppp b / ding - impl / ding - presentation - impl / src / main / java / org / cytoscape / ding / impl / dedgedetails . java <nl> + @ override <nl> public paint getsourcearrowpaint ( final cyedge edge ) { <nl> boolean isselected = selected . contains ( edge ) ; <nl>  <nl> - if ( isselected ) <nl> - return getselectedpaint ( edge ) ; <nl> - else <nl> - return getsourcearrowunselectedpaint ( edge ) ; <nl> + return isselected ? getselectedpaint ( edge ) : getsourcearrowunselectedpaint ( edge ) ; <nl> } <nl>  <nl> private final paint getsourcearrowunselectedpaint ( final cyedge edge ) { <nl> 
mmm a / src / com / bfh / logisim / designrulecheck / netlist . java <nl> ppp b / src / com / bfh / logisim / designrulecheck / netlist . java <nl> if ( slavenet ! = null ) { <nl> if ( slavenet . isrootnet ( ) ) { <nl> - result . addall ( gethiddensource ( slavenet , netindex , <nl> + sourceinfo ret = gethiddensource ( slavenet , netindex , <nl> splitterlist , currentsplitter , <nl> - handlednets , segments ) ) ; <nl> + handlednets , segments , reporter ) ; <nl> + if ( ret ! = null ) <nl> + return ret ; <nl> } else { <nl> - result . addall ( gethiddensource ( slavenet . getparent ( ) , <nl> - slavenet . getbit ( netindex ) , <nl> + sourceinfo ret = gethiddensource ( slavenet . getparent ( ) , <nl> + slavenet . getbit ( netindex ) , <nl> 
mmm a / src / main / java / com / yandex / money / api / typeadapters / showcase / showcasetypeadapter . java <nl> ppp b / src / main / java / com / yandex / money / api / typeadapters / showcase / showcasetypeadapter . java <nl> + list & lt ; allowedmoneysource & gt ; moneysources = allowedmoneysourcetypeadapter . getinstance ( ) <nl> + . fromjson ( object . getasjsonarray ( member_money_source ) ) ; <nl> + list & lt ; error & gt ; errors = errortypeadapter . getinstance ( ) . fromjson ( object . getasjsonarray ( member_error ) ) ; <nl> + <nl> + return new showcase . builder ( ) <nl> + . settitle ( getmandatorystring ( object , member_title ) ) <nl> + . sethiddenfields ( getnotnullmap ( object , member_hidden_fields ) ) <nl> . setform ( form ) <nl> - . setmoneysources ( new linkedhashset & lt ; & gt ; ( getnotnullarray ( object , member_money_source , <nl> - allowedmoneysourcetypeadapter . getinstance ( ) ) ) ) <nl> - . seterrors ( getnotnullarray ( object , member_error , errortypeadapter . getinstance ( ) ) ) <nl> + . setmoneysources ( toemptylistifnull ( moneysources ) ) <nl> + . seterrors ( toemptylistifnull ( errors ) ) <nl> . create ( ) ; <nl> } <nl> 
mmm a / src / main / java / com / fabahaba / jedipus / cluster / jedipus . java <nl> ppp b / src / main / java / com / fabahaba / jedipus / cluster / jedipus . java <nl> - return result ; <nl> - } catch ( final redisconnectionexception jcex ) { <nl> - <nl> - retries = connhandler . getclusternoderetrydelay ( ) <nl> - . markfailure ( client == null ? node : client . getnode ( ) , maxretries , jcex , retries ) ; <nl> - } catch ( final redisretryableunhandledexception retryableex ) { <nl> - <nl> - if ( ! retryunhandledretryableexceptions ) { <nl> + pool = null ; <nl> + final node failednode = client == null ? retryableex . getnode ( ) : client . getnode ( ) ; <nl> + client = null ; <nl> + retries = connhandler . getclusternoderetrydelay ( ) . markfailure ( failednode , maxretries , <nl> + retryableex , retries ) ; <nl> + } finally { <nl> + redisclientpool . returnclient ( pool , client ) ; <nl> + } <nl> 
mmm a / app / src / main / java / com / cooloongwu / greendao / gen / chatfrienddao . java <nl> ppp b / app / src / main / java / com / cooloongwu / greendao / gen / chatfrienddao . java <nl> cursor . isnull ( offset + 5 ) ? null : cursor . getstring ( offset + 5 ) , /  / content <nl> cursor . isnull ( offset + 6 ) ? null : cursor . getstring ( offset + 6 ) , /  / contenttype <nl> - cursor . isnull ( offset + 7 ) ? null : cursor . getstring ( offset + 7 ) , /  / time <nl> - cursor . getshort ( offset + 8 ) ! = 0 /  / isread <nl> + cursor . isnull ( offset + 7 ) ? null : cursor . getstring ( offset + 7 ) , /  / audiolength <nl> + cursor . isnull ( offset + 8 ) ? null : cursor . getstring ( offset + 8 ) , /  / time <nl> + cursor . getshort ( offset + 9 ) ! = 0 /  / isread <nl> ) ; <nl> return entity ; <nl> } <nl> 
mmm a / src / main / java / com / marklogic / client / impl / jerseyservices . java <nl> ppp b / src / main / java / com / marklogic / client / impl / jerseyservices . java <nl> if ( logger . isdebugenabled ( ) ) <nl> logger . debug ( " searching for structure { } " , structure ) ; <nl>  <nl> - builder = getconnection ( ) . path ( " search " ) . queryparams ( params ) <nl> - . type ( " application / xml " ) . accept ( mimetype ) ; <nl> + webresource = getconnection ( ) . path ( " search " ) . queryparams ( params ) ; <nl> + builder = webresource . type ( " application / xml " ) . accept ( mimetype ) ; <nl> } else if ( querydef instanceof combinedquerydefinition ) { <nl> structure = ( ( combinedquerydefinition ) querydef ) . serialize ( ) ; <nl> 
mmm a / dbfit - java / db2 / src / main / java / dbfit / environment / db2ienvironment . java <nl> ppp b / dbfit - java / db2 / src / main / java / dbfit / environment / db2ienvironment . java <nl> + while ( rs . next ( ) ) { <nl> + string paramname = rs . getstring ( 1 ) ; <nl> + if ( paramname == null ) <nl> + paramname = " " ; <nl> + string datatype = rs . getstring ( 2 ) ; <nl> string direction = rs . getstring ( 4 ) ; <nl> direction paramdirection = getparameterdirection ( direction ) ; <nl> - dbparameteraccessor dbp = new dbparameteraccessor ( paramname , <nl> + dbparameteraccessor dbp = createdbparameteraccessor ( <nl> + paramname , <nl> paramdirection , getsqltype ( datatype ) , <nl> getjavaclass ( datatype ) , <nl> - paramdirection == return_value ? - 1 <nl> - : position++ ) ; <nl> + paramdirection == return_value ? - 1 : position++ ) ; <nl> allparams . put ( namenormaliser . normalisename ( paramname ) , dbp ) ; <nl> } <nl> rs . close ( ) ; <nl> 
mmm a / phosphor / src / edu / columbia / cs / psl / phosphor / instrumenter / tainttrackingclassvisitor . java <nl> ppp b / phosphor / src / edu / columbia / cs / psl / phosphor / instrumenter / tainttrackingclassvisitor . java <nl> mv . visitfieldinsn ( opcodes . putfield , classname , taintutils . taint_field , configuration . taint_tag_desc ) ; <nl> if ( classname . equals ( " java / lang / string " ) ) { <nl> + mv . visitvarinsn ( opcodes . aload , 0 ) ; <nl> + mv . visitvarinsn ( opcodes . aload , 0 ) ; <nl> + mv . visitfieldinsn ( opcodes . getfield , classname , " value " , " [ c " ) ; /  / force the stringtaintverifyingmv to make sure there is a taint array here <nl> + mv . visitinsn ( opcodes . arraylength ) ; <nl> + mv . visitintinsn ( opcodes . newarray , opcodes . t_int ) ; <nl> + mv . visitfieldinsn ( opcodes . putfield , classname , " value " + taintutils . taint_field , configuration . taint_tag_arraydesc ) ; <nl> + <nl> mv . visitvarinsn ( opcodes . aload , 0 ) ; <nl> mv . visitfieldinsn ( opcodes . getfield , classname , " value " + taintutils . taint_field , configuration . taint_tag_arraydesc ) ; <nl> mv . visitvarinsn ( opcodes . iload , 1 ) ; <nl> 
mmm a / src / com / avail / descriptor / messagebundletreedescriptor . java <nl> ppp b / src / com / avail / descriptor / messagebundletreedescriptor . java <nl> + * / <nl> + @ override <nl> + void o_removeplaninprogress ( <nl> final availobject object , <nl> - final a_definitionparsingplan plan ) <nl> + final a_parsingplaninprogress planinprogress ) <nl> { <nl> synchronized ( object ) <nl> { <nl> - final a_bundle bundle = plan . bundle ( ) ; <nl> - final a_definition definition = plan . definition ( ) ; <nl> - a_map allplans = object . slot ( all_plans ) ; <nl> - assert allplans . haskey ( bundle ) ; <nl> - a_map submap = allplans . mapat ( bundle ) ; <nl> - submap = submap . mapwithoutkeycandestroy ( definition , true ) ; <nl> - if ( submap . mapsize ( ) == 0 ) <nl> - { <nl> - allplans = allplans . mapwithoutkeycandestroy ( bundle , true ) ; <nl> - } <nl> - else <nl> - { <nl> - allplans = allplans . mapatputtingcandestroy ( <nl> - bundle , submap , true ) ; <nl> - } <nl> - object . setslot ( all_plans , allplans . makeshared ( ) ) ; <nl> - a_map unclassified = object . slot ( unclassified ) ; <nl> - if ( unclassified . haskey ( bundle ) ) <nl> - { <nl> - a_map unclassifiedsubmap = unclassified . mapat ( bundle ) ; <nl> - unclassifiedsubmap = unclassifiedsubmap . mapwithoutkeycandestroy ( <nl> - definition , true ) ; <nl> - if ( unclassifiedsubmap . mapsize ( ) == 0 ) <nl> - { <nl> - unclassified = unclassified . mapwithoutkeycandestroy ( <nl> - bundle , true ) ; <nl> - } <nl> - else <nl> - { <nl> - unclassified = unclassified . mapatputtingcandestroy ( <nl> - bundle , unclassifiedsubmap , true ) ; <nl> - } <nl> - object . setslot ( unclassified , unclassified . makeshared ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> + object . setslot ( <nl> + all_plans_in_progress , <nl> + layeredmapwithoutplan ( <nl> + object . slot ( all_plans_in_progress ) , planinprogress ) ) ; <nl> + object . setslot ( <nl> + unclassified , <nl> + layeredmapwithoutplan ( <nl> 
mmm a / src / main / java / org / zwobble / mammoth / internal / styles / parsing / stylemappingtokeniser . java <nl> ppp b / src / main / java / org / zwobble / mammoth / internal / styles / parsing / stylemappingtokeniser . java <nl> list ( <nl> regextokeniser . rule ( tokentype . identifier , " ( [ a - za - z ] [ a - za - z0 - 9 \  \  - ] * ) " ) , <nl> regextokeniser . rule ( tokentype . class_name , " ( \  \  . ( ? : [ a - za - z0 - 9 \  \  - ] | \  \  \  \ . ) + ) " ) , <nl> - regextokeniser . rule ( tokentype . colon , " : " ) , <nl> - regextokeniser . rule ( tokentype . greater_than , " & gt ; " ) , <nl> + regextokeniser . rule ( tokentype . symbol , " : | & gt ; |= & gt ; |=| \  \ ( | \  \ ) | \  \ [ | \  \ ] | \  \ || ! " ) , <nl> regextokeniser . rule ( tokentype . whitespace , " \  \ s+ " ) , <nl> - regextokeniser . rule ( tokentype . arrow , " = & gt ; " ) , <nl> - regextokeniser . rule ( tokentype . equals , " = " ) , <nl> - regextokeniser . rule ( tokentype . open_paren , " \  \ ( " ) , <nl> - regextokeniser . rule ( tokentype . close_paren , " \  \ ) " ) , <nl> + regextokeniser . rule ( tokentype . string , stringprefix + " ' " ) , <nl> 
mmm a / src / main / java / com / github / games647 / flexiblelogin / listener / preventlistener . java <nl> ppp b / src / main / java / com / github / games647 / flexiblelogin / listener / preventlistener . java <nl> - @ listener ( ignorecancelled = true ) <nl> - public void onitemconsume ( useitemstackevent . sourceplayer itemconsumeevent ) { <nl> - checkallowance ( itemconsumeevent , itemconsumeevent . getsourceentity ( ) ) ; <nl> } <nl>  <nl> @ listener ( ignorecancelled = true ) <nl> + public void onitemconsume ( useitemstackevent itemconsumeevent ) { <nl> + optional & lt ; player & gt ; playeroptional = itemconsumeevent . getcause ( ) . first ( player . class ) ; <nl> + if ( playeroptional . ispresent ( ) ) { <nl> + checkallowance ( itemconsumeevent , playeroptional . get ( ) ) ; <nl> + } <nl> + } <nl> 
mmm a / src / v2 / org / analysis / complement / bitvector . java <nl> ppp b / src / v2 / org / analysis / complement / bitvector . java <nl> - result |= ( b1 & 0xff ) ; <nl>  <nl> - result = ( bitvector . isapihandle ( ) ) ? convert . convetunsignedvalue ( result , 32 ) : convert . convertsignedvalue ( <nl> - result , 32 ) ; <nl> - <nl> - return result ; <nl> + return convert . convetunsignedvalue ( result , 32 ) ; <nl> } <nl>  <nl> public static long bytestolong ( int b1 , int b2 ) { <nl> 
mmm a / main / plugins / org . talend . designer . camel . dependencies . core / src / org / talend / designer / camel / dependencies / core / dependenciesresolver . java <nl> ppp b / main / plugins / org . talend . designer . camel . dependencies . core / src / org / talend / designer / camel / dependencies / core / dependenciesresolver . java <nl> - continue ; <nl> - } <nl> - for ( importpackage importpackage : targets ) { <nl> - if ( ! importpackages . add ( importpackage ) ) { <nl> - for ( importpackage obj : importpackages ) { <nl> - if ( importpackage . equals ( obj ) ) { <nl> - importpackage = obj ; <nl> - break ; <nl> - } <nl> - } <nl> + final collection & lt ; importpackage & gt ; targets = ip . totargets ( n ) ; <nl> + if ( targets ! = null ) { <nl> + for ( importpackage importpackage : targets ) { <nl> + additem ( importpackages , importpackage ) . addrelativecomponent ( uniquename ) ; <nl> } <nl> + } <nl> + } <nl> 
mmm a / patient - user / src / test / java / gov / samhsa / c2s / patientuser / web / usercreationcontrollertest . java <nl> ppp b / patient - user / src / test / java / gov / samhsa / c2s / patientuser / web / usercreationcontrollertest . java <nl> mvc . perform ( post ( " / activations " ) <nl> . contenttype ( mediatype . application_json_utf8 ) <nl> - . content ( objectmapper . writevalueasbytes ( request ) ) ) <nl> + . content ( objectmapper . writevalueasbytes ( request ) ) <nl> + . header ( usercreationcontroller . x_forwarded_proto , xforwardedproto ) <nl> + . header ( usercreationcontroller . x_forwarded_host , xforwardedhost ) <nl> + . header ( usercreationcontroller . x_forwarded_port , xforwardedport ) ) <nl> . andexpect ( status ( ) . isok ( ) ) <nl> . andexpect ( jsonpath ( " $ . id " , is ( patientid . intvalue ( ) ) ) ) <nl> . andexpect ( jsonpath ( " $ . lastname " , is ( lastname ) ) ) <nl> 
mmm a / src / main / java / com / github / bingoohuang / springrestclient / generators / methodgenerator . java <nl> ppp b / src / main / java / com / github / bingoohuang / springrestclient / generators / methodgenerator . java <nl> - mv . visitvarinsn ( aload , paramsize + 2 ) ; <nl> - <nl> - mv . visitldcinsn ( type . gettype ( returntype ) ) ; <nl> - mv . visitmethodinsn ( invokestatic , p ( unirestutils . class ) , " asjson " , <nl> - sig ( object . class , string . class , map . class , map . class , class . class ) , false ) ; <nl> - mv . visittypeinsn ( checkcast , p ( returntype ) ) ; <nl> - mv . visitinsn ( areturn ) ; <nl> - mv . visitmaxs ( - 1 , - 1 ) ; <nl> + if ( requestbodyindex & lt ; 0 ) { <nl> + mv . visitldcinsn ( type . gettype ( returntype ) ) ; <nl> + mv . visitmethodinsn ( invokestatic , p ( unirestutils . class ) , " get " , <nl> + sig ( object . class , string . class , map . class , map . class , class . class ) , false ) ; <nl> + mv . visittypeinsn ( checkcast , p ( returntype ) ) ; <nl> + mv . visitinsn ( areturn ) ; <nl> + } else { <nl> + mv . visitvarinsn ( aload , requestbodyindex + 1 ) ; <nl> + mv . visitmethodinsn ( invokestatic , p ( unirestutils . class ) , " postasjson " , <nl> + sig ( string . class , string . class , map . class , map . class , object . class ) , false ) ; <nl> + mv . visitvarinsn ( astore , paramsize + 3 ) ; <nl> + mv . visitvarinsn ( aload , paramsize + 3 ) ; <nl> 
mmm a / src / main / java / org / squiddev / cobalt / lib / debuglib . java <nl> ppp b / src / main / java / org / squiddev / cobalt / lib / debuglib . java <nl> + valueof ( ds . hookcount ) ) ; <nl> + } <nl> + <nl> static varargs _sethook ( luastate state , varargs args ) { <nl> int a = 1 ; <nl> - luathread thread = args . isthread ( a ) ? args . checkthread ( a++ ) : state . currentthread ; <nl> - luavalue func = args . optfunction ( a++ , null ) ; <nl> - string str = args . optjstring ( a++ , " " ) ; <nl> - int count = args . optint ( a++ , 0 ) ; <nl> + luathread thread = args . arg ( a ) . isthread ( ) ? args . arg ( a++ ) . checkthread ( ) : state . currentthread ; <nl> + int i1 = a++ ; <nl> + luavalue func = args . arg ( i1 ) . optfunction ( null ) ; <nl> + int i3 = a++ ; <nl> + string str = args . arg ( i3 ) . optjstring ( " " ) ; <nl> + int i2 = a++ ; <nl> + int count = args . arg ( i2 ) . optinteger ( 0 ) ; <nl> + boolean call = false , line = false , rtrn = false ; <nl> + for ( int i = 0 ; i & lt ; str . length ( ) ; i++ ) { <nl> + switch ( str . charat ( i ) ) { <nl> 
mmm a / rest / src / main / java / org / teavm / flavour / rest / impl / factoryemitter . java <nl> ppp b / rest / src / main / java / org / teavm / flavour / rest / impl / factoryemitter . java <nl> } <nl>  <nl> - private valueemitter createlistdeserializer ( type itemtype , programemitter pe ) { <nl> - valueemitter itemdeserializer = createdeserializer ( itemtype , pe ) . cast ( jsondeserializer . class ) ; <nl> - return pe . construct ( listdeserializer . class , itemdeserializer ) ; <nl> + private value & lt ; jsondeserializer & gt ; createlistdeserializer ( emitter & lt ; ? & gt ; em , type itemtype ) { <nl> + value & lt ; jsondeserializer & gt ; itemdeserializer = createdeserializer ( em , itemtype ) ; <nl> + return em . emit ( ( ) - & gt ; new listdeserializer ( itemdeserializer . get ( ) ) ) ; <nl> } <nl>  <nl> - private valueemitter createsetdeserializer ( type itemtype , programemitter pe ) { <nl> + private value & lt ; jsondeserializer & gt ; createsetdeserializer ( emitter & lt ; ? & gt ; em , type itemtype ) { <nl> 
mmm a / src / consulo / unity3d / jsonapi / unityopenfileposthandler . java <nl> ppp b / src / consulo / unity3d / jsonapi / unityopenfileposthandler . java <nl> - } <nl> - <nl> ideframe ideframe = windowmanager . getinstance ( ) . getideframe ( openedproject ) ; <nl> - requestfocushttprequesthandler . activateframe ( ideframe ) ; <nl> + if ( systeminfo . ismac ) <nl> + { <nl> + id id = macutil . findwindowfromjavawindow ( ( window ) ideframe ) ; <nl> + if ( id ! = null ) <nl> + { <nl> + foundation . invoke ( id , " makekeyandorderfront " , new object [ ] { null } ) ; <nl> + } <nl> + } <nl> + else if ( systeminfo . iswindows ) <nl> + { <nl> + pointer windowpointer = native . getwindowpointer ( ( window ) ideframe ) ; <nl> + user32 . instance . setforegroundwindow ( new windef . hwnd ( windowpointer ) ) ; <nl> + } <nl> + else <nl> + { <nl> + requestfocushttprequesthandler . activateframe ( ideframe ) ; <nl> + } <nl> } <nl> - <nl> - private void openfile ( @ nullable project openedproject , @ notnull unityopenfileposthandlerrequest body ) <nl> 
mmm a / mjolnirrecyclerview / src / main / java / co / infinum / mjolnirrecyclerview / mjolnirrecycleradapter . java <nl> ppp b / mjolnirrecyclerview / src / main / java / co / infinum / mjolnirrecyclerview / mjolnirrecycleradapter . java <nl> - * @ return true if header was added / replaced , false otherwise . <nl> - * / <nl> - public boolean setheader ( @ layoutres int headerviewid , boolean shouldreplace ) { <nl> - if ( shouldreplace || ! hasheader ( ) ) { <nl> - removeheader ( ) ; <nl> - headerview = layoutinflater . from ( getcontext ( ) ) . inflate ( headerviewid , null , false ) ; <nl> - setdefaultlayoutparams ( headerview ) ; <nl> - notifyiteminserted ( 0 ) ; <nl> - return true ; <nl> + headerview = layoutinflater . from ( getcontext ( ) ) . inflate ( headerviewid , null , false ) ; <nl> + setdefaultlayoutparams ( headerview ) ; <nl> + <nl> + if ( hadheaderbefore ) { <nl> + notifyitemchanged ( 0 ) ; <nl> } else { <nl> - return false ; <nl> + notifyiteminserted ( 0 ) ; <nl> } <nl> } <nl> 
mmm a / src / shaders / shadowshader . java <nl> ppp b / src / shaders / shadowshader . java <nl> shaderprogram . pedantic = false ; <nl> shaderprogram shadowshader = new shaderprogram ( vertexshader , <nl> fragmentshader ) ; <nl> - if ( shadowshader . iscompiled ( ) == false ) { <nl> - gdx . app . log ( " error " , shadowshader . getlog ( ) ) ; <nl> - <nl> + if ( ! shadowshader . iscompiled ( ) ) { <nl> + shadowshader = new shaderprogram ( " # version 330 core \ n " +vertexshader , <nl> + " # version 330 core \ n " +fragmentshader ) ; <nl> + if ( ! shadowshader . iscompiled ( ) ) { <nl> + gdx . app . log ( " error " , shadowshader . getlog ( ) ) ; <nl> + } <nl> } <nl> 
mmm a / src / main / java / edu / sc / seis / taup / taup_curve . java <nl> ppp b / src / main / java / edu / sc / seis / taup / taup_curve . java <nl> ( isbetween ( math . acos ( math . cos ( phase . getdist ( ) [ distindex ] ) ) , <nl> math . acos ( math . cos ( phase . getdist ( ) [ distindex+1 ] ) ) , <nl> arcdistance ) ) ) { <nl> - phase . calctime ( arcdistance*180 / math . pi ) ; <nl> - arrival [ ] phasearrivals = phase . getarrivals ( ) ; <nl> - int j = 0 ; <nl> - while ( j & lt ; phasearrivals . length ) { <nl> - if ( ( phase . rayparams [ distindex ] - phasearrivals [ j ] . getrayparam ( ) ) <nl> - * ( phasearrivals [ j ] . getrayparam ( ) - phase . rayparams [ distindex + 1 ] ) & gt ; 0 ) { <nl> + list & lt ; arrival & gt ; phasearrivals = phase . calctime ( arcdistance*180 / math . pi ) ; <nl> + for ( arrival arrival : phasearrivals ) { <nl> + if ( ( phase . rayparams [ distindex ] - arrival . getrayparam ( ) ) <nl> + * ( arrival . getrayparam ( ) - phase . rayparams [ distindex + 1 ] ) & gt ; 0 ) { <nl> if ( reducetime ) { <nl> - writevalue ( arcdistance , phasearrivals [ j ] . gettime ( ) - arcdistance <nl> - / reducevel , relphase , out ) ; <nl> - } else { <nl> - writevalue ( arcdistance , phasearrivals [ j ] . gettime ( ) , relphase , out ) ; <nl> - } <nl> - break ; <nl> - } <nl> 
mmm a / org . eclipse . january . geometry / src - gen / xtext / parser / antlr / internal / internalstlparser . java <nl> ppp b / org . eclipse . january . geometry / src - gen / xtext / parser / antlr / internal / internalstlparser . java <nl> - newcompositenode ( grammaraccess . getvertexaccess ( ) . getzedoubleparserrulecall_3_0 ( ) ) ; <nl> - <nl> - pushfollow ( follow_2 ) ; <nl> - lv_z_3_0=ruleedouble ( ) ; <nl> - <nl> - state . _fsp -  - ; <nl> + { <nl> + lv_z_3_0= ( token ) match ( input , rule_double , follow_2 ) ; <nl>  <nl> + newleafnode ( lv_z_3_0 , grammaraccess . getvertexaccess ( ) . getzdoubleterminalrulecall_3_0 ( ) ) ; <nl> + <nl>  <nl> if ( current==null ) { <nl> - current = createmodelelementforparent ( grammaraccess . getvertexrule ( ) ) ; <nl> + current = createmodelelement ( grammaraccess . getvertexrule ( ) ) ; <nl> } <nl> - set ( <nl> + setwithlastconsumed ( <nl> current , <nl> " z " , <nl> lv_z_3_0 , <nl> - " xtext . stl . edouble " ) ; <nl> - afterparserorenumrulecall ( ) ; <nl> + " xtext . stl . double " ) ; <nl>  <nl> + <nl> + } <nl> 
mmm a / ij / plugin / plugininstaller . java <nl> ppp b / ij / plugin / plugininstaller . java <nl> + } <nl> + <nl> + public static byte [ ] download ( string urlstring , string name ) { <nl> + url url = null ; <nl> + try { <nl> + url = new url ( urlstring ) ; <nl> + } catch ( exception e ) { <nl> + ij . log ( " " +e ) ; <nl> + } <nl> + if ( url==null ) return null ; <nl> + byte [ ] data ; <nl> try { <nl> urlconnection uc = url . openconnection ( ) ; <nl> int len = uc . getcontentlength ( ) ; <nl> - ij . showstatus ( " downloading " +url . getfile ( ) ) ; <nl> + if ( name ! =null ) <nl> + ij . showstatus ( " downloading " +url . getfile ( ) ) ; <nl> inputstream in = uc . getinputstream ( ) ; <nl> data = new byte [ len ] ; <nl> int n = 0 ; <nl> 
mmm a / src / com / opentaxi / android / fragments / requestdetailsfragment . java <nl> ppp b / src / com / opentaxi / android / fragments / requestdetailsfragment . java <nl> if ( newcrequest . getcarnumber ( ) ! = null & & ! newcrequest . getcarnumber ( ) . isempty ( ) ) { <nl> car . settext ( ( newcrequest . getnotes ( ) ! = null ? newcrequest . getnotes ( ) : " " ) + " â " + newcrequest . getcarnumber ( ) ) ; <nl> - drawable icon = new iconicsdrawable ( mactivity , googlematerial . icon . gmd_info ) . actionbar ( ) . colorres ( r . color . transparent_blue ) ; <nl> + drawable icon = new icondrawable ( mactivity , materialicons . md_info ) . colorres ( r . color . transparent_blue ) . sizedp ( 30 ) ; <nl> car . setcompounddrawableswithintrinsicbounds ( null , null , icon , null ) ; <nl> car . setonclicklistener ( new view . onclicklistener ( ) { <nl> - public void onclick ( view v ) { <nl> 
mmm a / src / com / android / providers / downloads / helpers . java <nl> ppp b / src / com / android / providers / downloads / helpers . java <nl> + / ** <nl> + * checks whether the filename looks legitimate <nl> + * / <nl> + static boolean isfilenamevalid ( string filename , file downloadsdatadir ) { <nl> + final string [ ] whitelist ; <nl> + try { <nl> + filename = new file ( filename ) . getcanonicalpath ( ) ; <nl> + whitelist = new string [ ] { <nl> + downloadsdatadir . getcanonicalpath ( ) , <nl> + environment . getdownloadcachedirectory ( ) . getcanonicalpath ( ) , <nl> + environment . getexternalstoragedirectory ( ) . getcanonicalpath ( ) , <nl> + } ; <nl> + } catch ( ioexception e ) { <nl> + log . w ( tag , " failed to resolve canonical path : " + e ) ; <nl> return false ; <nl> } <nl>  <nl> - return filename . startswith ( environment . getdownloadcachedirectory ( ) . tostring ( ) ) <nl> - || filename . startswith ( downloadsdatadir . tostring ( ) ) <nl> - || filename . startswith ( environment . getexternalstoragedirectory ( ) . tostring ( ) ) ; <nl> + for ( string test : whitelist ) { <nl> + if ( filename . startswith ( test ) ) { <nl> + return true ; <nl> + } <nl> + } <nl> + <nl> + return false ; <nl> } <nl> + <nl> + / ** <nl> 
mmm a / org . eclipse . jdt . ui / ui / org / eclipse / jdt / internal / ui / util / coreutility . java <nl> ppp b / org . eclipse . jdt . ui / ui / org / eclipse / jdt / internal / ui / util / coreutility . java <nl> + } <nl> + } <nl> } <nl> + submonitor submonitor= submonitor . convert ( monitor , messages . format ( javauimessages . coreutility_buildproject_taskname , basicelementlabels . getresourcename ( fproject ) ) , 2 ) ; <nl> try { <nl> if ( fproject ! = null ) { <nl> - monitor . begintask ( messages . format ( javauimessages . coreutility_buildproject_taskname , basicelementlabels . getresourcename ( fproject ) ) , 2 ) ; <nl> - fproject . build ( incrementalprojectbuilder . full_build , new subprogressmonitor ( monitor,1 ) ) ; <nl> - javaplugin . getworkspace ( ) . build ( incrementalprojectbuilder . incremental_build , new subprogressmonitor ( monitor,1 ) ) ; <nl> + fproject . build ( incrementalprojectbuilder . full_build , submonitor . split ( 1 ) ) ; <nl> + javaplugin . getworkspace ( ) . build ( incrementalprojectbuilder . incremental_build , submonitor . split ( 1 ) ) ; <nl> } else { <nl> monitor . begintask ( javauimessages . coreutility_buildall_taskname , 2 ) ; <nl> - javaplugin . getworkspace ( ) . build ( incrementalprojectbuilder . full_build , new subprogressmonitor ( monitor , 2 ) ) ; <nl> - } <nl> - } catch ( coreexception e ) { <nl> - return e . getstatus ( ) ; <nl> + javaplugin . getworkspace ( ) . build ( incrementalprojectbuilder . full_build , submonitor . split ( 2 ) ) ; <nl> 
mmm a / hadoop - hdfs - project / hadoop - hdfs / src / main / java / org / apache / hadoop / hdfs / server / namenode / fspermissionchecker . java <nl> ppp b / hadoop - hdfs - project / hadoop - hdfs / src / main / java / org / apache / hadoop / hdfs / server / namenode / fspermissionchecker . java <nl> return ; <nl> } <nl>  <nl> - datainputbuffer buffer = new datainputbuffer ( ) ; <nl> - buffer . reset ( inode . getpermission ( ) , inode . getpermission ( ) . length ) ; <nl> - permissionstatus ps = permissionstatus . read ( buffer ) ; <nl> - fspermission mode = ps . getpermission ( ) ; <nl> - <nl> - check ( inode . getid ( ) , access , mode , ps . getusername ( ) , ps . getgroupname ( ) ) ; <nl> + check ( inode . getid ( ) , access , new fspermission ( inode . getpermission ( ) ) , inode <nl> + . getusername ( ) , inode . getgroupname ( ) ) ; <nl> } <nl> 
mmm a / java - symbol - solver - core / src / main / java / com / github / javaparser / symbolsolver / javaparsermodel / contexts / methodcallexprcontext . java <nl> ppp b / java - symbol - solver - core / src / main / java / com / github / javaparser / symbolsolver / javaparsermodel / contexts / methodcallexprcontext . java <nl> @ override <nl> public symbolreference & lt ; methoddeclaration & gt ; solvemethod ( string name , list & lt ; type & gt ; argumentstypes , typesolver typesolver ) { <nl> - if ( wrappednode . getscope ( ) . ispresent ( ) ) { <nl> + if ( wrappednode . getscope ( ) ! = null ) { <nl>  <nl> - if ( wrappednode . getscope ( ) . get ( ) instanceof nameexpr ) { <nl> - nameexpr scopeasname = ( nameexpr ) wrappednode . getscope ( ) . get ( ) ; <nl> + if ( wrappednode . getscope ( ) instanceof nameexpr ) { <nl> + nameexpr scopeasname = ( nameexpr ) wrappednode . getscope ( ) ; <nl> symbolreference symbolreference = this . solvetype ( scopeasname . getname ( ) , typesolver ) ; <nl> if ( symbolreference . issolved ( ) & & symbolreference . getcorrespondingdeclaration ( ) . istype ( ) ) { <nl> typedeclaration typedeclaration = symbolreference . getcorrespondingdeclaration ( ) . astype ( ) ; <nl>  <nl> type typeofscope = null ; <nl> try { <nl> - typeofscope = javaparserfacade . get ( typesolver ) . gettype ( wrappednode . getscope ( ) . get ( ) ) ; <nl> + typeofscope = javaparserfacade . get ( typesolver ) . gettype ( wrappednode . getscope ( ) ) ; <nl> } catch ( exception e ) { <nl> throw new runtimeexception ( string . format ( " issur calculating the type of the scope of " + this ) , e ) ; <nl> } <nl> 
mmm a / thrifty - schema / src / main / java / com / microsoft / thrifty / schema / linker . java <nl> ppp b / thrifty - schema / src / main / java / com / microsoft / thrifty / schema / linker . java <nl> try { <nl> structtype . link ( this ) ; <nl> } catch ( linkfailureexception e ) { <nl> - environment . adderror ( <nl> - " failed to resolve type " + e . getmessage ( ) + " referenced at " + structtype . location ( ) ) ; <nl> + reporter . error ( structtype . location ( ) , " failed to resolve type ' " + e . getmessage ( ) + " ' " ) ; <nl> } <nl> } <nl> } <nl> 
mmm a / third - party / triemap / src / main / java / org / opendaylight / yangtools / triemap / triemap . java <nl> ppp b / third - party / triemap / src / main / java / org / opendaylight / yangtools / triemap / triemap . java <nl> public v put ( final k key , final v value ) { <nl> ensurereadwrite ( ) ; <nl> final int hc = computehash ( key ) ; <nl> - final option & lt ; v & gt ; ov = insertifhc ( key , hc , value , null ) ; <nl> - if ( ov instanceof some ) { <nl> - some & lt ; v & gt ; sv = ( some & lt ; v & gt ; ) ov ; <nl> - return sv . get ( ) ; <nl> - } <nl> - <nl> - return null ; <nl> + return insertifhc ( key , hc , value , null ) . orelse ( null ) ; <nl> } <nl>  <nl> triemap & lt ; k , v & gt ; add ( final k k , final v v ) { <nl> 
mmm a / src / test / java / com / google / api / gax / grpc / unarycallabletest . java <nl> ppp b / src / test / java / com / google / api / gax / grpc / unarycallabletest . java <nl> @ test ( expected = validationexception . class ) <nl> public void pagedfixedsizecollectiontoomanyelements ( ) { <nl> mockito . when ( callintlist . futurecall ( ( integer ) mockito . any ( ) , ( callcontext ) mockito . any ( ) ) ) <nl> - . thenreturn ( futures . & lt ; list & lt ; integer & gt ; & gt ; immediatefuture ( lists . newarraylist ( 0 , 1 , 2 ) ) ) <nl> - . thenreturn ( futures . & lt ; list & lt ; integer & gt ; & gt ; immediatefuture ( lists . newarraylist ( 3 , 4 ) ) ) <nl> - . thenreturn ( futures . immediatefuture ( collections . & lt ; integer & gt ; emptylist ( ) ) ) ; <nl> + . thenreturn ( immediatefuture ( arrays . aslist ( 0 , 1 , 2 ) ) ) <nl> + . thenreturn ( immediatefuture ( arrays . aslist ( 3 , 4 ) ) ) <nl> + . thenreturn ( immediatefuture ( collections . & lt ; integer & gt ; emptylist ( ) ) ) ; <nl>  <nl> unarycallable . & lt ; integer , list & lt ; integer & gt ; & gt ; create ( callintlist ) <nl> 
mmm a / test / functionaltest . java <nl> ppp b / test / functionaltest . java <nl> - } <nl> is . close ( ) ; <nl>  <nl> - iterator & lt ; result & lt ; upload & gt ; & gt ; uploaditer = client . listincompleteuploads ( bucketname , " minio " , true ) ; <nl> - for ( int i = 0 ; i & lt ; 10 ; i++ ) { <nl> - if ( uploaditer . hasnext ( ) ) { <nl> - result r = uploaditer . next ( ) ; <nl> - println ( i , r . getresult ( ) ) ; <nl> - } else { <nl> + int i = 0 ; <nl> + for ( result & lt ; upload & gt ; r : client . listincompleteuploads ( bucketname , " minio " , true ) ) { <nl> + println ( i++ , r . get ( ) ) ; <nl> + if ( i == 10 ) { <nl> break ; <nl> } <nl> + } <nl> 
mmm a / simplenewsproject / simplenews / src / main / java / de / dala / simplenews / ui / expandablenewsfragment . java <nl> ppp b / simplenewsproject / simplenews / src / main / java / de / dala / simplenews / ui / expandablenewsfragment . java <nl> - shareactionprovider shareactionprovider = new shareactionprovider ( getactivity ( ) ) ; <nl> - item . setactionprovider ( shareactionprovider ) ; <nl> - shareactionprovider . setsharehistoryfilename ( <nl> - shareactionprovider . default_share_history_file_name ) ; <nl> - shareactionprovider . setshareintent ( createshareintent ( ) ) ; <nl> - shareactionprovider . setonsharetargetselectedlistener ( new shareactionprovider . onsharetargetselectedlistener ( ) { <nl> - @ override <nl> - public boolean onsharetargetselected ( shareactionprovider shareactionprovider , intent intent ) { <nl> - return false ; <nl> + mode . getmenuinflater ( ) . inflate ( r . menu . contextual_list_view , menu ) ; <nl> + menuitem item = menu . finditem ( r . id . menu_item_share ) ; <nl> + if ( item ! = null ) { <nl> + shareactionprovider = ( shareactionprovider ) item . getactionprovider ( ) ; <nl> + if ( shareactionprovider ! = null ) { <nl> + string sharehistoryfilename = shareactionprovider . default_share_history_file_name ; <nl> + shareactionprovider . setsharehistoryfilename ( sharehistoryfilename ) ; <nl> + shareactionprovider . setshareintent ( getshareintent ( ) ) ; <nl> + shareactionprovider . setonsharetargetselectedlistener ( new shareactionprovider . onsharetargetselectedlistener ( ) { <nl> + @ override <nl> + public boolean onsharetargetselected ( shareactionprovider shareactionprovider , intent intent ) { <nl> + return false ; <nl> + } <nl> + } ) ; <nl> } <nl> - } ) ; <nl> + } <nl> return true ; <nl> - } <nl> 
mmm a / src / util / connectionmanager . java <nl> ppp b / src / util / connectionmanager . java <nl> system . out . println ( " errore 401 " ) ; <nl> system . out . println ( " token scaduto , richiesta nuovo token " ) ; <nl> connectionmanager . tokenexpired = true ; <nl> - connectandgettoken ( ) ; <nl> - getanimeinformation ( animeid ) ; <nl> + attempts++ ; <nl> + if ( attempts & gt ; 5 ) <nl> + { <nl> + connectandgettoken ( ) ; <nl> + getanimeinformation ( animeid ) ; <nl> + attempts = 0 ; <nl> + } <nl> + else <nl> + joptionpane . showmessagedialog ( animeindex . frame , " errore durante la connessione ! potrebbe dipendere dalla tua connessione o dal sito di anilist . " , " errore ! " , joptionpane . error_message ) ; <nl> } <nl> else <nl> + { <nl> 
mmm a / deeplearning4j - core / src / test / java / org / deeplearning4j / gradientcheck / cnngradientchecktest . java <nl> ppp b / deeplearning4j - core / src / test / java / org / deeplearning4j / gradientcheck / cnngradientchecktest . java <nl> + double [ ] l2vals = { 0 . 4 , 0 . 0 , 0 . 4 , 0 . 4 } ; <nl> + double [ ] l1vals = { 0 . 0 , 0 . 0 , 0 . 5 , 0 . 0 } ; <nl> + double [ ] biasl2 = { 0 . 0 , 0 . 0 , 0 . 0 , 0 . 2 } ; <nl> + double [ ] biasl1 = { 0 . 0 , 0 . 0 , 0 . 6 , 0 . 0 } ; <nl> + <nl> + for ( string afn : activfns ) { <nl> + for ( boolean dolearningfirst : characteristic ) { <nl> + for ( int i=0 ; i & lt ; lossfunctions . length ; i++ ) { <nl> + for ( int k = 0 ; k & lt ; l2vals . length ; k++ ) { <nl> + lossfunctions . lossfunction lf = lossfunctions [ i ] ; <nl> + string outputactivation = outputactivations [ i ] ; <nl> + double l2 = l2vals [ k ] ; <nl> + double l1 = l1vals [ k ] ; <nl> + <nl> multilayerconfiguration . builder builder = new neuralnetconfiguration . builder ( ) <nl> . regularization ( true ) <nl> . l2 ( l2 ) . l1 ( l1 ) <nl> + . l2bias ( biasl2 [ k ] ) . l1bias ( biasl1 [ k ] ) <nl> . optimizationalgo ( optimizationalgorithm . conjugate_gradient ) <nl> . seed ( 12345l ) <nl> . list ( ) <nl> 
mmm a / test / functionaltest . java <nl> ppp b / test / functionaltest . java <nl> - filenames [ i ] = filename ; <nl> } <nl>  <nl> - iterator & lt ; result & lt ; item & gt ; & gt ; objectiter = client . listobjects ( bucketname ) ; <nl> - for ( int i = 0 ; i & lt ; 10 ; i++ ) { <nl> - if ( objectiter . hasnext ( ) ) { <nl> - result r = objectiter . next ( ) ; <nl> - println ( i , r . getresult ( ) ) ; <nl> - } else { <nl> + i = 0 ; <nl> + for ( result r : client . listobjects ( bucketname ) ) { <nl> + println ( i++ , r . get ( ) ) ; <nl> + if ( i == 10 ) { <nl> break ; <nl> } <nl> + } <nl> 
mmm a / src / main / java / reborncore / common / recipes / recipecrafter . java <nl> ppp b / src / main / java / reborncore / common / recipes / recipecrafter . java <nl> - for ( itemstack input : recipetype . getinputs ( ) ) { <nl> - boolean hasitem = false ; <nl> + if ( recipetype == null ) { <nl> + return false ; <nl> + } <nl> + for ( object input : recipetype . getinputs ( ) ) { <nl> + boolean hasitem = false ; <nl> + boolean useoredict = input instanceof string || recipetype . useoredic ( ) ; <nl> + boolean checksize = input instanceof itemstack ; <nl> for ( int inputslot : inputslots ) { <nl> - if ( itemutils . isitemequal ( input , inventory . getstackinslot ( inputslot ) , true , true , <nl> - recipetype . useoredic ( ) ) & & inventory . getstackinslot ( inputslot ) . getcount ( ) & gt ; = input . getcount ( ) ) { <nl> - hasitem = true ; <nl> - } <nl> - } <nl> + if ( itemutils . isinputequal ( input , inventory . getstackinslot ( inputslot ) , true , true , <nl> + useoredict ) ) { <nl> + itemstack stack = recipetranslator . getstackfromobject ( input ) ; <nl> + if ( ! checksize || inventory . getstackinslot ( inputslot ) . getcount ( ) & gt ; = stack . getcount ( ) ) { <nl> + hasitem = true ; <nl> + } <nl> 
mmm a / validator / src / main / java / com / networknt / validator / parameter / arrayparametervalidator . java <nl> ppp b / validator / src / main / java / com / networknt / validator / parameter / arrayparametervalidator . java <nl> - } <nl> - <nl> - public validationreport validate ( final collection & lt ; string & gt ; values , final parameter p ) { <nl> - final mutablevalidationreport report = new mutablevalidationreport ( ) ; <nl> - if ( p == null ) { <nl> - return report ; <nl> - } <nl> - <nl> final serializableparameter parameter = ( serializableparameter ) p ; <nl> if ( parameter . getrequired ( ) & & ( values == null || values . isempty ( ) ) ) { <nl> - return report . add ( messages . get ( " validation . request . parameter . missing " , parameter . getname ( ) ) ) ; <nl> + return new status ( " err11001 " , parameter . getname ( ) ) ; <nl> } <nl>  <nl> if ( values == null ) { <nl> - return report ; <nl> + return null ; <nl> } <nl>  <nl> if ( ! parameter . getcollectionformat ( ) . equalsignorecase ( collectionformat . multi . name ( ) ) ) { <nl> - return report . add ( messages . get ( " validation . request . parameter . collection . invalidformat " , <nl> - p . getname ( ) , parameter . getcollectionformat ( ) , " multi " ) <nl> - ) ; <nl> + return new status ( " err11005 " , p . getname ( ) , parameter . getcollectionformat ( ) , " multi " ) ; <nl> } <nl>  <nl> - dovalidate ( values , parameter , report ) ; <nl> - return report ; <nl> + return dovalidate ( values , parameter ) ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / src / edu / umass / cs / gnsclient / console / commands / acllist . java <nl> ppp b / src / edu / umass / cs / gnsclient / console / commands / acllist . java <nl> + } <nl> + <nl> - jsonarray write = gnsclient . aclget ( aclaccesstype . write_whitelist , module . getcurrentguid ( ) , field , module <nl> - . getcurrentguid ( ) . getguid ( ) ) ; <nl> - console . printstring ( " write acl : " + write . tostring ( ) ) ; <nl> - console . printnewline ( ) ; <nl> - } <nl> - catch ( exception e ) <nl> - { <nl> + if ( gnsclient . fieldaclexists ( aclaccesstype . write_whitelist , module . getcurrentguid ( ) , field ) ) { <nl> + jsonarray write = gnsclient . aclget ( aclaccesstype . write_whitelist , module . getcurrentguid ( ) , field , module <nl> + . getcurrentguid ( ) . getguid ( ) ) ; <nl> + console . printstring ( " write acl : " + write . tostring ( ) ) ; <nl> + console . printnewline ( ) ; <nl> + } else { <nl> + console . printstring ( " write acl for field " + field + " does not exist " ) ; <nl> + console . printnewline ( ) ; <nl> + } <nl> + } catch ( exception e ) { <nl> 
mmm a / app / src / main / java / in / aviaryan / hinix / mainactivity . java <nl> ppp b / app / src / main / java / in / aviaryan / hinix / mainactivity . java <nl> for ( int i = 0 ; i & lt ; num_rows ; i++ ) { <nl> for ( int j = 0 ; j & lt ; num_cols ; j++ ) { <nl> textview tv = ( textview ) findviewbyid ( fetchid ( i , j ) ) ; <nl> - tv . setbackground ( getdrawable ( r . drawable . my_border ) ) ; <nl> + if ( build . version . sdk_int & gt ; =build . version_codes . lollipop ) <nl> + tv . setbackground ( getdrawable ( r . drawable . my_border ) ) ; <nl> + else <nl> + tv . setbackgrounddrawable ( getresources ( ) . getdrawable ( r . drawable . my_border ) ) ; <nl> } <nl> } <nl> } <nl> 
mmm a / rt / rs / security / jose - parent / jose / src / main / java / org / apache / cxf / rs / security / jose / jws / jwsutils . java <nl> ppp b / rt / rs / security / jose - parent / jose / src / main / java / org / apache / cxf / rs / security / jose / jws / jwsutils . java <nl> + return algo ; <nl> } <nl> public static signaturealgorithm getsignaturealgorithm ( properties props , <nl> - signaturealgorithm defaultalgo ) { <nl> - string algo = keymanagementutils . getkeyalgorithm ( phaseinterceptorchain . getcurrentmessage ( ) , <nl> - props , <nl> - joseconstants . rssec_signature_algorithm , <nl> - defaultalgo == null ? null : defaultalgo . getjwaname ( ) ) ; <nl> - return signaturealgorithm . getalgorithm ( algo ) ; <nl> + signaturealgorithm defaultalgo ) { <nl> + return getsignaturealgorithm ( phaseinterceptorchain . getcurrentmessage ( ) , <nl> + props , defaultalgo ) ; <nl> } <nl> - private static signaturealgorithm getdefaultkeyalgorithm ( jsonwebkey jwk ) { <nl> - keytype keytype = jwk . getkeytype ( ) ; <nl> + public static signaturealgorithm getsignaturealgorithm ( message m , <nl> 
mmm a / src / main / java / me / gnat008 / perworldinventory / data / players / pwiplayermanager . java <nl> ppp b / src / main / java / me / gnat008 / perworldinventory / data / players / pwiplayermanager . java <nl> + * @ param player the player <nl> * @ return the pwiplayer in the cache , or null <nl> * / <nl> public pwiplayer getplayer ( group group , player player ) { <nl> - string key = player . getuniqueid ( ) . tostring ( ) + " . " + group . getname ( ) + " . " ; <nl> - if ( settings . getproperty ( pwiproperties . separate_gamemode_inventories ) ) <nl> - key += player . getgamemode ( ) . tostring ( ) . tolowercase ( ) ; <nl> - else <nl> - key += " survival " ; <nl> + string key = makekey ( player . getuniqueid ( ) , group , player . getgamemode ( ) ) ; <nl> + <nl> + return playercache . get ( key ) ; <nl> + } <nl> 
mmm a / src / main / java / com / myapp / repository / userrepositoryimpl . java <nl> ppp b / src / main / java / com / myapp / repository / userrepositoryimpl . java <nl> - ) ; <nl> - query . orderby ( cb . desc ( root . get ( " id " ) ) ) ; <nl> + optional & lt ; long & gt ; sinceid , <nl> + optional & lt ; long & gt ; maxid , <nl> + integer maxsize ) { <nl> + final quser quser = quser . user ; <nl> + final qrelationship qrelationship = qrelationship . relationship ; <nl>  <nl> - return entitymanager <nl> - . createquery ( query ) <nl> - . setmaxresults ( optional . ofnullable ( maxsize ) . orelse ( 20 ) ) <nl> - . getresultlist ( ) ; <nl> + final jpqlquery & lt ; relationship & gt ; relationshipsubquery = jpaexpressions . selectfrom ( qrelationship ) <nl> + . where ( qrelationship . follower . eq ( user ) <nl> + . and ( qrelationship . followed . eq ( quser ) ) <nl> + ) ; <nl> + return queryfactory . selectfrom ( quser ) <nl> + . where ( relationshipsubquery . exists ( ) <nl> + . and ( sinceid . map ( quser . id : : gt ) . orelse ( null ) ) <nl> + . and ( maxid . map ( quser . id : : lt ) . orelse ( null ) ) <nl> + ) <nl> + . orderby ( quser . id . desc ( ) ) <nl> + . limit ( optional . ofnullable ( maxsize ) . orelse ( 20 ) ) <nl> + . fetch ( ) ; <nl> } <nl> 
mmm a / src / main / java / org / roaringbitmap / runcontainer . java <nl> ppp b / src / main / java / org / roaringbitmap / runcontainer . java <nl> + int start = 0 ; <nl> + for ( int rlepos = 0 ; rlepos & lt ; this . nbrruns ; ++rlepos ) { <nl> + int end = util . tointunsigned ( this . getvalue ( rlepos ) ) ; <nl> + int prevones = util . cardinalityinbitmaprange ( answer . bitmap , start , end ) ; <nl> util . resetbitmaprange ( answer . bitmap , start , end ) ; /  / had been x . bitmap <nl> + answer . updatecardinality ( prevones , 0 ) ; <nl> start = end + util . tointunsigned ( this . getlength ( rlepos ) ) + 1 ; <nl> } <nl> - util . resetbitmaprange ( answer . bitmap , start , util . maxlowbitasinteger ( ) + 1 ) ; /  / had been x . bitmap <nl> - answer . computecardinality ( ) ; <nl> + int ones = util . cardinalityinbitmaprange ( answer . bitmap , start , bitmapcontainer . max_capacity ) ; <nl> + util . resetbitmaprange ( answer . bitmap , start , bitmapcontainer . max_capacity ) ; /  / had been x . bitmap <nl> + answer . updatecardinality ( ones , 0 ) ; <nl> if ( answer . getcardinality ( ) & gt ; arraycontainer . default_max_size ) { <nl> return answer ; <nl> 
mmm a / src / peergos / shared / crypto / asymmetric / curve25519 / ed25519secretkey . java <nl> ppp b / src / peergos / shared / crypto / asymmetric / curve25519 / ed25519secretkey . java <nl> @ override <nl> public cborobject tocbor ( ) { <nl> - map & lt ; string , cborobject & gt ; cbor = new treemap & lt ; & gt ; ( ) ; <nl> - cbor . put ( " t " , new cborobject . cborlong ( type ( ) . value ) ) ; <nl> - cbor . put ( " k " , new cborobject . cborbytearray ( secretkey ) ) ; <nl> - return cborobject . cbormap . build ( cbor ) ; <nl> + return new cborobject . cborlist ( arrays . aslist ( new cborobject . cborlong ( type ( ) . value ) , new cborobject . cborbytearray ( secretkey ) ) ) ; <nl> } <nl>  <nl> public byte [ ] signmessage ( byte [ ] message ) { <nl> 
mmm a / forge111 / src / main / java / com / boydti / fawe / forge / v111 / forgequeue_all . java <nl> ppp b / forge111 / src / main / java / com / boydti / fawe / forge / v111 / forgequeue_all . java <nl> @ override <nl> - public chunk getchunk ( world world , int x , int z ) { <nl> - chunk chunk = world . getchunkprovider ( ) . providechunk ( x , z ) ; <nl> - if ( chunk ! = null & & ! chunk . isloaded ( ) ) { <nl> - chunk . onchunkload ( ) ; <nl> - } <nl> - return chunk ; <nl> + public chunk getcachedchunk ( world world , int cx , int cz ) { <nl> + return world . getchunkprovider ( ) . getloadedchunk ( cx , cz ) ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / sdk / com . ibm . sbt . core / src / main / java / com / ibm / sbt / services / client / connections / profiles / profileservice . java <nl> ppp b / sdk / com . ibm . sbt . core / src / main / java / com / ibm / sbt / services / client / connections / profiles / profileservice . java <nl> + } <nl> + <nl> protected entitylist & lt ; colleagueconnection & gt ; getcolleagueconnectionentitylist ( string requesturl , map & lt ; string , string & gt ; parameters ) throws clientservicesexception { <nl> - colleagueconnection result = null ; <nl> - ifeedhandler & lt ; colleagueconnection & gt ; handler = getcolleaguefeedhandler ( ) ; <nl> - <nl> - response response = getclientservice ( ) . get ( requesturl , parameters ) ; <nl> - <nl> - try { <nl> - checkresponsecode ( response , httpcode . ok ) ; <nl> - result = handler . createentity ( response ) ; <nl> - } catch ( clientservicesexception cse ) { <nl> - checkresponsecode ( response , httpcode . not_found ) ; <nl> - } <nl> - <nl> - return result ; <nl> + return getentities ( requesturl , parameters , getcolleaguefeedhandler ( ) ) ; <nl> } <nl>  <nl> protected entitylist & lt ; tag & gt ; gettagentitylist ( string requesturl , map & lt ; string , string & gt ; parameters ) throws clientservicesexception { <nl> 
mmm a / src / main / java / jp / classmethod / aws / gradle / cloudformation / amazoncloudformationmigratestacktask . java <nl> ppp b / src / main / java / jp / classmethod / aws / gradle / cloudformation / amazoncloudformationmigratestacktask . java <nl> + private void createstack ( amazoncloudformation cfn ) throws ioexception { <nl> + string stackname = getstackname ( ) ; <nl> + string cfntemplateurl = getcfntemplateurl ( ) ; <nl> + list & lt ; parameter & gt ; cfnstackparams = getcfnstackparams ( ) ; <nl> + list & lt ; tag & gt ; cfnstacktags = getcfnstacktags ( ) ; <nl> + string cfnstackpolicyurl = getcfnstackpolicyurl ( ) ; <nl> + file cfntemplatefile = getcfntemplatefile ( ) ; <nl> + file cfnstackpolicyfile = getcfnstackpolicyfile ( ) ; <nl> + string cfnonfailure = getcfnonfailure ( ) ; <nl> + <nl> getlogger ( ) . info ( " create stack : { } " , stackname ) ; <nl>  <nl> createstackrequest req = new createstackrequest ( ) <nl> . withstackname ( stackname ) <nl> - . withtemplateurl ( cfntemplateurl ) <nl> . withparameters ( cfnstackparams ) <nl> - . withtags ( cfnstacktags ) ; <nl> + . withtags ( cfnstacktags ) <nl> + . withonfailure ( cfnonfailure ) ; <nl> + <nl> + if ( strings . isnullorempty ( cfntemplateurl ) == false ) { <nl> + req . settemplateurl ( cfntemplateurl ) ; <nl> + } else { <nl> + req . settemplatebody ( fileutils . readfiletostring ( cfntemplatefile ) ) ; <nl> + } <nl> if ( iscapabilityiam ( ) ) { <nl> + req . setcapabilities ( arrays . aslist ( capability . capability_iam . tostring ( ) ) ) ; <nl> 
mmm a / kubernetes - client / src / main / java / io / fabric8 / kubernetes / client / dsl / internal / replicasetoperationsimpl . java <nl> ppp b / kubernetes - client / src / main / java / io / fabric8 / kubernetes / client / dsl / internal / replicasetoperationsimpl . java <nl> return rs ; <nl> } <nl>  <nl> - final countdownlatch latch = new countdownlatch ( 1 ) ; <nl> - watcher & lt ; replicaset & gt ; watcher = new readinesswatcher & lt ; & gt ; ( latch ) ; <nl> + readinesswatcher & lt ; replicaset & gt ; watcher = new readinesswatcher & lt ; & gt ; ( rs . getkind ( ) , getname ( ) , getnamespace ( ) ) ; <nl> try ( watch watch = watch ( watcher ) ) { <nl> - if ( latch . await ( amount , timeunit ) ) { <nl> - return get ( ) ; <nl> - } <nl> + return watcher . await ( amount , timeunit ) ; <nl> } <nl> - throw new kubernetesclienttimeoutexception ( rs . getkind ( ) , getname ( ) , getnamespace ( ) , amount , timeunit ) ; <nl> } <nl> - <nl> - private static class replicasetreaper implements reaper { <nl> 
mmm a / src / test / java / org / passay / illegalcharacterruletest . java <nl> ppp b / src / test / java / org / passay / illegalcharacterruletest . java <nl> return <nl> new object [ ] [ ] { <nl>  <nl> - { rule , new passworddata ( valid_pass ) , null , } , <nl> + { new illegalcharacterrule ( new char [ ] { ' @ ' , ' $ ' } ) , new passworddata ( " aycdpdsyz " ) , null , } , <nl> { <nl> - rule , <nl> - new passworddata ( invalid_pass ) , <nl> + new illegalcharacterrule ( new char [ ] { ' @ ' , ' $ ' } ) , <nl> + new passworddata ( " aycd @ pdsyz " ) , <nl> codes ( illegalcharacterrule . error_code ) , <nl> } , <nl> + { <nl> + new illegalcharacterrule ( new char [ ] { ' @ ' , ' $ ' } ) , <nl> + new passworddata ( " aycd @ pd $ yz " ) , <nl> + codes ( illegalcharacterrule . error_code , illegalcharacterrule . error_code ) , <nl> + } , <nl> + { <nl> + new illegalcharacterrule ( new char [ ] { ' @ ' , ' $ ' } , false ) , <nl> + new passworddata ( " aycd @ pd $ yz " ) , <nl> + codes ( illegalcharacterrule . error_code ) , <nl> + } , <nl> + { <nl> + new illegalcharacterrule ( new char [ ] { ' @ ' , ' $ ' } ) , <nl> + new passworddata ( " aycd @ pd $ yz @ " ) , <nl> + codes ( illegalcharacterrule . error_code , illegalcharacterrule . error_code ) , <nl> + } , <nl> } ; <nl> } <nl> 
mmm a / api / api - agi / src / main / java / org / astivetoolkit / agi / fastagi / fastagiresponse . java <nl> ppp b / api / api - agi / src / main / java / org / astivetoolkit / agi / fastagi / fastagiresponse . java <nl> throws agiexception { <nl> sayalpha command = new sayalpha ( text ) ; <nl>  <nl> - return chandler . sendagicommand ( command ) . getresultcodeaschar ( ) ; <nl> + agicommandreply acr = chandler . sendagicommand ( command ) ; <nl> + <nl> + if ( acr . getresultcode ( ) == - 1 ) { <nl> + throw new agiexception ( applocale . geti18n ( " errorchannelerrorordisconnected " ) ) ; <nl> + } <nl> + <nl> + return acr . getresultcodeaschar ( ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / user / super / com / google / gwt / emul / java / util / arrays . java <nl> ppp b / user / super / com / google / gwt / emul / java / util / arrays . java <nl> + return copyprimitivearray ( original , new boolean [ to - from ] , from , to ) ; <nl> } <nl>  <nl> public static byte [ ] copyofrange ( byte [ ] original , int from , int to ) { <nl> - int len = getcopylength ( original , from , to ) ; <nl> - byte [ ] copy = new byte [ to - from ] ; <nl> - arrayhelper . copy ( original , from , copy , 0 , len ) ; <nl> - return copy ; <nl> + checkcopyofrange ( original , from , to ) ; <nl> + return copyprimitivearray ( original , new byte [ to - from ] , from , to ) ; <nl> } <nl>  <nl> public static char [ ] copyofrange ( char [ ] original , int from , int to ) { <nl> 
mmm a / megamek / src / megamek / common / misctype . java <nl> ppp b / megamek / src / megamek / common / misctype . java <nl> - public static misctype createengineeringsuitinfarmor ( ) { <nl> + } <nl> + <nl> + public static misctype createisengineeringsuitinfarmor ( ) { <nl> misctype misc = new misctype ( ) ; <nl>  <nl> - misc . techlevel . put ( 3071 , techconstants . t_all ) ; <nl> misc . name = " engineering suit " ; <nl> misc . setinternalname ( misc . name ) ; <nl> - misc . addlookupname ( " engineeringsuit " ) ; <nl> + misc . addlookupname ( " isengineeringsuit " ) ; <nl> misc . damagedivisor = 1 . 0 ; <nl> misc . subtype = s_encumbering | s_space_suit ; <nl> misc . cost = 7500 ; <nl> - misc . availrating = new int [ ] { equipmenttype . rating_d , equipmenttype . rating_d , equipmenttype . rating_d } ; <nl> misc . flags = misc . flags . or ( f_inf_equipment ) . or ( f_armor_kit ) ; <nl> - misc . introdate = 2350 ; <nl> - misc . techlevel . put ( 2350 , misc . techlevel . get ( 3071 ) ) ; <nl> + misc . introdate = 2335 ; <nl> + misc . techlevel . put ( 2335 , techconstants . t_is_experimental ) ; <nl> + misc . techlevel . put ( 2350 , techconstants . t_is_advanced ) ; <nl> + misc . techlevel . put ( 2351 , techconstants . t_is_tw_non_box ) ; <nl> + misc . availrating = new int [ ] { rating_d , rating_d , rating_d , rating_c } ; <nl> misc . techrating = rating_d ; <nl> - <nl> - return misc ; <nl> + misc . rulesrefs = " 317 , to " ; <nl> 
mmm a / auto - project / auto - ui / src / main / java / jp / primecloud / auto / ui / winloadbalanceradd . java <nl> ppp b / auto - project / auto - ui / src / main / java / jp / primecloud / auto / ui / winloadbalanceradd . java <nl> - } <nl> + private void loaddata ( ) { <nl> + loadbalancerservice loadbalancerservice = beancontext . getbean ( loadbalancerservice . class ) ; <nl> + platforms = loadbalancerservice . getplatforms ( viewcontext . getuserno ( ) ) ; <nl>  <nl> - private void initdata ( ) { <nl> - long userno = viewcontext . getuserno ( ) ; <nl> - long farmno = viewcontext . getfarmno ( ) ; <nl> - <nl> + for ( int i = platforms . size ( ) - 1 ; i & gt ; = 0 ; i -  - ) { <nl> + if ( booleanutils . isnottrue ( platforms . get ( i ) . getplatform ( ) . getselectable ( ) ) ) { <nl> + platforms . remove ( i ) ; <nl> + } <nl> + } <nl> 
mmm a / openid - connect - server / src / main / java / org / mitre / openid / connect / view / userinfojwtview . java <nl> ppp b / openid - connect - server / src / main / java / org / mitre / openid / connect / view / userinfojwtview . java <nl> - jwtclaimsset claims = jwtclaimsset . parse ( writer . tostring ( ) ) ; <nl> - <nl> - claims . setaudience ( lists . newarraylist ( client . getclientid ( ) ) ) ; <nl> - <nl> - claims . setissuer ( config . getissuer ( ) ) ; <nl> - <nl> - claims . setissuetime ( new date ( ) ) ; <nl> - <nl> - claims . setjwtid ( uuid . randomuuid ( ) . tostring ( ) ) ; /  / set a random nonce in the middle of it <nl> + response . setcontenttype ( jose_media_type_value ) ; <nl> + <nl> + jwtclaimsset claims = new jwtclaimsset . builder ( jwtclaimsset . parse ( writer . tostring ( ) ) ) <nl> + . audience ( lists . newarraylist ( client . getclientid ( ) ) ) <nl> + . issuer ( config . getissuer ( ) ) <nl> + . issuetime ( new date ( ) ) <nl> + . jwtid ( uuid . randomuuid ( ) . tostring ( ) ) /  / set a random nonce in the middle of it <nl> + . build ( ) ; <nl>  <nl>  <nl> if ( client . getuserinfoencryptedresponsealg ( ) ! = null & & ! client . getuserinfoencryptedresponsealg ( ) . equals ( algorithm . none ) <nl> 
mmm a / eventstore / src / test / java / no / ks / eventstore2 / projection / projectionmanagertest . java <nl> ppp b / eventstore / src / test / java / no / ks / eventstore2 / projection / projectionmanagertest . java <nl> - @ test <nl> public void testprojectionmanagercreatesprojections ( ) throws exception { <nl>  <nl> - final actorref eventstore = super . testactor ( ) ; <nl> + list & lt ; props & gt ; factories = new arraylist & lt ; & gt ; ( ) ; <nl> + factories . add ( props . create ( formstatuses . class , super . testactor ( ) ) ) ; <nl>  <nl> - projectionfactory projectionfactory = new projectionfactory ( eventstore ) { <nl> - @ override <nl> - public class & lt ; ? extends projection & gt ; getprojectionclass ( ) { <nl> - return formstatuses . class ; <nl> - } <nl> - <nl> - public actor create ( ) throws exception { <nl> - return new formstatuses ( eventstore ) ; <nl> - } <nl> - } ; <nl> - <nl> - list & lt ; projectionfactory & gt ; factories = new arraylist & lt ; projectionfactory & gt ; ( ) ; <nl> - factories . add ( projectionfactory ) ; <nl> - <nl> - final testactorref & lt ; projectionmanager & gt ; ref = testactorref . create ( _system , new props ( new projectionmanagerfactory ( factories , super . testactor ( ) ) ) , " projectionmanager " ) ; <nl> + final testactorref & lt ; projectionmanager & gt ; ref = testactorref . create ( _system , projectionmanager . mkprops ( super . testactor ( ) , factories ) , " projectionmanager " ) ; <nl>  <nl> future & lt ; object & gt ; getprojectionref = ask ( ref , call ( " getprojectionref " , formstatuses . class ) , 3000 ) ; <nl> 
mmm a / soulissapp / src / main / java / it / angelic / soulissclient / addprogramactivity . java <nl> ppp b / soulissapp / src / main / java / it / angelic / soulissclient / addprogramactivity . java <nl> - spinnerarrval = getresources ( ) . getintarray ( r . array . scheduleintervalvalues ) ; <nl> - imageview nodeic = ( imageview ) findviewbyid ( r . id . timed_icon ) ; <nl> - tvcommand = ( textview ) findviewbyid ( r . id . textviewcommand ) ; <nl> - nodeic . setcolorfilter ( getresources ( ) . getcolor ( r . color . aa_violet ) , android . graphics . porterduff . mode . src_atop ) ; <nl> - <nl> - imageview nodeic2 = ( imageview ) findviewbyid ( r . id . position_icon ) ; <nl> - nodeic2 . setcolorfilter ( getresources ( ) . getcolor ( r . color . aa_blue ) , android . graphics . porterduff . mode . src_atop ) ; <nl> - <nl> - imageview nodeic3 = ( imageview ) findviewbyid ( r . id . triggered_icon ) ; <nl> - nodeic3 . setcolorfilter ( getresources ( ) . getcolor ( r . color . aa_red ) , android . graphics . porterduff . mode . src_atop ) ; <nl> + fontawesomeutil . preparefontawetextview ( addprogramactivity . this , nodeic2 , fontawesomeenum . fa_sign_out . getfontname ( ) ) ; <nl> + textview nodeic3 = ( textview ) findviewbyid ( r . id . triggered_icon ) ; <nl> + nodeic3 . settextcolor ( contextcompat . getcolor ( addprogramactivity . this , r . color . md_light_blue_900 ) ) ; <nl> + fontawesomeutil . preparefontawetextview ( addprogramactivity . this , nodeic3 , fontawesomeenum . fa_puzzle_piece . getfontname ( ) ) ; <nl>  <nl> list & lt ; soulissnode & gt ; goer = datasource . getallnodes ( ) ; <nl> 
mmm a / main / src / main / java / de / learnlib / alex / rest / counterresource . java <nl> ppp b / main / src / main / java / de / learnlib / alex / rest / counterresource . java <nl> user user = ( ( userprincipal ) securitycontext . getuserprincipal ( ) ) . getuser ( ) ; <nl> logger . traceentry ( " deletecounter ( { } , { } ) for user { } . " , projectid , names , user ) ; <nl>  <nl> - try { <nl> - counterdao . delete ( user . getid ( ) , projectid , names . toarray ( new string [ names . size ( ) ] ) ) ; <nl> + counterdao . delete ( user . getid ( ) , projectid , names . toarray ( new string [ names . size ( ) ] ) ) ; <nl>  <nl> - logger . traceexit ( " counter ( s ) { } deleted . " , names ) ; <nl> - return response . status ( response . status . no_content ) . build ( ) ; <nl> - } catch ( notfoundexception e ) { <nl> - logger . traceexit ( e ) ; <nl> - return resourceerrorhandler . createresterrormessage ( " counterresource . deletecounter " , <nl> - response . status . not_found , <nl> - e ) ; <nl> - } <nl> + logger . traceexit ( " counter ( s ) { } deleted . " , names ) ; <nl> + return response . status ( response . status . no_content ) . build ( ) ; <nl>  <nl> } <nl> 
mmm a / src / me / ryanhamshire / griefprevention / listener / playereventhandler . java <nl> ppp b / src / me / ryanhamshire / griefprevention / listener / playereventhandler . java <nl> final gpplayerdata playerdata = this . datastore . getorcreateplayerdata ( location . getextent ( ) , player . getuniqueid ( ) ) ; <nl> final gpclaim claim = this . datastore . getclaimatplayer ( playerdata , location , false ) ; <nl>  <nl> - if ( gppermissionhandler . getflagoverride ( claim , gppermissions . interact_block_primary , player , clickedblock . getstate ( ) ) == tristate . false ) { <nl> + tristate override = gppermissionhandler . getflagoverride ( claim , gppermissions . interact_block_primary , player , clickedblock . getstate ( ) ) ; <nl> + if ( override ! = tristate . undefined ) { <nl> + if ( override == tristate . true ) { <nl> + gptimings . player_interact_block_primary_event . stoptimingifsync ( ) ; <nl> + return ; <nl> + } <nl> + <nl> event . setcancelled ( true ) ; <nl> - gptimings . player_interact_block_primary_event . stoptimingifsync ( ) ; <nl> griefpreventionplugin . addeventlogentry ( event , claim , location , gppermissions . interact_block_primary , player , clickedblock . getstate ( ) , player , " " ) ; <nl> + gptimings . player_interact_block_primary_event . stoptimingifsync ( ) ; <nl> return ; <nl> } <nl> 
mmm a / optaplanner - core / src / test / java / org / optaplanner / core / api / score / buildin / hardmediumsoft / hardmediumsoftscoreholdertest . java <nl> ppp b / optaplanner - core / src / test / java / org / optaplanner / core / api / score / buildin / hardmediumsoft / hardmediumsoftscoreholdertest . java <nl> - scoreholder . addsoftconstraintmatch ( mockrulecontext ( " scorerule4 " ) , - 4 ) ; <nl> + scoreholder . addsoftconstraintmatch ( soft1 , - 100 ) ; <nl> + scoreholder . addsoftconstraintmatch ( soft1 , - 300 ) ; /  / overwrite existing <nl>  <nl> - rulecontext rulecontext5 = mockrulecontext ( " scorerule5 " ) ; <nl> - scoreholder . addhardconstraintmatch ( rulecontext5 , - 1 ) ; <nl> - scoreholder . addsoftconstraintmatch ( rulecontext5 , - 1 ) ; /  / different score level <nl> - callunmatch ( rulecontext5 ) ; <nl> + rulecontext multi1 = mockrulecontext ( " multi1 " ) ; <nl> + scoreholder . addmulticonstraintmatch ( multi1 , - 1000 , - 10000 , - 100000 ) ; <nl> + scoreholder . addmulticonstraintmatch ( multi1 , - 4000 , - 50000 , - 600000 ) ; /  / overwrite existing <nl> + <nl> + rulecontext hard3 = mockrulecontext ( " hard3 " ) ; <nl> + scoreholder . addhardconstraintmatch ( hard3 , - 1000000 ) ; <nl> + scoreholder . addhardconstraintmatch ( hard3 , - 7000000 ) ; /  / overwrite existing <nl> + <nl> + rulecontext soft2undo = mockrulecontext ( " soft2undo " ) ; <nl> + scoreholder . addsoftconstraintmatch ( soft2undo , - 99 ) ; <nl> + callunmatch ( soft2undo ) ; <nl> + <nl> + rulecontext multi2undo = mockrulecontext ( " multi2undo " ) ; <nl> + scoreholder . addmulticonstraintmatch ( multi2undo , - 999 , - 999 , - 999 ) ; <nl> + callunmatch ( multi2undo ) ; <nl> + <nl> + rulecontext medium2undo = mockrulecontext ( " medium2undo " ) ; <nl> + scoreholder . addmediumconstraintmatch ( medium2undo , - 9999 ) ; <nl> 
mmm a / org . eclipse . january / src / org / eclipse / january / dataset / abstractcompounddataset . java <nl> ppp b / org . eclipse . january / src / org / eclipse / january / dataset / abstractcompounddataset . java <nl> + return es ; <nl> } <nl>  <nl> private double [ ] getinternalerrorarray ( final boolean squared , final int .  .  . pos ) { <nl> - dataset sed = squared ? getinternalsquarederror ( ) : getinternalerror ( ) ; <nl> + dataset sed = getinternalerror ( squared ) ; <nl> if ( sed == null ) <nl> return null ; <nl>  <nl> - broadcaststride bs = ( broadcaststride ) getstoredvalue ( store_broadcast ) ; <nl> - int n = bs . get1dindex ( pos ) ; <nl> double [ ] es = new double [ isize ] ; <nl> if ( sed instanceof compounddoubledataset ) { <nl> - ( ( compounddoubledataset ) sed ) . getdoublearrayabs ( n , es ) ; <nl> + es = ( ( compounddoubledataset ) sed ) . getdoublearray ( pos ) ; <nl> if ( sed . getelementsperitem ( ) ! = isize ) { /  / ensure error is broadcasted <nl> arrays . fill ( es , es [ 0 ] ) ; <nl> } <nl> 
mmm a / app / src / main / java / tech / ozak / sportmix / fragment / sabahfragment . java <nl> ppp b / app / src / main / java / tech / ozak / sportmix / fragment / sabahfragment . java <nl> private void fillthedata ( ) { <nl> listactivity splashactivity = listactivity . getinstance ( ) ; <nl> - if ( ! splashactivity . getrssitems ( ) . equals ( collections . empty_list ) ) { <nl> + if ( splashactivity . getrssitems ( ) ! =null & & splashactivity . getrssitems ( ) . size ( ) & gt ; 0 ) { <nl> rssitems . addall ( splashactivity . getrssitems ( ) ) ; <nl>  <nl> listview listview = ( listview ) v . findviewbyid ( r . id . postlistview ) ; <nl> + <nl> + itemadapter = new postitemadapter ( getactivity ( ) , <nl> + r . layout . postitem , rssitems ) ; <nl> + <nl> + <nl> + swingbottominanimationadapter swingbottominanimationadapter = new swingbottominanimationadapter ( itemadapter ) ; <nl> + <nl> + swingbottominanimationadapter . setabslistview ( listview ) ; <nl> + <nl> + listview . setadapter ( swingbottominanimationadapter ) ; <nl> + swiperefreshlayout . setrefreshing ( false ) ; <nl> + } <nl> + else { <nl> + toast . maketext ( getactivity ( ) , " lã¼tfen diäer haber kaynaklarä±nä± inceleyiniz .  .  . " , toast . length_long ) ; <nl> + } <nl> + } <nl> 
mmm a / sdk / src / main / java / com / silanis / esl / sdk / internal / converter / visibilityconverter . java <nl> ppp b / sdk / src / main / java / com / silanis / esl / sdk / internal / converter / visibilityconverter . java <nl> return sdkvisibility ; <nl> } <nl>  <nl> - visibility [ ] visibilities = visibility . values ( ) ; <nl> - for ( visibility visibility : visibilities ) { <nl> - if ( apivisibility . equals ( visibility . getapivalue ( ) ) ) { <nl> - return visibility ; <nl> - } <nl> + try { <nl> + return iterables . find ( arrays . aslist ( visibility . values ( ) ) , new predicate & lt ; visibility & gt ; ( ) { <nl> + public boolean apply ( visibility visibility ) { <nl> + return apivisibility . equals ( visibility . getapivalue ( ) ) ; <nl> + } <nl> + } ) ; <nl> + } catch ( nosuchelementexception e ) { <nl> + return visibility . unrecognized ( apivisibility ) ; <nl> } <nl> - return visibility . unrecognized ( apivisibility ) ; <nl> } <nl> - <nl> - public string toapivisibility ( ) { <nl> 
mmm a / nakadi - java - client / src / main / java / nakadi / okhttpresource . java <nl> ppp b / nakadi - java - client / src / main / java / nakadi / okhttpresource . java <nl> public & lt ; res & gt ; res requestthrowing ( string method , string url , resourceoptions options , <nl> class & lt ; res & gt ; res ) throws nakadiexception { <nl>  <nl> - if ( null == retrypolicy ) { <nl> - response response = requestthrowinginner ( method , url , options ) ; <nl> - return marshalresponse ( response , res ) ; <nl> - } else { <nl> - observable & lt ; response & gt ; observable = observable . defer ( <nl> - ( ) - & gt ; observable . just ( requestthrowinginner ( method , url , options ) ) <nl> - ) . compose ( buildretry ( retrypolicy ) ) ; <nl> + observable & lt ; response & gt ; observable = <nl> + observable . defer ( ( ) - & gt ; observable . just ( requestthrowinginner ( method , url , options ) ) ) ; <nl>  <nl> - response response = observable . toblocking ( ) . first ( ) ; <nl> - return marshalresponse ( response , res ) ; <nl> + response response = maybecomposeretrypolicy ( observable ) . toblocking ( ) . first ( ) ; <nl> + return marshalresponse ( response , res ) ; <nl> + } <nl> 
mmm a / compact - hash - map - java / compacthashmap . java <nl> ppp b / compact - hash - map - java / compacthashmap . java <nl> + throw new nullpointerexception ( ) ; <nl> if ( ! translator . iskeyinstance ( key ) ) <nl> return false ; <nl> - @ suppresswarnings ( " unchecked " ) <nl> - object chain = table [ getindex ( ( k ) key ) ] ; <nl> - if ( chain == null ) <nl> - return false ; <nl> - while ( true ) { <nl> - if ( chain instanceof byte [ ] ) <nl> - return equals ( key , ( byte [ ] ) chain ) ; <nl> - else { /  / chain instanceof node <nl> - node node = ( node ) chain ; <nl> - if ( equals ( key , node . object ) ) <nl> - return true ; <nl> - chain = node . next ; <nl> - } <nl> - } <nl> + return probe ( ( k ) key ) & gt ; = 0 ; <nl> } <nl> + <nl> + <nl> 
mmm a / src / main / java / com / net2plan / documentation / createhtmlkeywords . java <nl> ppp b / src / main / java / com / net2plan / documentation / createhtmlkeywords . java <nl> { <nl> final classdoc javaclass = classes [ i ] ; <nl> final string classname = javaclass . qualifiedname ( ) ; <nl> - final string firstsentencethisclass = javaclass . firstsentencetags ( ) [ 0 ] . text ( ) ; <nl> + final tag [ ] firstsentencetags = javaclass . firstsentencetags ( ) ; <nl> + if ( firstsentencetags . length == 0 ) system . out . println ( " a class without first sentence ! ! : " + classname ) ; <nl> + final string firstsentencethisclass = ( firstsentencetags . length == 0 ) ? " " : javaclass . firstsentencetags ( ) [ 0 ] . text ( ) ; <nl> algorithmtofirstsentence . put ( classname , firstsentencethisclass ) ; <nl> algorithmtokeywordsmap . put ( classname , new linkedlist & lt ; string & gt ; ( ) ) ; <nl> string keywordsstring = " " ; for ( tag tag : javaclass . tags ( ) ) { if ( tag . name ( ) . equals ( " @ " +tagname ) ) keywordsstring += " " + tag . text ( ) + " " ; } <nl> 
mmm a / single - module / src / main / java / net / chrisrichardson / eventstore / examples / todolist / queryside / todoqueryservice . java <nl> ppp b / single - module / src / main / java / net / chrisrichardson / eventstore / examples / todolist / queryside / todoqueryservice . java <nl> } <nl>  <nl> - public optional & lt ; todo & gt ; findbyid ( string id ) { <nl> - return optional . of ( repository . findone ( id ) ) ; <nl> + public completablefuture & lt ; todo & gt ; findbyid ( string todoid ) { <nl> + todo res = repository . findone ( todoid ) ; <nl> + if ( res ! = null ) { <nl> + return completablefuture . completedfuture ( res ) ; <nl> + } <nl> + return completablefutureutil . failedfuture ( new nosuchelementexception ( " no todo with given id found " ) ) ; <nl> } <nl> - <nl> - public observable & lt ; todo & gt ; findbyid ( entityidentifier todoid ) { <nl> 
mmm a / hazelcast - hibernate3 / src / main / java / com / hazelcast / hibernate / instance / hazelcastinstancefactory . java <nl> ppp b / hazelcast - hibernate3 / src / main / java / com / hazelcast / hibernate / instance / hazelcastinstancefactory . java <nl> - } <nl> - <nl> - private static class getinstanceloaderclass ( properties props , boolean usenativeclient ) throws classnotfoundexception { <nl> - if ( props ! = null ) { <nl> - usenativeclient = cacheenvironment . isnativeclient ( props ) ; <nl> - } <nl> - class loaderclass = null ; <nl> + private static class getinstanceloaderclass ( properties props ) throws classnotfoundexception { <nl> classloader cl = hazelcastinstancefactory . class . getclassloader ( ) ; <nl> - if ( usenativeclient ) { <nl> - loaderclass = cl . loadclass ( hz_client_loader_classname ) ; <nl> + if ( props ! = null & & cacheenvironment . isnativeclient ( props ) ) { <nl> + return cl . loadclass ( hz_client_loader_classname ) ; <nl> } else { <nl> - loaderclass = cl . loadclass ( hz_instance_loader_classname ) ; <nl> + return cl . loadclass ( hz_instance_loader_classname ) ; <nl> } <nl> - return loaderclass ; <nl> } <nl> } <nl> 
mmm a / ctk - transport / src / main / java / org / ga4gh / ctk / transport / protocols / client . java <nl> ppp b / ctk - transport / src / main / java / org / ga4gh / ctk / transport / protocols / client . java <nl> - @ override <nl> - public searchphenotypeassociationsetsresponse searchphenotypeassociationsets ( searchphenotypeassociationsetsrequest request ) throws avroremoteexception , gaexception { <nl> - string path = urls . getsearchphenotypeassociationsets ( ) ; <nl> - searchphenotypeassociationsetsresponse response = new searchphenotypeassociationsetsresponse ( ) ; <nl> - final avrojson aj = <nl> - new avrojson & lt ; & gt ; ( request , response , urls . geturlroot ( ) , path , wiretracker ) ; <nl> - response = ( searchphenotypeassociationsetsresponse ) aj . dopostresp ( ) ; <nl> - return response ; <nl> + public searchphenotypeassociationsetsresponse searchphenotypeassociationsets ( searchphenotypeassociationsetsrequest request ) throws invalidprotocolbufferexception , gawrapperexception , unirestexception { <nl> + string path = urls . getphenotypes ( ) ; <nl> + searchphenotypeassociationsetsresponse . builder builder = searchphenotypeassociationsetsresponse . newbuilder ( ) ; <nl> + new post & lt ; & gt ; ( urls . geturlroot ( ) , path , request , builder , wiretracker ) . performquery ( ) ; <nl> + return builder . build ( ) ; <nl> } <nl> } <nl> + } <nl> 
mmm a / src / graphtea / extensions / reports / hamilton / hamiltonianpathextension . java <nl> ppp b / src / graphtea / extensions / reports / hamilton / hamiltonianpathextension . java <nl> + subgraph sg = new subgraph ( ) ; <nl> + <nl> hamiltoniancycle hc = new hamiltoniancycle ( ) ; <nl> double [ ] [ ] adj = g . getadjacencymatrix ( ) . getarray ( ) ; <nl> - int [ ] [ ] adjmatrix = new int [ g . getverticescount ( ) ] <nl> - [ g . getverticescount ( ) ] ; <nl> + int [ ] [ ] adjmatrix = utils . getbinarypattern ( adj , g . getverticescount ( ) ) ; <nl> + int [ ] path = hc . hamiltoncycle ( adjmatrix ) ; <nl>  <nl> - for ( int i=0 ; i & lt ; g . getverticescount ( ) ; i++ ) { <nl> - for ( int j=0 ; j & lt ; g . getverticescount ( ) ; j++ ) { <nl> - if ( adj [ i ] [ j ] == 0 ) adjmatrix [ i ] [ j ] =0 ; <nl> - else adjmatrix [ i ] [ j ] =1 ; <nl> - } <nl> - } <nl> + if ( path == null ) return sg ; <nl> 
mmm a / pax - logging - log4j2 / src / main / java / org / ops4j / pax / logging / log4j2 / internal / paxloggerimpl . java <nl> ppp b / pax - logging - log4j2 / src / main / java / org / ops4j / pax / logging / log4j2 / internal / paxloggerimpl . java <nl> + } <nl> + } <nl> + <nl> + public void trace ( string message , throwable t , string fqcn ) <nl> + { <nl> if ( istraceenabled ( ) ) <nl> { <nl> - setdelegatecontext ( ) ; <nl> - message msg = m_delegate . getmessagefactory ( ) . newmessage ( message ) ; <nl> - m_delegate . logmessage ( fqcn , level . trace , null , msg , t ) ; <nl> - cleardelegatecontext ( ) ; <nl> - m_service . handleevents ( m_bundle , null , logservice . log_debug , message , t ) ; <nl> + dolog ( level . trace , logservice . log_debug , fqcn , message , t ) ; <nl> } <nl> } <nl> 
mmm a / src / test / java / net / sf / oval / test / guard / prepostjavascripttest . java <nl> ppp b / src / test / java / net / sf / oval / test / guard / prepostjavascripttest . java <nl> + final guard guard = new guard ( ) ; <nl> + testguardaspect . aspectof ( ) . setguard ( guard ) ; <nl> + <nl> + final testtransaction t = new testtransaction ( ) ; <nl> + <nl> try <nl> { <nl> - t . increase1 ( new bigdecimal ( 1 ) ) ; <nl> + t . increase ( bigdecimal . valueof ( 1 ) ) ; <nl> fail ( ) ; <nl> } <nl> catch ( final constraintsviolatedexception ex ) <nl> assertequals ( ex . getconstraintviolations ( ) [ 0 ] . getmessage ( ) , " pre " ) ; <nl> } <nl>  <nl> + t . value = bigdecimal . valueof ( 2 ) ; <nl> try <nl> { <nl> - t . value = new bigdecimal ( 2 ) ; <nl> - t . increase1 ( null ) ; <nl> + t . increase ( null ) ; <nl> fail ( ) ; <nl> } <nl> catch ( final constraintsviolatedexception ex ) <nl> } <nl> try <nl> { <nl> - t . increase1 ( new bigdecimal ( 1 ) ) ; <nl> + t . increase ( bigdecimal . valueof ( 1 ) ) ; <nl> } <nl> catch ( final constraintsviolatedexception ex ) <nl> { <nl> 
mmm a / easyreport - web / src / main / java / com / easytoolsoft / easyreport / web / controller / metadata / confcontroller . java <nl> ppp b / easyreport - web / src / main / java / com / easytoolsoft / easyreport / web / controller / metadata / confcontroller . java <nl> @ requestmapping ( value = " / remove " ) <nl> - public jsonresult remove ( int id , httpservletrequest req ) { <nl> + public jsonresult remove ( int id ) { <nl> jsonresult & lt ; string & gt ; result = new jsonresult & lt ; & gt ; ( ) ; <nl> - try { <nl> - this . confservice . removebyid ( id ) ; <nl> - this . logsuccessresult ( result , string . format ( " å é¤é ? ç½®é¡¹ [ id : % s ] æ ? ä½æ ? å ! " , id ) , req ) ; <nl> - } catch ( exception ex ) { <nl> - result . setmsg ( string . format ( " å é¤é ? ç½®é¡¹ [ id : % s ] æ ? ä½å¤±è´¥ ! " , id ) ) ; <nl> - this . logexceptionresult ( result , ex , req ) ; <nl> - } <nl> + this . service . removebyid ( id ) ; <nl> return result ; <nl> } <nl> + } <nl> 
mmm a / src / main / java / org / pac4j / jax / rs / features / pac4jsecurityfeature . java <nl> ppp b / src / main / java / org / pac4j / jax / rs / features / pac4jsecurityfeature . java <nl> + " renewsession parameter in @ pac4jcallback is not expected to have more than one value " ) ; <nl> + } <nl> + <nl> + if ( cbann . skipresponse ( ) . length & gt ; 1 ) { <nl> + throw new illegalargumentexception ( <nl> + " skipresponse parameter in @ pac4jcallback is not expected to have more than one value " ) ; <nl> + } <nl> + <nl> + final callbackfilter filter = new callbackfilter ( request , config ) ; <nl> + <nl> filter . setmultiprofile ( cbann . multiprofile ( ) . length == 0 ? null : cbann . multiprofile ( ) [ 0 ] ) ; <nl> filter . setrenewsession ( cbann . renewsession ( ) . length == 0 ? null : cbann . renewsession ( ) [ 0 ] ) ; <nl> filter . setdefaulturl ( cbann . defaulturl ( ) . length == 0 ? null : cbann . defaulturl ( ) [ 0 ] ) ; <nl> - filter . setskipresponse ( cbann . skipresponse ( ) ) ; <nl> + filter . setskipresponse ( cbann . skipresponse ( ) . length == 0 ? null : cbann . skipresponse ( ) [ 0 ] ) ; <nl>  <nl> context . register ( filter ) ; <nl> } <nl> 
mmm a / src / main / java / io / mewbase / server / impl / connectionimpl . java <nl> ppp b / src / main / java / io / mewbase / server / impl / connectionimpl . java <nl> - @ override <nl> public void handlelistchannels ( bsonobject frame ) { <nl> checkcontext ( ) ; <nl> - if ( ! isauthorized ( protocol . list_channels_frame ) ) { <nl> - return ; <nl> - } <nl> - integer requestid = frame . getinteger ( protocol . request_request_id ) ; <nl> - if ( requestid == null ) { <nl> - missingfield ( protocol . request_request_id , protocol . list_channels_frame ) ; <nl> - return ; <nl> - } <nl> - bsonobject resp = new bsonobject ( ) ; <nl> - resp . put ( protocol . response_request_id , requestid ) ; <nl> - resp . put ( protocol . response_ok , true ) ; <nl> + <nl> + completablefuture & lt ; boolean & gt ; authorisedcf = user . isauthorised ( protocol . list_channels_frame ) ; <nl> + <nl> + consumer & lt ; bsonobject & gt ; frameconsumer = ( protocolframe ) - & gt ; { <nl> + integer requestid = protocolframe . getinteger ( protocol . request_request_id ) ; <nl> + if ( requestid == null ) { <nl> + missingfield ( protocol . request_request_id , protocol . list_channels_frame ) ; <nl> + return ; <nl> + } <nl> + bsonobject resp = new bsonobject ( ) ; <nl> + resp . put ( protocol . response_request_id , requestid ) ; <nl> + resp . put ( protocol . response_ok , true ) ; <nl> + bsonarray arr = new bsonarray ( server . listchannels ( ) ) ; <nl> + resp . put ( protocol . listchannels_channels , arr ) ; <nl> + writeresponse ( protocol . response_frame , resp ) ; <nl> + } ; <nl> + <nl> + authorisedcf . handle ( ( res , ex ) - & gt ; { <nl> + <nl> + handleframe ( frame , frameconsumer , res , ex ) ; <nl> + return null ; <nl> + } ) ; <nl> + } <nl> + <nl> + @ override <nl> 
mmm a / ff4j - store - elastic / src / test / java / org / ff4j / elastic / store / featurestoreelastictest . java <nl> ppp b / ff4j - store - elastic / src / test / java / org / ff4j / elastic / store / featurestoreelastictest . java <nl> @ beforeclass <nl> public static void setup ( ) { <nl> - server = embeddedelasticserver ( folder . getroot ( ) . getpath ( ) ) ; <nl> - server . start ( ) ; <nl> - clusterhealthresponse healths = server . client ( ) . admin ( ) . cluster ( ) . preparehealth ( ) . get ( ) ; <nl> - logger . info ( healths . tostring ( ) ) ; <nl> + server = embeddedelasticserver . builder ( ) /  / <nl> + . clustername ( " myintegrationclusterfeature " ) /  / <nl> + . datadirectory ( folder . getroot ( ) . getpath ( ) ) /  / <nl> + . health ( true ) /  / <nl> + . start ( ) ; <nl> } <nl>  <nl> @ afterclass <nl> 
mmm a / data / org . eclipse . birt . data . aggregation / src / org / eclipse / birt / data / aggregation / impl / totalmovingave . java <nl> ppp b / data / org . eclipse . birt . data . aggregation / src / org / eclipse / birt / data / aggregation / impl / totalmovingave . java <nl> - assert ( args . length & gt ; 1 ) ; <nl> - if ( args [ 0 ] ! = null & & args [ 1 ] ! = null ) <nl> - { <nl> - if ( calculator == null ) <nl> - { <nl> - calculator = calculatorfactory . getcalculator ( args [ 0 ] . getclass ( ) ) ; <nl> - } <nl> - try <nl> - { <nl> - if ( list . size ( ) == 0 ) <nl> - { <nl> - window = datatypeutil . tointeger ( args [ 1 ] ) . intvalue ( ) ; <nl> assert ( window & gt ; 0 ) ; <nl> } <nl> list . addlast ( args [ 0 ] ) ; <nl> - sum = calculator . add ( sum , args [ 0 ] ) ; <nl> + sum = calculator . add ( sum , calculator . gettypedobject ( args [ 0 ] ) ) ; <nl>  <nl> if ( list . size ( ) & gt ; window ) <nl> { <nl> 
mmm a / src / main / java / synapticloop / b2 / response / b2bucketresponse . java <nl> ppp b / src / main / java / synapticloop / b2 / response / b2bucketresponse . java <nl> - this . bucketname = response . optstring ( b2responseproperties . key_bucket_name , null ) ; <nl> - this . buckettype = response . optstring ( b2responseproperties . key_bucket_type , null ) ; <nl> + this . bucketname = this . readstring ( b2responseproperties . key_bucket_name ) ; <nl> + this . buckettype = this . readstring ( b2responseproperties . key_bucket_type ) ; <nl>  <nl> - if ( logger . iswarnenabled ( ) ) { <nl> - response . remove ( b2responseproperties . key_bucket_id ) ; <nl> - response . remove ( b2responseproperties . key_account_id ) ; <nl> - response . remove ( b2responseproperties . key_bucket_name ) ; <nl> - response . remove ( b2responseproperties . key_bucket_type ) ; <nl> - <nl> - warnonmissedkeys ( logger , response ) ; <nl> - } <nl> + this . warnonmissedkeys ( logger ) ; <nl> } <nl> + <nl> + / ** <nl> 
mmm a / src / main / java / com / fasterxml / jackson / databind / deser / impl / methodproperty . java <nl> ppp b / src / main / java / com / fasterxml / jackson / databind / deser / impl / methodproperty . java <nl> - public object deserializesetandreturn ( jsonparser p , <nl> deserializationcontext ctxt , object instance ) throws ioexception <nl> { <nl> - object value = deserialize ( p , ctxt ) ; <nl> + object value ; <nl> + if ( p . hastoken ( jsontoken . value_null ) ) { <nl> + if ( _skipnulls ) { <nl> + return instance ; <nl> + } <nl> + value = _nullprovider . getnullvalue ( ctxt ) ; <nl> + } else if ( _valuetypedeserializer == null ) { <nl> + value = _valuedeserializer . deserialize ( p , ctxt ) ; <nl> + } else { <nl> + value = _valuedeserializer . deserializewithtype ( p , ctxt , _valuetypedeserializer ) ; <nl> + } <nl> try { <nl> object result = _setter . invoke ( instance , value ) ; <nl> - return ( result == null ) ? instance : result ; <nl> 
mmm a / src / graphtea / extensions / reports / coloring / fillinaware / fillinawarecoloring . java <nl> ppp b / src / graphtea / extensions / reports / coloring / fillinaware / fillinawarecoloring . java <nl> - system . out . println ( " file : " + f . getabsolutepath ( ) ) ; <nl> matrix m = mm . loadmatrixfromsparse ( f ) ; <nl> spmat sm = new spmat ( m ) ; <nl> - generateresults ( ret , f , sm , " nat " , " nat " , 10 ) ; <nl> - generateresults ( ret , f , sm , " mindeg " , " mindeg " , 10 ) ; <nl> - generateresults ( ret , f , sm , " metis " , " metis " ,10 ) ; <nl> + int sizes [ ] = { 10 , sm . rows ( ) / 32 , sm . rows ( ) / 8 } ; <nl> + for ( int i=0 ; i & lt ; sizes . length ; i++ ) { <nl> + generateresults ( ret , f , sm , " nat " , " nat " , sizes [ i ] ) ; <nl> + generateresults ( ret , f , sm , " mindeg " , " mindeg " , sizes [ i ] ) ; <nl> + generateresults ( ret , f , sm , " metis " , " metis " , sizes [ i ] ) ; <nl> + generateresults ( ret , f , sm , " nat " , " nat " , sizes [ i ] ) ; <nl> + generateresults ( ret , f , sm , " metis " , " maxdeg " , sizes [ i ] ) ; <nl> + generateresults ( ret , f , sm , " nat " , " maxdeg " , sizes [ i ] ) ; <nl> + } <nl> } catch ( ioexception e ) { <nl> 
mmm a / tests / src / test / java / com / appnexus / opensdk / mediatedadviewcontrollertest . java <nl> ppp b / tests / src / test / java / com / appnexus / opensdk / mediatedadviewcontrollertest . java <nl> @ test <nl> public void test8standardthenmediated ( ) { <nl> - fakehttp . addpendinghttpresponse ( 200 , testresponses . banner ( ) ) ; <nl> - fakehttp . addpendinghttpresponse ( 200 , testresponses . mediatedsuccessfulbanner ( ) ) ; <nl> - fakehttp . addpendinghttpresponse ( 200 , testresponses . blank ( ) ) ; <nl> + server . enqueue ( new mockresponse ( ) . setresponsecode ( 200 ) . setbody ( testresponses . banner ( ) ) ) ; <nl> + server . enqueue ( new mockresponse ( ) . setresponsecode ( 200 ) . setbody ( testresponses . mediatedsuccessfulbanner ( ) ) ) ; <nl> + server . enqueue ( new mockresponse ( ) . setresponsecode ( 200 ) . setbody ( testresponses . blank ( ) ) ) ; <nl>  <nl> requestmanager . execute ( ) ; <nl> 
mmm a / demo / src / main / java / com / commonsware / cwac / cam2 / demo / mainactivity . java <nl> ppp b / demo / src / main / java / com / commonsware / cwac / cam2 / demo / mainactivity . java <nl> - } <nl> - <nl> private void capturelandscapeffc ( ) { <nl> - intent i=new cameraactivity . intentbuilder ( mainactivity . this ) <nl> - . skipconfirm ( ) <nl> - . facing ( facing . front ) <nl> - . facingexactmatch ( ) <nl> - . to ( new file ( testroot , " landscape - front . jpg " ) ) <nl> - . updatemediastore ( ) <nl> - . flashmodes ( flash_modes ) <nl> - . zoomstyle ( zoomstyle . seekbar ) <nl> - . debugsavepreviewframe ( ) <nl> - . debug ( ) <nl> - . build ( ) ; <nl> + intent i ; <nl> + <nl> + if ( isvideo ) { <nl> + i=new videorecorderactivity . intentbuilder ( mainactivity . this ) <nl> + . facing ( facing . front ) <nl> + . facingexactmatch ( ) <nl> + . to ( new file ( testroot , " landscape - front . mp4 " ) ) <nl> + . updatemediastore ( ) <nl> + . flashmodes ( flash_modes ) <nl> + . durationlimit ( 10000 ) <nl> + . debug ( ) <nl> + . build ( ) ; <nl> + } <nl> + else { <nl> + i=new cameraactivity . intentbuilder ( mainactivity . this ) <nl> + . skipconfirm ( ) <nl> + . facing ( facing . front ) <nl> + . facingexactmatch ( ) <nl> + . to ( new file ( testroot , " landscape - front . jpg " ) ) <nl> + . updatemediastore ( ) <nl> + . flashmodes ( flash_modes ) <nl> + . zoomstyle ( zoomstyle . seekbar ) <nl> + . debugsavepreviewframe ( ) <nl> + . debug ( ) <nl> + . build ( ) ; <nl> + } <nl>  <nl> startactivityforresult ( i , request_landscape_ffc ) ; <nl> } <nl> 
mmm a / server / src / test / java / timely / test / integration / onewaysslbase . java <nl> ppp b / server / src / test / java / timely / test / integration / onewaysslbase . java <nl> final miniaccumuloconfig macconfig = new miniaccumuloconfig ( temp . newfolder ( " mac " ) , " secret " ) ; <nl> mac = new miniaccumulocluster ( macconfig ) ; <nl> mac . start ( ) ; <nl> - conf = temp . newfile ( " config . properties " ) ; <nl> - testconfiguration config = testconfiguration . createminimalconfigurationfortest ( ) ; <nl> - config . put ( configuration . instance_name , mac . getinstancename ( ) ) ; <nl> - config . put ( configuration . zookeepers , mac . getzookeepers ( ) ) ; <nl> - setupssl ( config ) ; <nl> - config . toconfiguration ( conf ) ; <nl> + conf = testconfiguration . createminimalconfigurationfortest ( ) ; <nl> + conf . getaccumulo ( ) . setinstancename ( mac . getinstancename ( ) ) ; <nl> + conf . getaccumulo ( ) . setzookeepers ( mac . getzookeepers ( ) ) ; <nl> + setupssl ( conf ) ; <nl> } <nl> - <nl> - @ afterclass <nl> 
mmm a / jooby - metrics / src / test / java / org / jooby / metrics / metricstest . java <nl> ppp b / jooby - metrics / src / test / java / org / jooby / metrics / metricstest . java <nl> @ test <nl> public void metricinstance ( ) throws exception { <nl> new mockunit ( env . class , config . class , binder . class , metric . class ) <nl> - . expect ( newregistry ) <nl> + . expect ( newmetricregistry ) <nl> + . expect ( newhealthcheckregistry ) <nl> . expect ( mapbinderstatic ) <nl> . expect ( mapbinder ( metric . class , ( unit , binder ) - & gt ; { <nl> } ) ) <nl> . expect ( setbinder ( reporter . class , ( unit , binder ) - & gt ; { <nl>  <nl> } ) ) <nl> - . expect ( bindregistry ) <nl> - . expect ( bindregistryinitializer ) <nl> + . expect ( bindmetricregistry ) <nl> + . expect ( bindmetricregistryinitializer ) <nl> . expect ( bindhealthcheckregistry ) <nl> + . expect ( bindhealthcheckregistryinitializer ) <nl> . expect ( onstop ) <nl> . run ( unit - & gt ; { <nl> new metrics ( ) <nl> 
mmm a / src / android / com / mirasense / scanditsdk / plugin / phonegapparamparser . java <nl> ppp b / src / android / com / mirasense / scanditsdk / plugin / phonegapparamparser . java <nl> - if ( bundle . getserializable ( paramlandscapemargins ) ! = null <nl> & & bundle . getserializable ( paramlandscapemargins ) instanceof list ) { <nl> list & lt ; object & gt ; list = ( list & lt ; object & gt ; ) bundle . getserializable ( paramlandscapemargins ) ; <nl> - if ( list . size ( ) == 4 & & uiparamparser . checkclassoflistobjects ( list , integer . class ) ) { <nl> - landscapemargins = new rect ( ( integer ) list . get ( 0 ) , ( integer ) list . get ( 1 ) , <nl> - ( integer ) list . get ( 2 ) , ( integer ) list . get ( 3 ) ) ; <nl> + if ( list . size ( ) == 4 & & <nl> + ( uiparamparser . checkclassoflistobjects ( list , integer . class ) || <nl> + uiparamparser . checkclassoflistobjects ( list , string . class ) ) ) { <nl> + landscapemargins = new rect ( uiparamparser . getdp ( list . get ( 0 ) ) , uiparamparser . getdp ( list . get ( 1 ) ) , <nl> + uiparamparser . getdp ( list . get ( 2 ) ) , uiparamparser . getdp ( list . get ( 3 ) ) ) ; <nl> } <nl> } else if ( bundle . getstring ( paramlandscapemargins ) ! = null ) { <nl> string landscapemarginsstring = bundle . getstring ( paramlandscapemargins ) ; <nl> 
mmm a / src / java / main / com / topcoder / direct / services / view / action / project / projectworkmanagementaction . java <nl> ppp b / src / java / main / com / topcoder / direct / services / view / action / project / projectworkmanagementaction . java <nl> if ( closedphases . containskey ( projectphasetype . submission . tostring ( ) ) ) { <nl> - map & lt ; string , object & gt ; resultitem = new hashmap & lt ; string , object & gt ; ( ) ; <nl> - resultitem . put ( " id " , getcontestid ( ) + " : " + projectphasetype . final_fix . tostring ( ) ) ; <nl> - resultitem . put ( " label " , projectphasetype . final_fix . tostring ( ) ) ; <nl> - resultitem . put ( " type " , " phase " ) ; <nl> - result . add ( resultitem ) ; <nl> + result . add ( buildphaseresult ( getcontestid ( ) , projectphasetype . final_fix ) ) ; <nl> } <nl> } <nl> 
mmm a / src / main / java / org / graphity / processor / filter / response / hypermediafilter . java <nl> ppp b / src / main / java / org / graphity / processor / filter / response / hypermediafilter . java <nl> + public statebuilder getpagebuilder ( statebuilder sb , templatecall templatecall ) <nl> { <nl> - if ( resource == null ) throw new illegalargumentexception ( " resource can not be null " ) ; <nl> - <nl> - statebuilder sb = statebuilder . fromresource ( resource ) ; <nl> + if ( sb == null ) throw new illegalargumentexception ( " resource can not be null " ) ; <nl> + if ( templatecall == null ) throw new illegalargumentexception ( " templatecall can not be null " ) ; <nl>  <nl> - if ( offset ! = null ) sb . replaceproperty ( gp . offset , resource . getmodel ( ) . createtypedliteral ( offset ) ) ; <nl> - if ( limit ! = null ) sb . replaceproperty ( gp . limit , resource . getmodel ( ) . createtypedliteral ( limit ) ) ; <nl> - if ( orderby ! = null ) sb . replaceproperty ( gp . orderby , resource . getmodel ( ) . createtypedliteral ( orderby ) ) ; <nl> - if ( desc ! = null ) sb . replaceproperty ( gp . desc , resource . getmodel ( ) . createtypedliteral ( desc ) ) ; <nl> + if ( templatecall . hasproperty ( gp . offset ) ) sb . replaceproperty ( gp . offset , templatecall . getproperty ( gp . offset ) . getobject ( ) ) ; <nl> + if ( templatecall . hasproperty ( gp . limit ) ) sb . replaceproperty ( gp . limit , templatecall . getproperty ( gp . limit ) . getobject ( ) ) ; <nl> + if ( templatecall . hasproperty ( gp . orderby ) ) sb . replaceproperty ( gp . orderby , templatecall . getproperty ( gp . orderby ) . getobject ( ) ) ; <nl> + if ( templatecall . hasproperty ( gp . desc ) ) sb . replaceproperty ( gp . desc , templatecall . getproperty ( gp . desc ) . getobject ( ) ) ; <nl> 
mmm a / src / main / java / shadow / typecheck / errorreporter . java <nl> ppp b / src / main / java / shadow / typecheck / errorreporter . java <nl> * / <nl> public void addwarning ( node node , error warning , string message ) { <nl> - if ( node ! = null ) { <nl> - message = makemessage ( warning , message , node . getfile ( ) , node . getlinestart ( ) , <nl> - node . getlineend ( ) , node . getcolumnstart ( ) , node . getcolumnend ( ) ) ; <nl> - warninglist . add ( new typecheckexception ( warning , message ) ) ; <nl> - } <nl> - } <nl> + if ( node ! = null ) <nl> + warninglist . add ( new typecheckexception ( warning , message , node . getfile ( ) , node . getlinestart ( ) , <nl> + node . getlineend ( ) , node . getcolumnstart ( ) , node . getcolumnend ( ) ) ) ; <nl> + } <nl>  <nl> + / ** <nl> 
mmm a / src / main / java / com / openfin / desktop / demo / openfindockingdemo . java <nl> ppp b / src / main / java / com / openfin / desktop / demo / openfindockingdemo . java <nl> + * / <nl> public static void main ( string [ ] args ) { <nl> - if ( args . length & gt ; = 2 ) { <nl> - final string desktop_path = args [ 0 ] ; <nl> - final int port = integer . parseint ( args [ 1 ] ) ; <nl> - java . lang . system . out . println ( " starting demo : " + desktop_path + " " + port ) ; <nl> - string desktop_cmd_line = " " ; <nl> - if ( args . length & gt ; 2 ) { <nl> - for ( int i = 2 ; i & lt ; args . length ; i++ ) { <nl> - desktop_cmd_line += ( args [ i ] + " " ) ; <nl> - } <nl> - java . lang . system . out . println ( " passing desktop args : " + desktop_cmd_line ) ; <nl> - } <nl> - final string desktopcommandline = desktop_cmd_line ; <nl> - javax . swing . swingutilities . invokelater ( new runnable ( ) { <nl> - public void run ( ) { <nl> - createandshowgui ( desktop_path , desktopcommandline , port ) ; <nl> + final string desktop_option = java . lang . system . getproperty ( " openfinoption " ) ; <nl> + final string startupuuid ; <nl> + if ( java . lang . system . getproperty ( " startupuuid " ) ! = null ) { <nl> + startupuuid = java . lang . system . getproperty ( " startupuuid " ) ; <nl> + } else { <nl> + startupuuid = " openfinhelloworld " ; <nl> 
mmm a / src / main / java / io / vertx / ext / stomp / defaultnackhandler . java <nl> ppp b / src / main / java / io / vertx / ext / stomp / defaultnackhandler . java <nl> - sf . connection ( ) . close ( ) ; <nl> + connection . close ( ) ; <nl> return ; <nl> } else { <nl> - transaction . addframetotransaction ( sf . frame ( ) ) ; <nl> - frames . handlereceipt ( sf . frame ( ) , sf . connection ( ) ) ; <nl> + if ( ! transaction . addframetotransaction ( sf . frame ( ) ) ) { <nl> + frame errorframe = frames . createerrorframe ( " frame not added to transaction " , <nl> + headers . create ( frame . id , id , frame . transaction , txid ) , <nl> + " message delivery failed - the frame can not be added to the transaction - the number of allowed thread " + <nl> + " may have been reached " ) ; <nl> + connection . handler ( ) . unregistertransactionsfromconnection ( connection ) ; <nl> + connection . write ( errorframe ) ; <nl> + connection . close ( ) ; <nl> + return ; <nl> + } <nl> + frames . handlereceipt ( sf . frame ( ) , connection ) ; <nl> return ; <nl> 
mmm a / src / test / java / org / sonar / plugins / cobertura / coberturasensortest . java <nl> ppp b / src / test / java / org / sonar / plugins / cobertura / coberturasensortest . java <nl> - verify ( context , never ( ) ) . savemeasure ( eq ( interfaze ) , argthat ( new ismeasure ( coremetrics . coverage ) ) ) ; <nl> + verify ( newmeasure , never ( ) ) . formetric ( coremetrics . coverage ) ; <nl>  <nl> - verify ( context , never ( ) ) . savemeasure ( eq ( interfaze ) , argthat ( new ismeasure ( coremetrics . line_coverage ) ) ) ; <nl> - verify ( context , never ( ) ) . savemeasure ( eq ( interfaze ) , argthat ( new ismeasure ( coremetrics . lines_to_cover ) ) ) ; <nl> - verify ( context , never ( ) ) . savemeasure ( eq ( interfaze ) , argthat ( new ismeasure ( coremetrics . uncovered_lines ) ) ) ; <nl> + verify ( newmeasure , never ( ) ) . formetric ( coremetrics . line_coverage ) ; <nl> + verify ( newmeasure , never ( ) ) . formetric ( coremetrics . lines_to_cover ) ; <nl> + verify ( newmeasure , never ( ) ) . formetric ( coremetrics . uncovered_lines ) ; <nl>  <nl> - verify ( context , never ( ) ) . savemeasure ( eq ( interfaze ) , argthat ( new ismeasure ( coremetrics . branch_coverage ) ) ) ; <nl> - verify ( context , never ( ) ) . savemeasure ( eq ( interfaze ) , argthat ( new ismeasure ( coremetrics . conditions_to_cover ) ) ) ; <nl> + verify ( newmeasure , never ( ) ) . formetric ( coremetrics . branch_coverage ) ; <nl> + verify ( newmeasure , never ( ) ) . formetric ( coremetrics . conditions_to_cover ) ; <nl> 
mmm a / html_renderer / src / main / java / org / lobobrowser / html / domimpl / htmlmeterelementimpl . java <nl> ppp b / html_renderer / src / main / java / org / lobobrowser / html / domimpl / htmlmeterelementimpl . java <nl> * / <nl> @ override <nl> public double getoptimum ( ) { <nl> - try { <nl> - return integer . parseint ( this . getattribute ( htmlattributeproperties . optinum ) ) ; <nl> - } catch ( exception thrown ) { <nl> - logger . error ( " getsize ( ) : unable to parse size attribute in " + this + " . " , thrown ) ; <nl> - return 0 ; <nl> - } <nl> + string valuetext = this . getattribute ( htmlattributeproperties . optinum ) ; <nl> + return htmlvalues . getpixelsize ( valuetext , this . getrenderstate ( ) , 0 ) ; <nl> } <nl> + <nl> + / * <nl> 
mmm a / src / main / java / org / spongepowered / api / data / memorydataview . java <nl> ppp b / src / main / java / org / spongepowered / api / data / memorydataview . java <nl> @ override <nl> public optional & lt ; list & lt ; boolean & gt ; & gt ; getbooleanlist ( dataquery path ) { <nl> - optional & lt ; list & lt ; ? & gt ; & gt ; list = getunsafelist ( path ) ; <nl> - <nl> - if ( ! list . ispresent ( ) ) { <nl> - return optional . empty ( ) ; <nl> - } <nl> - <nl> - list & lt ; boolean & gt ; newlist = lists . newarraylist ( ) ; <nl> - <nl> - for ( object object : list . get ( ) ) { <nl> - optional & lt ; boolean & gt ; optional = coerce . asboolean ( object ) ; <nl> - if ( optional . ispresent ( ) ) { <nl> - newlist . add ( optional . get ( ) ) ; <nl> - } <nl> - } <nl> - return optional . of ( newlist ) ; <nl> + return getunsafelist ( path ) . map ( list - & gt ; <nl> + list . stream ( ) <nl> + . map ( coerce : : asboolean ) <nl> + . filter ( optional : : ispresent ) <nl> + . map ( optional : : get ) <nl> + . collect ( collectors . tolist ( ) ) <nl> + ) ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / geoserver / webapp / src / main / java / com / boundlessgeo / geoserver / api / controllers / iconcontroller . java <nl> ppp b / geoserver / webapp / src / main / java / com / boundlessgeo / geoserver / api / controllers / iconcontroller . java <nl> - @ requestmapping ( value = " / { wsname } / { icon : . + } " , method = requestmethod . get ) <nl> - public httpentity raw ( @ pathvariable string wsname , @ pathvariable string icon ) throws ioexception { <nl> - <nl> - workspaceinfo ws = findworkspace ( wsname , catalog ( ) ) ; <nl> - <nl> - geoserverresourceloader rl = geoserver . getcatalog ( ) . getresourceloader ( ) ; <nl> - resource resource = rl . get ( paths . path ( " workspaces " , ws . getname ( ) , " styles " , icon ) ) ; <nl> - <nl> + workspaceinfo ws ; <nl> + resource resource ; <nl> + <nl> + if ( wsname == null ) { <nl> + ws = null ; <nl> + resource = datadir ( ) . getroot ( " styles " , icon ) ; <nl> + } else { <nl> + ws = findworkspace ( wsname , catalog ( ) ) ; <nl> + resource = datadir ( ) . get ( ws , " styles " , icon ) ; <nl> + } <nl> + <nl> if ( resource . gettype ( ) ! = type . resource ) { <nl> - throw new notfoundexception ( " icon " +icon+ " not found " ) ; <nl> 
mmm a / src / main / java / hudson / plugins / clover / results / filecoverage . java <nl> ppp b / src / main / java / hudson / plugins / clover / results / filecoverage . java <nl> + } <nl> + <nl> public abstractclovermetrics getpreviousresult ( ) { <nl> - return null ; /  / to change body of implemented methods use file | settings | file templates . <nl> + if ( owner == null ) return null ; <nl> + run prevbuild = owner . getpreviousbuild ( ) ; <nl> + if ( prevbuild == null ) return null ; <nl> + cloverbuildaction action = prevbuild . getaction ( cloverbuildaction . class ) ; <nl> + if ( action == null ) return null ; <nl> + return action . findfilecoverage ( getname ( ) ) ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / jetty - io / src / test / java / org / eclipse / jetty / io / writeflushertest . java <nl> ppp b / jetty - io / src / test / java / org / eclipse / jetty / io / writeflushertest . java <nl> + @ test <nl> public void testcompleteblocking ( ) throws exception <nl> { <nl> + bytearrayendpoint endpoint = new bytearrayendpoint ( new byte [ 0 ] , 10 ) ; <nl> + <nl> + atomicboolean incompleteflush = new atomicboolean ( ) ; <nl> + writeflusher flusher = new writeflusher ( endpoint ) <nl> + { <nl> + @ override <nl> + protected void onincompleteflush ( ) <nl> + { <nl> + incompleteflush . set ( true ) ; <nl> + } <nl> + } ; <nl> + <nl> futurecallback callback = new futurecallback ( ) ; <nl> - _flusher . write ( callback , bufferutil . tobuffer ( " how " ) , bufferutil . tobuffer ( " now " ) , bufferutil . tobuffer ( " brown " ) , bufferutil . tobuffer ( " cow ! " ) ) ; <nl> - assertfalse ( callback . isdone ( ) ) ; <nl> - assertfalse ( callback . iscancelled ( ) ) ; <nl> + flusher . write ( callback , bufferutil . tobuffer ( " how now brown cow ! " ) ) ; <nl> + <nl> + assert . assertfalse ( callback . isdone ( ) ) ; <nl> + assert . assertfalse ( callback . iscancelled ( ) ) ; <nl> + <nl> + assert . asserttrue ( incompleteflush . get ( ) ) ; <nl> + <nl> + try <nl> + { <nl> + callback . get ( 100 , timeunit . milliseconds ) ; <nl> + assert . fail ( ) ; <nl> + } <nl> + catch ( timeoutexception x ) <nl> 
mmm a / src / android / libs / salesforcehybrid / src / com / salesforce / androidsdk / phonegap / plugin / smartstoreplugin . java <nl> ppp b / src / android / libs / salesforcehybrid / src / com / salesforce / androidsdk / phonegap / plugin / smartstoreplugin . java <nl> - private smartstore getsmartstore ( jsonobject arg0 ) { <nl> + * @ return <nl> + * / <nl> + public static smartstore getsmartstore ( jsonobject arg0 ) throws exception { <nl> boolean isglobal = getisglobal ( arg0 ) ; <nl> - string storename = getstorename ( arg0 ) ; <nl> - return ( isglobal <nl> - ? smartstoresdkmanager . getinstance ( ) . getglobalsmartstore ( storename ) <nl> - : smartstoresdkmanager . getinstance ( ) . getsmartstore ( storename , useraccountmanager . getinstance ( ) . getcurrentuser ( ) , useraccountmanager . getinstance ( ) . getcurrentuser ( ) . getcommunityid ( ) ) ) ; <nl> + final string storename = getstorename ( arg0 ) ; <nl> + if ( isglobal ) { <nl> + return smartstoresdkmanager . getinstance ( ) . getglobalsmartstore ( storename ) ; <nl> + } else { <nl> + final useraccount account = useraccountmanager . getinstance ( ) . getcurrentuser ( ) ; <nl> + if ( account == null ) { <nl> + throw new exception ( " no user account found " ) ; <nl> + } else { <nl> + return smartstoresdkmanager . getinstance ( ) . getsmartstore ( storename , account , account . getcommunityid ( ) ) ; <nl> + } <nl> + } <nl> } <nl> - <nl> - / ** <nl> 
mmm a / src / main / java / org / walkmod / javalang / visitors / dumpvisitor . java <nl> ppp b / src / main / java / org / walkmod / javalang / visitors / dumpvisitor . java <nl> public void visit ( enumdeclaration n , object arg ) { <nl> printpreviouscomments ( n , arg ) ; <nl> - printjavadoc ( n . getjavadoc ( ) , arg ) ; <nl> + javadoccomment comment = n . getjavadoc ( ) ; <nl> + printjavadoc ( comment , arg ) ; <nl> + if ( comment ! = null & & ! n . isnewnode ( ) & & ! comment . isnewnode ( ) ) { <nl> + int start = comment . getendline ( ) ; <nl> + int end = n . getbeginline ( ) ; <nl> + for ( int i = start + 1 ; i & lt ; end ; i++ ) { <nl> + printer . println ( ) ; <nl> + } <nl> + } <nl> printmemberannotations ( n . getannotations ( ) , arg ) ; <nl> - printmodifiers ( n . getmodifiers ( ) ) ; <nl> - printer . print ( " enum " ) ; <nl> 
mmm a / tests / fr . inria . diverse . melange . tests / src / main / java / simplefsm / fsm / adapters / fsmmt / fsmmtadaptersfactory . java <nl> ppp b / tests / fr . inria . diverse . melange . tests / src / main / java / simplefsm / fsm / adapters / fsmmt / fsmmtadaptersfactory . java <nl> - } <nl>  <nl> public eobjectadapter createadapter ( final eobject o ) { <nl> - eobjectadapter res = register . get ( o ) ; <nl> - if ( res ! = null ) { <nl> - return res ; <nl> + if ( o instanceof fsm . fsm ) { <nl> + return createfsmadapter ( ( fsm . fsm ) o ) ; <nl> } <nl> - else { <nl> - if ( o instanceof fsm . fsm ) { <nl> - res = createfsmadapter ( ( fsm . fsm ) o ) ; <nl> - register . put ( o , res ) ; <nl> - return res ; <nl> - } <nl> - if ( o instanceof fsm . state ) { <nl> - res = createstateadapter ( ( fsm . state ) o ) ; <nl> - register . put ( o , res ) ; <nl> - return res ; <nl> - } <nl> - if ( o instanceof fsm . transition ) { <nl> - res = createtransitionadapter ( ( fsm . transition ) o ) ; <nl> - register . put ( o , res ) ; <nl> - return res ; <nl> - } <nl> + if ( o instanceof fsm . state ) { <nl> + return createstateadapter ( ( fsm . state ) o ) ; <nl> } <nl> + if ( o instanceof fsm . transition ) { <nl> + return createtransitionadapter ( ( fsm . transition ) o ) ; <nl> + } <nl> + <nl> + return null ; <nl> 
mmm a / java / org / lwjgl / opengl / arbuniformbufferobject . java <nl> ppp b / java / org / lwjgl / opengl / arbuniformbufferobject . java <nl> * @ param uniformblockindex the index of the uniform block within { @ code program } <nl> * / <nl> public static string glgetactiveuniformblockname ( int program , int uniformblockindex ) { <nl> - int bufsize = glgetactiveuniformblocki ( program , uniformblockindex , gl_uniform_block_name_length ) ; <nl> - memorystack stack = stackget ( ) ; int stackpointer = stack . getpointer ( ) ; <nl> - try { <nl> - intbuffer length = stack . ints ( 0 ) ; <nl> - bytebuffer uniformblockname = stack . malloc ( bufsize ) ; <nl> - nglgetactiveuniformblockname ( program , uniformblockindex , bufsize , memaddress ( length ) , memaddress ( uniformblockname ) ) ; <nl> - return memascii ( uniformblockname , length . get ( 0 ) ) ; <nl> - } finally { <nl> - stack . setpointer ( stackpointer ) ; <nl> - } <nl> + return glgetactiveuniformblockname ( program , uniformblockindex , glgetactiveuniformblocki ( program , uniformblockindex , gl_uniform_block_name_length ) ) ; <nl> + } <nl> + <nl> 
mmm a / device / iothub - java - client / src / main / java / com / microsoft / azure / iothub / transport / amqps / amqpsiothubconnectionbasehandler . java <nl> ppp b / device / iothub - java - client / src / main / java / com / microsoft / azure / iothub / transport / amqps / amqpsiothubconnectionbasehandler . java <nl> public void shutdown ( ) { <nl> this . linkflow = false ; <nl> - this . sender . close ( ) ; <nl> - this . receiver . close ( ) ; <nl> - this . session . close ( ) ; <nl> - this . connection . close ( ) ; <nl> + if ( this . sender ! = null ) { <nl> + this . sender . close ( ) ; <nl> + } <nl> + if ( this . receiver ! = null ) { <nl> + this . receiver . close ( ) ; <nl> + } <nl> + if ( this . session ! = null ) { <nl> + this . session . close ( ) ; <nl> + } <nl> + if ( this . connection ! = null ) { <nl> + this . connection . close ( ) ; <nl> + } <nl> } <nl> - <nl> - / ** <nl> 
mmm a / blade - engine - spine - plugin / src / main / java / com / bladecoder / engine / spine / spinerenderer . java <nl> ppp b / blade - engine - spine - plugin / src / main / java / com / bladecoder / engine / spine / spinerenderer . java <nl> - currentsource . skeleton . sety ( y / scale ) ; <nl> - currentsource . skeleton . getrootbone ( ) . setrotation ( rotation ) ; <nl> + private static final matrix4 tmp = new matrix4 ( ) ; <nl> + <nl> + @ override <nl> + public void draw ( spritebatch batch , float x , float y , float scale , float rotation , color tint ) { <nl>  <nl> - batch . settransformmatrix ( batch . gettransformmatrix ( ) . scale ( scale , scale , 1 . 0f ) ) ; <nl> + if ( currentsource ! = null & & currentsource . skeleton ! = null ) { <nl> + matrix4 tm = batch . gettransformmatrix ( ) ; <nl> + tmp . set ( tm ) ; <nl> + <nl> + currentsource . skeleton . setx ( x / scale ) ; <nl> + currentsource . skeleton . sety ( y / scale ) ; <nl> + <nl> + tm . rotate ( 0 , 0 , 1 , rotation ) . scale ( scale , scale , 1 ) ; <nl> + batch . settransformmatrix ( tm ) ; <nl>  <nl> if ( tint ! = null ) <nl> currentsource . skeleton . setcolor ( tint ) ; <nl>  <nl> if ( tint ! = null ) <nl> batch . setcolor ( color . white ) ; <nl> - batch . settransformmatrix ( batch . gettransformmatrix ( ) . scale ( 1 / scale , 1 / scale , 1 . 0f ) ) ; <nl> + batch . settransformmatrix ( tmp ) ; <nl> } else { <nl> x = x - getwidth ( ) / 2 * scale ; <nl> rectanglerenderer . draw ( batch , x , y , getwidth ( ) * scale , getheight ( ) * scale , color . red ) ; <nl> 
mmm a / src / test / java / org / sonar / plugins / findbugs / findbugssensortest . java <nl> ppp b / src / test / java / org / sonar / plugins / findbugs / findbugssensortest . java <nl> - @ test <nl> - public void should_execute_findbugs_but_not_find_violation ( ) throws exception { <nl> - project project = createproject ( ) ; <nl> - findbugsexecutor executor = mock ( findbugsexecutor . class ) ; <nl> - <nl> - buginstance buginstance = getbuginstance ( " this_rule_does_not_exist " , 107 ) ; <nl> - collection & lt ; reportedbug & gt ; collection = arrays . aslist ( new reportedbug ( buginstance ) ) ; <nl> - when ( executor . execute ( false , false ) ) . thenreturn ( collection ) ; <nl> - javaresourcelocator javaresourcelocator = mockjavaresourcelocator ( ) ; <nl> when ( javaresourcelocator . classfilestoanalyze ( ) ) . thenreturn ( lists . newarraylist ( new file ( " file " ) ) ) ; <nl>  <nl> - findbugssensor analyser = new findbugssensor ( createrulesprofilewithactiverules ( false , false , false , false ) , <nl> - fakerulefinder . createwithallrules ( ) , perspectives , executor , <nl> - javaresourcelocator , fs , bytecoderesourcelocator ) ; <nl> - analyser . analyse ( project , context ) ; <nl> + pico . addcomponent ( createrulesprofilewithactiverules ( false , false , false , false ) ) ; <nl> + <nl> + findbugssensor analyser = pico . getcomponent ( findbugssensor . class ) ; <nl> + analyser . execute ( sensorcontext ) ; <nl>  <nl> verify ( executor ) . execute ( false , false ) ; <nl> - verify ( issuable , never ( ) ) . addissue ( any ( issue . class ) ) ; <nl> + verify ( sensorcontext , never ( ) ) . newissue ( ) ; <nl> 
mmm a / thymeleaf - spring3 / src / main / java / org / thymeleaf / spring3 / view / thymeleafviewresolver . java <nl> ppp b / thymeleaf - spring3 / src / main / java / org / thymeleaf / spring3 / view / thymeleafviewresolver . java <nl> - beanfactory . applybeanpropertyvalues ( view , viewname ) ; <nl> - view = ( abstractthymeleafview ) beanfactory . initializebean ( view , viewname ) ; <nl> + <nl> + final beandefinition viewbeandefinition = <nl> + ( beanfactory instanceof configurablelistablebeanfactory ? <nl> + ( ( configurablelistablebeanfactory ) beanfactory ) . getbeandefinition ( viewname ) : <nl> + null ) ; <nl> + <nl> + if ( viewbeandefinition == null || ! viewbeandefinition . isprototype ( ) ) { <nl> + final abstractthymeleafview viewinstance = beanutils . instantiateclass ( getviewclass ( ) ) ; <nl> + view = ( abstractthymeleafview ) beanfactory . configurebean ( viewinstance , viewname ) ; <nl> + } else { <nl> + view = ( abstractthymeleafview ) beanfactory . getbean ( viewname ) ; <nl> + } <nl>  <nl> } else { <nl>  <nl> - beanfactory . autowirebeanproperties ( view , autowirecapablebeanfactory . autowire_no , false ) ; <nl> - view = ( abstractthymeleafview ) beanfactory . initializebean ( view , viewname ) ; <nl> + final abstractthymeleafview viewinstance = beanutils . instantiateclass ( getviewclass ( ) ) ; <nl> + <nl> + if ( viewbeanexists & & viewbeantype == null ) { <nl> + <nl> + beanfactory . autowirebeanproperties ( viewinstance , autowirecapablebeanfactory . autowire_no , false ) ; <nl> + beanfactory . applybeanpropertyvalues ( viewinstance , viewname ) ; <nl> + view = ( abstractthymeleafview ) beanfactory . initializebean ( viewinstance , viewname ) ; <nl> + <nl> + } else { <nl> + <nl> + beanfactory . autowirebeanproperties ( viewinstance , autowirecapablebeanfactory . autowire_no , false ) ; <nl> + view = ( abstractthymeleafview ) beanfactory . initializebean ( viewinstance , viewname ) ; <nl>  <nl> - } <nl> + } <nl> 
mmm a / admobadapter / src / main / java / com / clockbyte / admobadapter / expressads / admobexpressadapterwrapper . java <nl> ppp b / admobadapter / src / main / java / com / clockbyte / admobadapter / expressads / admobexpressadapterwrapper . java <nl> - } <nl> - <nl> public int getadscounttopublish ( ) { <nl> - int noofads = math . min ( adfetcher . getfetchedadscount ( ) , <nl> - madapter . getcount ( ) / getnoofdatabetweenads ( ) ) ; <nl> - return math . min ( noofads , getlimitofads ( ) ) ; <nl> + int expected = 0 ; <nl> + if ( madapter . getcount ( ) & gt ; 0 & & madapter . getcount ( ) & gt ; = getoffsetvalue ( ) +1 ) <nl> + expected = ( madapter . getcount ( ) - getoffsetvalue ( ) ) / getnoofdatabetweenads ( ) + 1 ; <nl> + expected = math . max ( 0 , expected ) ; <nl> + return math . min ( expected , getlimitofads ( ) ) ; <nl> } <nl> 
mmm a / sentry - binding / sentry - binding - hive / src / main / java / org / apache / sentry / binding / metastore / sentrymetastoreposteventlistener . java <nl> ppp b / sentry - binding / sentry - binding - hive / src / main / java / org / apache / sentry / binding / metastore / sentrymetastoreposteventlistener . java <nl> - tableevent . getoldtable ( ) . gettablename ( ) , <nl> - tableevent . getoldtable ( ) . getsd ( ) . getlocation ( ) , <nl> - tableevent . getnewtable ( ) . getdbname ( ) , <nl> - tableevent . getnewtable ( ) . gettablename ( ) , <nl> - tableevent . getnewtable ( ) . getsd ( ) . getlocation ( ) ) ; <nl> - } <nl> + return ; <nl> + } <nl> + <nl> + string oldloc = null , newloc = null ; <nl> + <nl> + org . apache . hadoop . hive . metastore . api . table oldtal = tableevent . getoldtable ( ) ; <nl> + org . apache . hadoop . hive . metastore . api . table newtal = tableevent . getnewtable ( ) ; <nl> + <nl> + if ( oldtal ! = null & & oldtal . getsd ( ) ! =null ) { <nl> + oldloc = oldtal . getsd ( ) . getlocation ( ) ; <nl> + } <nl> + if ( newtal ! = null & & newtal . getsd ( ) ! = null ) { <nl> + newloc = newtal . getsd ( ) . getlocation ( ) ; <nl> + } <nl> + if ( oldloc ! = null & & newloc ! = null & & ! oldloc . equals ( newloc ) ) { <nl> + string olddbname = tableevent . getoldtable ( ) . getdbname ( ) ; <nl> + string oldtbname = tableevent . getoldtable ( ) . gettablename ( ) ; <nl> + string newtbname = tableevent . getnewtable ( ) . gettablename ( ) ; <nl> + string newdbname = tableevent . getnewtable ( ) . getdbname ( ) ; <nl> + renamesentrytableprivilege ( olddbname , oldtbname , oldloc , newdbname , newtbname , newloc ) ; <nl> + } <nl> 
mmm a / demos / eclipse / appmenudemo / src / com / example / appmenudemo / controls . java <nl> ppp b / demos / eclipse / appmenudemo / src / com / example / appmenudemo / controls . java <nl> - public void sharefromsdcardfile ( string _filename ) { <nl> - file file = new file ( environment . getexternalstoragedirectory ( ) , _filename ) ; <nl> - intent . putextra ( intent . extra_stream , uri . fromfile ( file ) ) ; <nl> - controls . activity . startactivity ( intent ) ; <nl> - } <nl> - <nl> + } <nl> + } <nl> + <nl> + public void sharefrominternalappstorage ( string _filename , string _mimetype ) { <nl> + string srcpath = controls . activity . getfilesdir ( ) . getabsolutepath ( ) + " / " + _filename ; /  / result : / data / data / com / myapp / files <nl> + string destpath = mtransitoryenvironmentdirectorypath + " / " + _filename ; <nl> + copyfile ( srcpath , destpath ) ; <nl> + sharefrom ( destpath , _mimetype ) ; <nl> + } <nl> + <nl> + public void sharefrom ( string _fullfilename , string _mimetype ) { <nl> 
mmm a / android / crimp / app / src / main / java / com / nusclimb / live / crimp / hello / route / routefragment . java <nl> ppp b / android / crimp / app / src / main / java / com / nusclimb / live / crimp / hello / route / routefragment . java <nl> @ override <nl> public void onviewcreated ( view view , bundle savedinstancestate ) { <nl> - textview textview = ( textview ) view . findviewbyid ( r . id . text ) ; <nl> - textview . settext ( getarguments ( ) . getstring ( args_title ) ) ; <nl> - } <nl> + mswipelayout = ( swiperefreshlayout ) view . findviewbyid ( r . id . swipe_layout ) ; <nl> + mloadwheel = ( progressbar ) view . findviewbyid ( r . id . route_wheel_progressbar ) ; <nl> + mstatustext = ( textview ) view . findviewbyid ( r . id . route_request_status_text ) ; <nl> + mretrybutton = ( button ) view . findviewbyid ( r . id . route_retry_button ) ; <nl> + mhellotext = ( textview ) view . findviewbyid ( r . id . route_hello_text ) ; <nl> + mcategoryspinner = ( spinner ) view . findviewbyid ( r . id . route_category_spinner ) ; <nl> + mroutespinner = ( spinner ) view . findviewbyid ( r . id . route_route_spinner ) ; <nl> + mroutenextbutton = ( button ) view . findviewbyid ( r . id . route_next_button ) ; <nl> + mroutereplacetext = ( textview ) view . findviewbyid ( r . id . route_replace_text ) ; <nl> + myesnogroup = ( linearlayout ) view . findviewbyid ( r . id . route_yes_no_viewgroup ) ; <nl> + <nl> + mcategoryspinner . setadapter ( mcategoryadapter ) ; <nl> + mroutespinner . setadapter ( mrouteadapter ) ; <nl> 
mmm a / src / test / java / reactor / core / publisher / fluxpublishontest . java <nl> ppp b / src / test / java / reactor / core / publisher / fluxpublishontest . java <nl> @ test <nl> public void normalsyncfusedbackpressured ( ) throws exception { <nl> - assertsubscriber & lt ; integer & gt ; ts = assertsubscriber . create ( 0 ) ; <nl> + stepverifier . create ( flux . range ( 1 , 1_000_000 ) <nl> + . publishon ( schedulers . fromexecutorservice ( exec ) ) , 0 ) <nl> + . thenrequest ( 500_000 ) <nl> + . expectnextcount ( 500_000 ) <nl> + . thenrequest ( 500_000 ) <nl> + . expectnextcount ( 500_000 ) <nl> + . verifycomplete ( ) ; <nl> + } <nl>  <nl> - flux . range ( 1 , 1_000_000 ) <nl> - . publishon ( schedulers . fromexecutorservice ( exec ) ) <nl> - . subscribe ( ts ) ; <nl> - <nl> - ts . assertnovalues ( ) <nl> - . assertnoerror ( ) <nl> - . assertnotcomplete ( ) ; <nl> - <nl> - ts . request ( 500_000 ) ; <nl> - <nl> - thread . sleep ( 500 ) ; <nl> - <nl> - ts . assertvaluecount ( 500_000 ) <nl> - . assertnoerror ( ) <nl> - . assertnotcomplete ( ) ; <nl> - <nl> - ts . request ( 500_000 ) ; <nl> - <nl> - ts . await ( duration . ofseconds ( 10 ) ) ; <nl> - ts . assertterminated ( ) ; <nl> - <nl> - ts . assertvaluecount ( 1_000_000 ) <nl> + @ test <nl> 
mmm a / src / main / java / com / mycompany / myapp / web / rest / userresource . java <nl> ppp b / src / main / java / com / mycompany / myapp / web / rest / userresource . java <nl> public responseentity & lt ; manageduserdto & gt ; updateuser ( @ requestbody manageduserdto manageduserdto ) throws urisyntaxexception { <nl> log . debug ( " rest request to update user : { } " , manageduserdto ) ; <nl> optional & lt ; user & gt ; existinguser = userrepository . findonebyemail ( manageduserdto . getemail ( ) ) ; <nl> - if ( existinguser . ispresent ( ) & & ( ! existinguser . get ( ) . getlogin ( ) . equalsignorecase ( manageduserdto . getlogin ( ) ) ) ) { <nl> + if ( existinguser . ispresent ( ) & & ( ! existinguser . get ( ) . getid ( ) . equals ( manageduserdto . getid ( ) ) ) ) { <nl> return responseentity . badrequest ( ) . headers ( headerutil . createfailurealert ( " user - management " , " emailexists " , " email already in use " ) ) . body ( null ) ; <nl> } <nl> + existinguser = userrepository . findonebylogin ( manageduserdto . getlogin ( ) ) ; <nl> + if ( existinguser . ispresent ( ) & & ( ! existinguser . get ( ) . getid ( ) . equals ( manageduserdto . getid ( ) ) ) ) { <nl> + return responseentity . badrequest ( ) . headers ( headerutil . createfailurealert ( " user - management " , " userexists " , " login name already used " ) ) . body ( null ) ; <nl> + } <nl> return userrepository <nl> + . findonebyid ( manageduserdto . getid ( ) ) <nl> 
mmm a / splice_machine / src / test / java / com / splicemachine / derby / impl / sql / execute / operations / joinselectionit . java <nl> ppp b / splice_machine / src / test / java / com / splicemachine / derby / impl / sql / execute / operations / joinselectionit . java <nl> @ test <nl> public void testinnerjoinwithsubqueryfilterexactcriteria ( ) throws exception { <nl> - fourthrowcontainsquery ( <nl> + resultset rs = methodwatcher . executequery ( <nl> format ( " explain select a2 . pid from % s a2 join " + <nl> " ( select person . pid from % s ) as a3 " + <nl> " on a2 . pid = a3 . pid " + <nl> - " where a2 . pid = 100 " , splicetablewatcher2 , splicetablewatcher ) , <nl> - broadcast_join , methodwatcher ) ; <nl> + " where a2 . pid = 100 " , splicetablewatcher2 , splicetablewatcher ) ) ; <nl> + int count = 0 ; <nl> + while ( rs . next ( ) ) { <nl> + count++ ; <nl> + if ( count == 4 ) { <nl> + string row = rs . getstring ( 1 ) ; <nl> + string joinstrategy = row . substring ( row . indexof ( plan_line_leader ) + plan_line_leader . length ( ) , <nl> + row . indexof ( join_strategy_terminator ) ) ; <nl> + assert . assertthat ( " join strategy must be either nested_loop_join or broadcast_join " , joinstrategy , <nl> + anyof ( equalto ( nested_loop_join ) , equalto ( broadcast_join ) ) ) ; <nl> + break ; <nl> + } <nl> + } <nl> } <nl>  <nl> - @ test <nl> 
mmm a / app / src / main / java / moe / feng / nhentai / api / bookapi . java <nl> ppp b / app / src / main / java / moe / feng / nhentai / api / bookapi . java <nl> public static bitmap getthumb ( context context , book book ) { <nl> string url = book . previewimageurl ; <nl> - filecachemanager m = filecachemanager . getinstance ( context ) ; <nl>  <nl> - if ( ! m . cacheexistsurl ( cache_thumb , url , book . title ) & & ! m . createcachefromnetwork ( cache_thumb , url , book . title ) ) { <nl> - return null ; <nl> + if ( filecachemanager . getinstance ( context ) . cacheexistsurl ( cache_thumb , url , book . title ) ) { <nl> + log . d ( tag , " thumb : loaded from cache " ) ; <nl> + return filecachemanager . getinstance ( context ) . getbitmapurl ( cache_thumb , url , book . title ) ; <nl> } <nl> - <nl> - return m . getbitmapurl ( cache_thumb , url , book . title ) ; <nl> - } <nl> - <nl> - public static bitmap getpagethumb ( context context , book book , int position ) { <nl> + else if ( filecachemanager . getinstance ( context ) . createcachefromnetwork ( cache_thumb , url , book . title ) ) { <nl> + log . d ( tag , " thumb : downloaded from web " ) ; <nl> + return filecachemanager . getinstance ( context ) . getbitmapurl ( cache_thumb , url , book . title ) ; <nl> + } <nl> + else { <nl> + return null ; <nl> 
mmm a / tcap / tcap - impl / src / main / java / org / mobicents / protocols / ss7 / tcap / tcapproviderimpl . java <nl> ppp b / tcap / tcap - impl / src / main / java / org / mobicents / protocols / ss7 / tcap / tcapproviderimpl . java <nl> private long getavailabletxidpreview ( ) throws tcapexception { <nl> while ( true ) { <nl> - if ( this . curdialogid & lt ; this . stack . getdialogidrangestart ( ) ) <nl> - this . curdialogid = this . stack . getdialogidrangestart ( ) - 1 ; <nl> - if ( ++this . curdialogid & gt ; this . stack . getdialogidrangeend ( ) ) <nl> - this . curdialogid = this . stack . getdialogidrangestart ( ) ; <nl> - long id = this . curdialogid ; <nl> + long id ; <nl> + if ( ! currentdialogid . compareandset ( this . stack . getdialogidrangeend ( ) , this . stack . getdialogidrangestart ( ) + 1 ) ) { <nl> + id = currentdialogid . getandincrement ( ) ; <nl> + } else { <nl> + id = this . stack . getdialogidrangestart ( ) ; <nl> + } <nl> return id ; <nl> - } <nl> 
mmm a / de . prob2 . kernel / src / main / java / de / prob / model / eventb / translate / machinexmlhandler . java <nl> ppp b / de . prob2 . kernel / src / main / java / de / prob / model / eventb / translate / machinexmlhandler . java <nl> + } <nl> + <nl> + private void endcontextextraction ( ) throws saxexception { <nl> + modelelementlist & lt ; eventbaxiom & gt ; axms = new modelelementlist & lt ; eventbaxiom & gt ; ( inheritedaxioms ) ; <nl> + axms . addmultiple ( axioms ) ; <nl> + internalcontext = internalcontext . set ( axiom . class , axms ) ; <nl> + internalcontext = internalcontext . set ( constant . class , new modelelementlist & lt ; eventbconstant & gt ; ( constants ) ) ; <nl> + internalcontext = internalcontext . set ( context . class , new modelelementlist & lt ; context & gt ; ( extends ) ) ; <nl> + internalcontext = internalcontext . set ( de . prob . model . representation . set . class , new modelelementlist & lt ; de . prob . model . representation . set & gt ; ( sets ) ) ; <nl> + <nl> proofextractor extractor = new proofextractor ( internalcontext , <nl> directorypath + file . separatorchar + internalcontext . getname ( ) ) ; <nl> - internalcontext . addproofs ( extractor . getproofs ( ) ) ; <nl> + internalcontext = internalcontext . set ( proofobligation . class , extractor . getproofs ( ) ) ; <nl>  <nl> - extractingcontext = false ; <nl> - } <nl> + model = model . addcontext ( internalcontext ) ; <nl> + if ( seesnames . contains ( internalcontext . getname ( ) ) ) { <nl> + sees . add ( internalcontext ) ; <nl> + } <nl> 
mmm a / src / main / java / org / apache / commons / net / smtp / smtpsclient . java <nl> ppp b / src / main / java / org / apache / commons / net / smtp / smtpsclient . java <nl> initsslcontext ( ) ; <nl>  <nl> sslsocketfactory ssf = context . getsocketfactory ( ) ; <nl> - string ip = getremoteaddress ( ) . gethostaddress ( ) ; <nl> + string host = ( _hostname_ ! = null ) ? _hostname_ : getremoteaddress ( ) . gethostaddress ( ) ; <nl> int port = getremoteport ( ) ; <nl> sslsocket socket = <nl> - ( sslsocket ) ssf . createsocket ( _socket_ , ip , port , true ) ; <nl> + ( sslsocket ) ssf . createsocket ( _socket_ , host , port , true ) ; <nl> + socket . setenablesessioncreation ( true ) ; <nl> + socket . setuseclientmode ( true ) ; <nl> + <nl> + if ( tlsendpointchecking ) { <nl> + sslsocketutils . enableendpointnameverification ( socket ) ; <nl> + } <nl> + if ( protocols ! = null ) { <nl> + socket . setenabledprotocols ( protocols ) ; <nl> + } <nl> + if ( suites ! = null ) { <nl> + socket . setenabledciphersuites ( suites ) ; <nl> + } <nl> + socket . starthandshake ( ) ; <nl> + <nl> + _socket_ = socket ; <nl> + _input_ = socket . getinputstream ( ) ; <nl> + _output_ = socket . getoutputstream ( ) ; <nl> + _reader = new crlflinereader ( <nl> + new inputstreamreader ( _input_ , encoding ) ) ; <nl> + _writer = new bufferedwriter ( <nl> + new outputstreamwriter ( _output_ , encoding ) ) ; <nl> + <nl> + if ( hostnameverifier ! = null & & ! hostnameverifier . verify ( host , socket . getsession ( ) ) ) { <nl> + throw new sslhandshakeexception ( " hostname does n't match certificate " ) ; <nl> + } <nl> + } <nl> 
mmm a / samples / iotfdeviceclient / src / com / ibm / iotf / sample / client / gateway / sampleraspigateway . java <nl> ppp b / samples / iotfdeviceclient / src / com / ibm / iotf / sample / client / gateway / sampleraspigateway . java <nl> - * / <nl> - private void adddevicetype ( ) throws iotfcrestexception { <nl> - try { <nl> - jsonobject response = this . apiclient . adddevicetype ( device_type , null , null , null ) ; <nl> - system . out . println ( response ) ; <nl> + return ; <nl> + } <nl> } catch ( iotfcrestexception e ) { <nl> - system . out . println ( " httpcode : " + e . gethttpcode ( ) + " errormessage : : " + e . getmessage ( ) ) ; <nl> - system . out . println ( e . getresponse ( ) ) ; <nl> + if ( e . gethttpcode ( ) == 404 ) { <nl> + apiclient . adddevicetype ( devicetype , devicetype , null , null ) ; <nl> + } else { <nl> + system . err . println ( " error : unable to add manually device type " + e . getmessage ( ) ) ; <nl> + e . printstacktrace ( ) ; <nl> + } <nl> } <nl> } <nl> - <nl> 
mmm a / letschat / src / main / java / io / fabric8 / app / letschat / letschatmodelprocessor . java <nl> ppp b / letschat / src / main / java / io / fabric8 / app / letschat / letschatmodelprocessor . java <nl> + . withcontainerport ( 5000 ) <nl> . withprotocol ( " tcp " ) <nl> . endport ( ) <nl> . addnewenv ( ) . withname ( " letschat_create_hubot_user " ) . withvalue ( " true " ) . endenv ( ) <nl> . addnewenv ( ) . withname ( " letschat_hubot_token " ) . withvalue ( " $ { letschat_hubot_token } " ) . endenv ( ) <nl> - . addnewenv ( ) . withname ( " letschat_hubot_password " ) . withvalue ( " $ { letschat_hubot_password } " ) . endenv ( ) <nl> - . addnewenv ( ) . withname ( " letschat_hubot_username " ) . withvalue ( " fabric8 " ) . endenv ( ) <nl> + . addnewenv ( ) . withname ( " letschat_hubot_password " ) . withvalue ( " $ { hubot_password } " ) . endenv ( ) <nl> + . addnewenv ( ) . withname ( " letschat_hubot_username " ) . withvalue ( " $ { hubot_username } " ) . endenv ( ) <nl> . addnewenv ( ) . withname ( " letschat_hubot_email " ) . withvalue ( " fabric8 - admin @ googlegroups . com " ) . endenv ( ) <nl> . addnewenv ( ) . withname ( " letschat_hubot_first_name " ) . withvalue ( " fabric8 " ) . endenv ( ) <nl> . addnewenv ( ) . withname ( " letschat_hubot_last_name " ) . withvalue ( " rocks " ) . endenv ( ) <nl> 
mmm a / src / main / java / com / deutscheboerse / risk / dave / ers / processor / marginshortfallsurplusprocessor . java <nl> ppp b / src / main / java / com / deutscheboerse / risk / dave / ers / processor / marginshortfallsurplusprocessor . java <nl> + private jsonobject processmarginrequirementreport ( marginrequirementreportmessaget mrrmessage ) <nl> + { <nl> + jsonobject mss = new jsonobject ( ) ; <nl> + mss . put ( " received " , new jsonobject ( ) . put ( " $ date " , zoneddatetime . now ( zoneoffset . utc ) . format ( datetimeformatter . iso_offset_date_time ) ) ) ; <nl> mss . put ( " reqid " , mrrmessage . getid ( ) ) ; <nl> mss . put ( " sesid " , mrrmessage . getsetsesid ( ) . tostring ( ) ) ; <nl> mss . put ( " rptid " , mrrmessage . getrptid ( ) ) ; <nl> - mss . put ( " txntm " , new jsonobject ( ) . put ( " $ date " , timestampformatter . format ( mrrmessage . gettxntm ( ) . togregoriancalendar ( ) . gettime ( ) ) ) ) ; <nl> - mss . put ( " bizdt " , new jsonobject ( ) . put ( " $ date " , timestampformatter . format ( mrrmessage . getbizdt ( ) . togregoriancalendar ( ) . gettime ( ) ) ) ) ; <nl> + mss . put ( " txntm " , new jsonobject ( ) . put ( " $ date " , mrrmessage . gettxntm ( ) . togregoriancalendar ( ) . tozoneddatetime ( ) . withzonesameinstant ( zoneoffset . utc ) . format ( datetimeformatter . iso_offset_date_time ) ) ) ; <nl> + mss . put ( " bizdt " , mrrmessage . getbizdt ( ) . togregoriancalendar ( ) . tozoneddatetime ( ) . format ( datetimeformatter . iso_local_date ) ) ; <nl> mss . put ( " clearingccy " , mrrmessage . getccy ( ) ) ; <nl>  <nl> processparties ( mrrmessage . getpty ( ) , mss ) ; <nl> 
mmm a / squidlib - util / src / main / java / squidpony / squidmath / crosshash . java <nl> ppp b / squidlib - util / src / main / java / squidpony / squidmath / crosshash . java <nl> + public static long hash64 ( final char [ ] [ ] data ) { <nl> + if ( data == null ) <nl> return 0 ; <nl> - long result = 0x632be59bd9b4e019l ; <nl> - for ( int i = 0 ; i & lt ; data . length ; ) { <nl> - result ^= 0x8329c6eb9e6ad3e3l * ( hash64 ( data [ i ] ) * ++i ) ; <nl> + long result = 0x9e3779b97f4a7c94l , a = 0x632be59bd9b4e019l ; <nl> + final int len = data . length ; <nl> + for ( int i = 0 ; i & lt ; len ; i++ ) { <nl> + result += ( a ^= 0x8329c6eb9e6ad3e3l * hash64 ( data [ i ] ) ) ; <nl> } <nl> - return ( result ^ 0xc6bc25963ab56c93l * data . length ) ; <nl> + return result * ( a & lt ; & lt ; 1 | 1 ) ; <nl> } <nl>  <nl> public static long hash64 ( final long [ ] [ ] data ) { <nl> 
mmm a / api / src / main / java / org / xnio / abstractiofuture . java <nl> ppp b / api / src / main / java / org / xnio / abstractiofuture . java <nl> * { @ inheritdoc } <nl> * / <nl> public status await ( ) { <nl> - synchronized ( lock ) { <nl> - boolean intr = thread . interrupted ( ) ; <nl> - try { <nl> - if ( status == status . waiting ) { <nl> - xnio . checkblockingallowed ( ) ; <nl> + final thread thread = thread . currentthread ( ) ; <nl> + state & lt ; t & gt ; state ; <nl> + for ( ; ; ) { <nl> + state = getstate ( ) ; <nl> + if ( state . getstatus ( ) ! = status . waiting ) { <nl> + return state . getstatus ( ) ; <nl> + } <nl> + xnio . checkblockingallowed ( ) ; <nl> + state & lt ; t & gt ; withwaiter = state . withwaiter ( thread ) ; <nl> + if ( compareandsetstate ( state , withwaiter ) ) { <nl> + boolean intr = thread . interrupted ( ) ; <nl> + try { <nl> do { <nl> - try { <nl> - lock . wait ( ) ; <nl> - } catch ( interruptedexception e ) { <nl> - intr = true ; <nl> - } <nl> - } while ( status == status . waiting ) ; <nl> - } <nl> - } finally { <nl> - if ( intr ) { <nl> - thread . currentthread ( ) . interrupt ( ) ; <nl> + locksupport . park ( this ) ; <nl> + if ( thread . interrupted ( ) ) intr = true ; <nl> + state = getstate ( ) ; <nl> + } while ( state . getstatus ( ) == status . waiting ) ; <nl> + return state . getstatus ( ) ; <nl> + } finally { <nl> + if ( intr ) thread . interrupt ( ) ; <nl> } <nl> - } <nl> - return status ; <nl> - } <nl> - } <nl> 
mmm a / modern - jogl - examples / src / tut09 / basiclighting / basiclighting . java <nl> ppp b / modern - jogl - examples / src / tut09 / basiclighting / basiclighting . java <nl> - public void reshape ( glautodrawable glad , int x , int y , int w , int h ) { <nl> - system . out . println ( " reshape ( ) x : " + x + " y : " + y + " width : " + w + " height : " + h ) ; <nl> + @ override <nl> + public void reshape ( gl3 gl3 , int w , int h ) { <nl>  <nl> - gl3 gl3 = glad . getgl ( ) . getgl3 ( ) ; <nl> + float znear = 1 . 0f , zfar = 1_000f ; <nl> + matrixstack_ perspmatrix = new matrixstack_ ( ) ; <nl>  <nl> - matrixstack perspectivematrix = new matrixstack ( ) ; <nl> + perspmatrix . perspective ( 45 . 0f , ( float ) w / h , znear , zfar ) ; <nl>  <nl> - perspectivematrix . settop ( jglm . perspective ( 45 . 0f , ( float ) w / ( float ) h , znear , zfar ) ) ; <nl> - <nl> - perspectivematrix . top ( ) . print ( " perspectivematrix . top ( ) " ) ; <nl> - <nl> - gl3 . glbindbuffer ( gl3 . gl_uniform_buffer , projectionubo [ 0 ] ) ; <nl> - { <nl> - gl3 . glbuffersubdata ( gl3 . gl_uniform_buffer , 0 , 16 * 4 , glbuffers . newdirectfloatbuffer ( perspectivematrix . top ( ) . tofloatarray ( ) ) ) ; <nl> - } <nl> - gl3 . glbindbuffer ( gl3 . gl_uniform_buffer , 0 ) ; <nl> + gl3 . glbindbuffer ( gl_uniform_buffer , projectionuniformbuffer . get ( 0 ) ) ; <nl> + gl3 . glbuffersubdata ( gl_uniform_buffer , 0 , mat4 . size , perspmatrix . top ( ) . todfb ( matrixbuffer ) ) ; <nl> 
mmm a / useragent - generic - java / src / main / java / com / temenos / useragent / generic / http / defaulthttpclient . java <nl> ppp b / useragent - generic - java / src / main / java / com / temenos / useragent / generic / http / defaulthttpclient . java <nl> } <nl>  <nl> - private void loghttprequest ( string url , httprequest request ) { <nl> - logger . info ( " \ nurl : { } \ nheaders : { } \ nrequest : { } " , url , <nl> - request . headers ( ) , <nl> - defaulthttpclienthelper . prettyprintxml ( request . payload ( ) ) ) ; <nl> - } <nl> - <nl> - private void loghttpresponse ( httpresponse response ) { <nl> + private void loghttprequest ( string url , httprequest request ) { <nl> + if ( logger . isinfoenabled ( ) ) { <nl> + string payload = request . payload ( ) ; <nl> + if ( payload ! = null & & ! payload . isempty ( ) ) { <nl> + logger . info ( " \ nurl : { } \ nheaders : { } \ nrequest : { } " , url , <nl> + request . headers ( ) , <nl> + defaulthttpclienthelper . prettyprintxml ( payload ) ) ; <nl> + } else { <nl> + logger . info ( " \ nurl : { } \ nheaders : { } \ nno request body " , url , <nl> + request . headers ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / impl / src / main / java / javax / faces / component / methodexpressionmethodbindingadapter . java <nl> ppp b / impl / src / main / java / javax / faces / component / methodexpressionmethodbindingadapter . java <nl> - class torestoreclass = null ; <nl> - if ( null ! = classname ) { <nl> - try { <nl> - torestoreclass = loadclass ( classname , this ) ; <nl> - } <nl> - catch ( classnotfoundexception e ) { <nl> - throw new illegalstateexception ( e . getmessage ( ) ) ; <nl> - } <nl> - <nl> - if ( null ! = torestoreclass ) { <nl> - try { <nl> - result = <nl> - ( methodbinding ) torestoreclass . newinstance ( ) ; <nl> - } <nl> - catch ( instantiationexception e ) { <nl> - throw new illegalstateexception ( e . getmessage ( ) ) ; <nl> - } <nl> - catch ( illegalaccessexception a ) { <nl> - throw new illegalstateexception ( a . getmessage ( ) ) ; <nl> - } <nl> - } <nl> - <nl> - if ( null ! = result & & null ! = savedstate ) { <nl> - ( ( stateholder ) result ) . restorestate ( context , savedstate ) ; <nl> + if ( ! ( state instanceof methodbinding ) ) { <nl> + object [ ] statestruct = ( object [ ] ) state ; <nl> + object savedstate = statestruct [ 0 ] ; <nl> + string classname = statestruct [ 1 ] . tostring ( ) ; <nl> + methodbinding result = null ; <nl> + <nl> + if ( classname ! = null ) { <nl> + class & lt ; ? & gt ; torestoreclass = loadclass2 ( classname , this ) ; <nl> + <nl> + if ( torestoreclass ! = null ) { <nl> + result = newinstance ( torestoreclass ) ; <nl> + } <nl> + <nl> + if ( ! isanynull ( result , savedstate ) ) { <nl> + ( ( stateholder ) result ) . restorestate ( context , savedstate ) ; <nl> 
mmm a / jackson1 / src / main / java / com / webcohesion / enunciate / modules / jackson1 / model / util / jacksonutil . java <nl> ppp b / jackson1 / src / main / java / com / webcohesion / enunciate / modules / jackson1 / model / util / jacksonutil . java <nl> if ( typeadapterinfo ! = null ) { <nl> final xmljavatypeadapter finalinfo = typeadapterinfo ; <nl> - decorateddeclaredtype adaptertypemirror = ( decorateddeclaredtype ) annotations . mirrorof ( new callable & lt ; class & lt ; ? & gt ; & gt ; ( ) { <nl> + decoratedtypemirror adaptertypemirror = annotations . mirrorof ( new callable & lt ; class & lt ; ? & gt ; & gt ; ( ) { <nl> @ override <nl> public class & lt ; ? & gt ; call ( ) throws exception { <nl> return finalinfo . value ( ) ; <nl> } <nl> } , env ) ; <nl> - <nl> - adaptertype adaptertype = new adaptertype ( adaptertypemirror , context ) ; <nl> - if ( ( adaptedtype instanceof declaredtype & & adaptertype . canadapt ( adaptedtype , context . getcontext ( ) ) ) || <nl> - ( maybecontainedadaptedtype ! = adaptedtype & & adaptertype . canadapt ( maybecontainedadaptedtype , context . getcontext ( ) ) ) ) { <nl> - return adaptertype ; <nl> + if ( adaptertypemirror instanceof decorateddeclaredtype ) { <nl> + return new adaptertype ( ( decorateddeclaredtype ) adaptertypemirror , context ) ; <nl> } <nl> - <nl> - throw new enunciateexception ( referer + " : adapter " + adaptertypemirror + " does not adapt " + maybecontainedadaptedtype ) ; <nl> } <nl> } <nl> 
mmm a / sejda - sambox / src / main / java / org / sejda / impl / sambox / splitdownthemiddletask . java <nl> ppp b / sejda - sambox / src / main / java / org / sejda / impl / sambox / splitdownthemiddletask . java <nl> + importpage ( page , lookup , trimbox . getwidth ( ) , topsideheight , 0 , - bottomsideheight ) ; <nl> } <nl>  <nl> - private void importbottompage ( pdpage page , lookuptable & lt ; pdpage & gt ; lookup , double ratio ) { <nl> - pdrectangle trimbox = page . gettrimbox ( ) ; <nl> + private void importbottompage ( pdpage page , lookuptable & lt ; pdpage & gt ; lookup , double ratio ) throws taskioexception { <nl> + pdrectangle trimbox = page . gettrimbox ( ) . rotate ( page . getrotation ( ) ) ; <nl> float h = trimbox . getheight ( ) ; <nl> float r = ( float ) ratio ; <nl> float bottomsideheight = h / ( r + 1 ) ; <nl>  <nl> - pdpage bottompage = destinationhandler . importpage ( page ) ; <nl> - lookup . addlookupentry ( page , bottompage ) ; <nl> - pdrectangle lowerside = new pdrectangle ( ) ; <nl> - lowerside . setupperrighty ( trimbox . getlowerlefty ( ) + bottomsideheight ) ; <nl> - lowerside . setupperrightx ( trimbox . getupperrightx ( ) ) ; <nl> - lowerside . setlowerlefty ( trimbox . getlowerlefty ( ) ) ; <nl> - lowerside . setlowerleftx ( trimbox . getlowerleftx ( ) ) ; <nl> - <nl> - bottompage . setcropbox ( lowerside ) ; <nl> - bottompage . settrimbox ( lowerside ) ; <nl> - bottompage . setmediabox ( lowerside ) ; <nl> + importpage ( page , lookup , trimbox . getwidth ( ) , bottomsideheight , 0 , 0 ) ; <nl> } <nl> - <nl> - @ override <nl> 
mmm a / groovy - language - server / src / test / java / com / palantir / ls / groovy / groovycwrappertest . java <nl> ppp b / groovy - language - server / src / test / java / com / palantir / ls / groovy / groovycwrappertest . java <nl> + createsymbolinformation ( " friend " , symbolkind . variable , <nl> + createlocation ( scriptfile . getabsolutepath ( ) , ranges . createrange ( 0 , 7 , 0 , 13 ) ) , <nl> + optional . of ( " myscript " ) ) , <nl> + createsymbolinformation ( " friend " , symbolkind . variable , <nl> + createlocation ( scriptfile . getabsolutepath ( ) , ranges . createrange ( 0 , 7 , 0 , 13 ) ) , <nl> + optional . of ( " run " ) ) , <nl> + createsymbolinformation ( " animal " , symbolkind . variable , <nl> + createlocation ( scriptfile . getabsolutepath ( ) , ranges . createrange ( 2 , 11 , 2 , 24 ) ) , <nl> + optional . of ( " pet " ) ) , <nl> + createsymbolinformation ( " myanimal " , symbolkind . variable , <nl> + createlocation ( scriptfile . getabsolutepath ( ) , ranges . createrange ( 3 , 10 , 3 , 18 ) ) , <nl> optional . of ( " pet " ) ) , <nl> createsymbolinformation ( " pet " , symbolkind . method , <nl> - createlocation ( scriptfile . getabsolutepath ( ) , ranges . createrange ( 2 , 0 , 5 , 1 ) ) , <nl> + createlocation ( scriptfile . getabsolutepath ( ) , ranges . createrange ( 2 , 0 , 6 , 1 ) ) , <nl> optional . of ( " myscript " ) ) , <nl> createsymbolinformation ( " valueof " , symbolkind . method , <nl> 
mmm a / jenkins / src / main / java / io / fabric8 / apps / jenkins / jenkinsmodelprocessor . java <nl> ppp b / jenkins / src / main / java / io / fabric8 / apps / jenkins / jenkinsmodelprocessor . java <nl> + . withcontainerport ( 8080 ) <nl> . endport ( ) <nl> + . addnewenv ( ) <nl> + . withname ( " domain " ) <nl> + . withvalue ( " $ { domain } " ) <nl> + . endenv ( ) <nl> . addnewenv ( ) <nl> . withname ( " jenkins_workflow_git_repository " ) <nl> . withvalue ( " $ { jenkins_workflow_git_repository } " ) <nl> 
mmm a / src / test / java / hudson / plugins / parameterizedtrigger / test / renamejobtest . java <nl> ppp b / src / test / java / hudson / plugins / parameterizedtrigger / test / renamejobtest . java <nl> } <nl> - <nl> + <nl> public void testrenameanddeletejobinparentfolder ( ) throws exception { <nl> - mockfolder folder1 = ( mockfolder ) jenkins . createproject ( <nl> - ( toplevelitemdescriptor ) jenkins . getdescriptor ( mockfolder . class ) , <nl> - " folder1 " , <nl> - true <nl> - ) ; <nl> - mockfolder folder2 = ( mockfolder ) folder1 . createproject ( <nl> - ( toplevelitemdescriptor ) jenkins . getdescriptor ( mockfolder . class ) , <nl> - " folder2 " , <nl> - true <nl> - ) ; <nl> - freestyleproject p1 = ( freestyleproject ) folder2 . createproject ( <nl> - ( toplevelitemdescriptor ) jenkins . getdescriptor ( freestyleproject . class ) , <nl> - " projecta " , <nl> - true <nl> - ) ; <nl> - freestyleproject p2 = ( freestyleproject ) folder1 . createproject ( <nl> - ( toplevelitemdescriptor ) jenkins . getdescriptor ( freestyleproject . class ) , <nl> - " projectb " , <nl> - true <nl> - ) ; <nl> - <nl> + mockfolder folder1 = createproject ( mockfolder . class , jenkins , " folder1 " ) ; <nl> + mockfolder folder2 = createproject ( mockfolder . class , folder1 , " folder2 " ) ; <nl> + freestyleproject p1 = createproject ( freestyleproject . class , folder2 , " projecta " ) ; <nl> + freestyleproject p2 = createproject ( freestyleproject . class , folder1 , " projectb " ) ; <nl> + <nl> p1 . getpublisherslist ( ) . add ( new buildtrigger ( new buildtriggerconfig ( <nl> string . format ( " .  .  / % s " , p2 . getname ( ) ) , <nl> 
mmm a / src / main / java / uk / co / coen / capsulecrm / client / copportunity . java <nl> ppp b / src / main / java / uk / co / coen / capsulecrm / client / copportunity . java <nl> } <nl>  <nl> - public static f . promise & lt ; copportunities & gt ; listbytag ( string tag , long time , timeunit unit ) { <nl> - return ws . url ( capsuleurl + " / api / opportunity " ) <nl> - . settimeout ( ( int ) unit . tomillis ( time ) ) <nl> - . setqueryparameter ( " tag " , tag ) <nl> - . setheader ( " content - type " , " text / xml ; charset=utf - 8 " ) <nl> - . setauth ( capsuletoken , " " ) <nl> - . get ( ) . map ( new f . function & lt ; ws . response , copportunities & gt ; ( ) { <nl> - @ override <nl> - public copportunities apply ( ws . response response ) throws throwable { <nl> - return ( copportunities ) xstream . unmarshal ( new domreader ( response . asxml ( ) ) ) ; <nl> - } <nl> - } ) ; <nl> + public static future & lt ; copportunities & gt ; listbytag ( string tag , long time , timeunit unit ) throws ioexception { <nl> + return transform ( new listenablefutureadapter & lt ; & gt ; ( asynchttpclient . prepareget ( capsuleurl + " / api / opportunity " ) <nl> + . addqueryparameter ( " tag " , tag ) <nl> + . addheader ( " accept " , " application / xml " ) <nl> + . setrealm ( realm ) <nl> + . execute ( ) ) , new transformhttpresponse & lt ; copportunities & gt ; ( xstream ) ) ; <nl> } <nl>  <nl> - public static f . promise & lt ; copportunities & gt ; listmodifiedsince ( datetime modifiedsince ) { <nl> + public static future & lt ; copportunities & gt ; listmodifiedsince ( datetime modifiedsince ) throws ioexception { <nl> 
mmm a / src / me / libraryaddict / disguise / disguisetypes / targeteddisguise . java <nl> ppp b / src / me / libraryaddict / disguise / disguisetypes / targeteddisguise . java <nl> - { <nl> + if ( ! disguiseviewers . contains ( playername ) ) { <nl> disguiseviewers . add ( playername ) ; <nl>  <nl> - if ( disguiseapi . isdisguiseinuse ( this ) ) <nl> - { <nl> + if ( disguiseapi . isdisguiseinuse ( this ) ) { <nl> disguiseutilities . checkconflicts ( this , playername ) ; <nl> disguiseutilities . refreshtracker ( this , playername ) ; <nl> + <nl> + if ( ishideplayer ( ) & & getentity ( ) instanceof player ) { <nl> + try { <nl> + player player = bukkit . getplayerexact ( playername ) ; <nl> + <nl> + if ( player ! = null ) { <nl> + packetcontainer deletetab = new packetcontainer ( packettype . play . server . player_info ) ; <nl> + <nl> + deletetab . getplayerinfoaction ( ) . write ( 0 , <nl> + cansee ( player ) ? playerinfoaction . remove_player : playerinfoaction . add_player ) ; <nl> + deletetab . getplayerinfodatalists ( ) . write ( 0 , <nl> + arrays . aslist ( new playerinfodata ( reflectionmanager . getgameprofile ( ( player ) getentity ( ) ) , 0 , <nl> + nativegamemode . survival , <nl> + wrappedchatcomponent . fromtext ( ( ( player ) getentity ( ) ) . getdisplayname ( ) ) ) ) ) ; <nl> + <nl> + protocollibrary . getprotocolmanager ( ) . sendserverpacket ( player , deletetab ) ; <nl> + } <nl> + } <nl> + catch ( invocationtargetexception e ) { <nl> + e . printstacktrace ( ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / bobas . businessobjectscommon / src / main / java / org / colorcoding / ibas / bobas / rules / businessrulesfactory . java <nl> ppp b / bobas . businessobjectscommon / src / main / java / org / colorcoding / ibas / bobas / rules / businessrulesfactory . java <nl> - * / <nl> - public synchronized static ibusinessrulesmanager createmanager ( ) throws businessruleexception { <nl> - if ( defaultmanager == null ) { <nl> - synchronized ( businessrulesfactory . class ) { <nl> - if ( defaultmanager == null ) { <nl> - try { <nl> - defaultmanager = newmanager ( myconfiguration <nl> - . getconfigvalue ( myconfiguration . config_item_business_rules_way , " " ) . tolowercase ( ) ) ; <nl> - } catch ( exception e ) { <nl> - throw new businessruleexception ( i18n . prop ( " msg_bobas_create_business_rules_manager_falid " ) , e ) ; <nl> - } <nl> - if ( defaultmanager == null ) { <nl> - throw new businessruleexception ( i18n . prop ( " msg_bobas_create_business_rules_manager_falid " ) ) ; <nl> - } <nl> - } <nl> - } <nl> + * / <nl> + public synchronized ibusinessrulesmanager createmanager ( ) throws businessruleexception { <nl> + if ( defaultmanager == null ) { <nl> + defaultmanager = this . create ( myconfiguration . config_item_business_rules_way , " businessrulesmanager " ) ; <nl> + } <nl> + return defaultmanager ; <nl> 
mmm a / jfixby - cmns - api / jfixby - commons - api / com / jfixby / cmns / ver / version . java <nl> ppp b / jfixby - cmns - api / jfixby - commons - api / com / jfixby / cmns / ver / version . java <nl> + public string getversionstring ( ) { <nl> debug . checknull ( " packagename " , this . packagename ) ; <nl> debug . checkempty ( " packagename " , this . packagename ) ; <nl> - debug . checknull ( " stage " , this . stage ) ; <nl> - debug . checktrue ( " major is invalid : " + this . major , this . major & gt ; = 0 ) ; <nl> - debug . checktrue ( " minor is invalid : " + this . minor , this . minor & gt ; = 0 ) ; <nl> - debug . checktrue ( " build is invalid : " + this . build , this . build & gt ; = 0 ) ; <nl> - return this . major + " . " + this . minor + " . " + this . stage . tagname + " . " + this . build ; <nl> + debug . checkempty ( " major is invalid " , this . major ) ; <nl> + debug . checkempty ( " minor is invalid " , this . minor ) ; <nl> + debug . checkempty ( " build is invalid " , this . build ) ; <nl> + debug . checknull ( " major is invalid " , this . major ) ; <nl> + debug . checknull ( " minor is invalid " , this . minor ) ; <nl> + debug . checknull ( " build is invalid " , this . build ) ; <nl> + return this . major + " . " + this . minor + " . " + this . build ; <nl> } <nl> - <nl> - public string getpackageversionstring ( ) { <nl> 
mmm a / stroom - query - api / src / main / java / stroom / query / shared / search . java <nl> ppp b / stroom - query - api / src / main / java / stroom / query / shared / search . java <nl> - search search = ( search ) o ; <nl> + final search search = ( search ) o ; <nl>  <nl> - return new equalsbuilder ( ) <nl> - . append ( incremental , search . incremental ) <nl> - . append ( datasourceref , search . datasourceref ) <nl> - . append ( expression , search . expression ) <nl> - . append ( componentsettingsmap , search . componentsettingsmap ) <nl> - . append ( parammap , search . parammap ) <nl> - . isequals ( ) ; <nl> + if ( incremental ! = search . incremental ) return false ; <nl> + if ( datasourceref ! = null ? ! datasourceref . equals ( search . datasourceref ) : search . datasourceref ! = null ) <nl> + return false ; <nl> + if ( expression ! = null ? ! expression . equals ( search . expression ) : search . expression ! = null ) return false ; <nl> + if ( componentsettingsmap ! = null ? ! componentsettingsmap . equals ( search . componentsettingsmap ) : search . componentsettingsmap ! = null ) <nl> + return false ; <nl> + if ( parammap ! = null ? ! parammap . equals ( search . parammap ) : search . parammap ! = null ) return false ; <nl> + return datetimelocale ! = null ? datetimelocale . equals ( search . datetimelocale ) : search . datetimelocale == null ; <nl> } <nl> 
mmm a / src / main / java / pcl / openfm / tileentity / tileentityradio . java <nl> ppp b / src / main / java / pcl / openfm / tileentity / tileentityradio . java <nl> + } <nl> + } <nl> + } <nl> + if ( ( minecraft . getminecraft ( ) . theplayer ! = null ) & & ( mp3player ! = null || oggplayer ! = null ) & & ( ! isinvalid ( ) ) ) { <nl> + vol = getclosest ( ) ; <nl> + if ( vol & gt ; 10000 . 0f * volume ) { <nl> + if ( mp3player ! = null ) <nl> + mp3player . setvolume ( 0 . 0f ) ; <nl> + else if ( oggplayer ! = null ) <nl> + oggplayer . setvolume ( 0 . 0f ) ; <nl> + } else { <nl> + float v2 = 10000 . 0f / vol / 100 . 0f ; <nl> if ( v2 & gt ; 1 . 0f ) { <nl> - mp3player . setvolume ( 1 . 0f * volume * volume ) ; <nl> + if ( mp3player ! = null ) <nl> + mp3player . setvolume ( 1 . 0f * volume * volume ) ; <nl> + else if ( oggplayer ! = null ) <nl> + oggplayer . setvolume ( 1 . 0f * volume * volume ) ; <nl> } else { <nl> - mp3player . setvolume ( v2 * volume * volume ) ; <nl> + if ( mp3player ! = null ) <nl> + mp3player . setvolume ( v2 * volume * volume ) ; <nl> + else if ( oggplayer ! = null ) <nl> + oggplayer . setvolume ( v2 * volume * volume ) ; <nl> } <nl> } <nl> if ( vol == 0 . 0f ) { <nl> 
mmm a / jdbc - lib / src / test / java / com / streamsets / pipeline / stage / origin / jdbc / table / basicit . java <nl> ppp b / jdbc - lib / src / test / java / com / streamsets / pipeline / stage / origin / jdbc / table / basicit . java <nl> . tableconfigbeans ( immutablelist . of ( tableconfigbean ) ) <nl> . build ( ) ; <nl>  <nl> - sourcerunner runner = new sourcerunner . builder ( tablejdbcdsource . class , tablejdbcsource ) <nl> - . addoutputlane ( " a " ) . build ( ) ; <nl> + pushsourcerunner runner = new pushsourcerunner . builder ( tablejdbcdsource . class , tablejdbcsource ) <nl> + . addoutputlane ( " a " ) <nl> + . setonrecorderror ( onrecorderror . to_error ) <nl> + . build ( ) ; <nl> runner . runinit ( ) ; <nl> try { <nl> - stagerunner . output output = runner . runproduce ( " " , 5 ) ; <nl> - list & lt ; record & gt ; records = output . getrecords ( ) . get ( " a " ) ; <nl> - assert . assertequals ( 5 , records . size ( ) ) ; <nl> - checkrecords ( expected_cricket_stars_records . sublist ( 0 , 5 ) , records ) ; <nl> + jdbcpushsourcetestcallback callback = new jdbcpushsourcetestcallback ( runner , 2 ) ; <nl> + runner . runproduce ( collections . emptymap ( ) , 5 , callback ) ; <nl>  <nl> - output = runner . runproduce ( output . getnewoffset ( ) , 5 ) ; <nl> - records = output . getrecords ( ) . get ( " a " ) ; <nl> + list & lt ; list & lt ; record & gt ; & gt ; batchrecords = callback . waitforallbatchesandreset ( ) ; <nl> + <nl> + list & lt ; record & gt ; records = batchrecords . get ( 0 ) ; <nl> assert . assertequals ( 5 , records . size ( ) ) ; <nl> - checkrecords ( expected_cricket_stars_records . sublist ( 5 , 10 ) , records ) ; <nl> + checkrecords ( expected_cricket_stars_records . sublist ( 0 , 5 ) , records ) ; <nl> 
mmm a / src / main / java / com / livefyre / android / core / writeclient . java <nl> ppp b / src / main / java / com / livefyre / android / core / writeclient . java <nl> + public static void postcontent ( string networkid , <nl> + string collectionid , <nl> + string parentid , <nl> + string token , <nl> string body , <nl> jsonhttpresponsehandler handler ) <nl> { <nl> - builder paramsbuilder = new builder ( ) ; <nl> - paramsbuilder . appendqueryparameter ( " lftoken " , token ) ; <nl>  <nl> - stringbuilder urlstringbuilder = new stringbuilder ( config . scheme ) <nl> - . append ( config . quilldomain ) . append ( " . " ) <nl> - . append ( config . gethostname ( networkid ) ) <nl> - . append ( " / api / v3 . 0 / collection / " ) <nl> - . append ( collectionid ) <nl> - . append ( " / post / " ) <nl> - . append ( paramsbuilder . tostring ( ) ) ; <nl> + final builder uribuilder = new uri . builder ( ) <nl> + . scheme ( config . scheme ) <nl> + . authority ( config . quilldomain + " . " + config . gethostname ( networkid ) ) <nl> + . appendpath ( " api " ) <nl> + . appendpath ( " v3 . 0 " ) <nl> + . appendpath ( " collection " ) <nl> + . appendpath ( collectionid ) <nl> + . appendpath ( " post " ) <nl> + . appendpath ( " " ) <nl> + . appendqueryparameter ( " lftoken " , token ) ; <nl>  <nl> - requestparams bodyparams = new requestparams ( ) ; <nl> - bodyparams . put ( " body " , body ) ; <nl> 
mmm a / src / main / java / com / livefyre / android / core / publicapiclient . java <nl> ppp b / src / main / java / com / livefyre / android / core / publicapiclient . java <nl> throws malformedurlexception <nl> { <nl> - builder paramsbuilder = new builder ( ) ; <nl> - if ( usertoken ! = null ) { <nl> - paramsbuilder . appendqueryparameter ( " lftoken " , usertoken ) ; <nl> - } <nl> - if ( statuses ! = null ) { <nl> - paramsbuilder . appendqueryparameter ( " status " , textutils . join ( " , " , statuses ) ) ; <nl> - } <nl> - if ( offset ! = null ) { <nl> - paramsbuilder . appendqueryparameter ( " offset " , integer . tostring ( offset ) ) ; <nl> - } <nl> - <nl> - stringbuilder urlstringbuilder = new stringbuilder ( config . scheme ) <nl> - . append ( config . bootstrapdomain ) . append ( " . " ) <nl> - . append ( config . gethostname ( networkid ) ) <nl> - . append ( " / api / v3 . 0 / author / " ) <nl> - . append ( userid ) <nl> - . append ( " / comments / " ) <nl> - . append ( paramsbuilder . tostring ( ) ) ; <nl> + final builder uribuilder = new uri . builder ( ) <nl> + . scheme ( config . scheme ) <nl> + . authority ( config . bootstrapdomain + " . " + config . gethostname ( networkid ) ) <nl> + . appendpath ( " api " ) <nl> + . appendpath ( " v3 . 0 " ) <nl> + . appendpath ( " author " ) <nl> + . appendpath ( userid ) <nl> + . appendpath ( " " ) <nl> + . appendpath ( " comments " ) <nl> + . appendpath ( " " ) ; <nl>  <nl> - return urlstringbuilder . tostring ( ) ; <nl> - } <nl> + if ( usertoken ! = null ) { <nl> 
mmm a / base / org . codehaus . groovy21 / src / org / codehaus / groovy / antlr / antlrparserplugin . java <nl> ppp b / base / org . codehaus . groovy21 / src / org / codehaus / groovy / antlr / antlrparserplugin . java <nl> } <nl> if ( target ! = null ) { <nl> + int off = math . min ( locations . findoffset ( target . getlastlinenumber ( ) + 1 , 1 ) , locations . getend ( ) - 1 ) ; <nl> + int [ ] row_col = locations . getrowcol ( off ) ; <nl> + <nl> synthetic = new returnstatement ( constantexpression . null ) ; <nl> - synthetic . setstart ( target . getend ( ) +1 ) ; <nl> - synthetic . setend ( target . getend ( ) +1 ) ; <nl> - synthetic . setlinenumber ( target . getlastlinenumber ( ) ) ; <nl> - synthetic . setlastlinenumber ( target . getlinenumber ( ) ) ; <nl> - synthetic . setcolumnnumber ( target . getlastcolumnnumber ( ) +1 ) ; <nl> - synthetic . setlastcolumnnumber ( target . getcolumnnumber ( ) +1 ) ; <nl> + synthetic . setstart ( off ) ; <nl> + synthetic . setend ( off ) ; <nl> + synthetic . setlinenumber ( row_col [ 0 ] ) ; <nl> + synthetic . setcolumnnumber ( row_col [ 1 ] ) ; <nl> + synthetic . setlastlinenumber ( row_col [ 0 ] ) ; <nl> + synthetic . setlastcolumnnumber ( row_col [ 1 ] ) ; <nl> } <nl> return synthetic ; <nl> - } <nl> 
mmm a / mediation / mediatedviews / inmobi / src / com / appnexus / opensdk / mediatednativead / inmobinativead . java <nl> ppp b / mediation / mediatedviews / inmobi / src / com / appnexus / opensdk / mediatednativead / inmobinativead . java <nl> + * @ return native ad response from inmobi <nl> * / <nl> @ override <nl> public void requestnativead ( context context , string uid , mediatednativeadcontroller mbc , targetingparameters tp ) { <nl> - if ( inmobisettings . inmobi_app_id == null || inmobisettings . inmobi_app_id . isempty ( ) ) { <nl> - clog . e ( clog . mediationlogtag , " inmobi mediation failed . call inmobisettings . setinmobiappid ( string key , context context ) to set the app id . " ) ; <nl> - if ( mbc ! = null ) { <nl> + if ( mbc ! = null ) { <nl> + if ( stringutil . isempty ( inmobisettings . inmobi_app_id ) ) { <nl> + clog . e ( clog . mediationlogtag , " inmobi mediation failed . call inmobisettings . setinmobiappid ( string key , context context ) to set the app id . " ) ; <nl> mbc . onadfailed ( resultcode . mediated_sdk_unavailable ) ; <nl> + return ; <nl> } <nl> - return ; <nl> - } <nl> - imnative nativead ; <nl> - if ( uid == null || uid . isempty ( ) ) { <nl> - nativead = new imnative ( inmobisettings . inmobi_app_id , new inmobinativeadlistener ( mbc ) ) ; <nl> - } else { <nl> - nativead = new imnative ( uid , new inmobinativeadlistener ( mbc ) ) ; <nl> - } <nl> - inmobisettings . settargetingparams ( tp ) ; <nl> - nativead . loadad ( ) ; <nl> + try { <nl> + long placementid = long . parselong ( uid ) ; <nl> + inmobinativeadlistener nativeadlistener = new inmobinativeadlistener ( mbc ) ; <nl> + inmobinative nativead = new inmobinative ( placementid , nativeadlistener ) ; <nl> + inmobisettings . settargetingparams ( tp ) ; <nl> + nativead . load ( ) ; <nl> + } catch ( numberformatexception e ) { <nl> 
mmm a / java_point_to_point_example / app / src / main / java / com / projecttango / examples / java / pointtopoint / pointtopointrenderer . java <nl> ppp b / java_point_to_point_example / app / src / main / java / com / projecttango / examples / java / pointtopoint / pointtopointrenderer . java <nl> * note : this must be called from the opengl render thread - it is not thread safe . <nl> * / <nl> - public void updaterendercamerapose ( tangoposedata devicepose , deviceextrinsics extrinsics ) { <nl> - pose camerapose = sceneposecalculator . toopenglcamerapose ( devicepose , extrinsics ) ; <nl> - getcurrentcamera ( ) . setrotation ( camerapose . getorientation ( ) ) ; <nl> - getcurrentcamera ( ) . setposition ( camerapose . getposition ( ) ) ; <nl> + public void updaterendercamerapose ( tangoposedata camerapose ) { <nl> + float [ ] rotation = camerapose . getrotationasfloats ( ) ; <nl> + float [ ] translation = camerapose . gettranslationasfloats ( ) ; <nl> + quaternion quaternion = new quaternion ( rotation [ 3 ] , rotation [ 0 ] , rotation [ 1 ] , rotation [ 2 ] ) ; <nl> + getcurrentcamera ( ) . setrotation ( quaternion . conjugate ( ) ) ; <nl> + getcurrentcamera ( ) . setposition ( translation [ 0 ] , translation [ 1 ] , translation [ 2 ] ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / android - networking / src / main / java / com / androidnetworking / internal / internalrunnable . java <nl> ppp b / android - networking / src / main / java / com / androidnetworking / internal / internalrunnable . java <nl> - andata data = null ; <nl> try { <nl> - data = internalnetworking . performsimplerequest ( request ) ; <nl> - if ( data == null ) { <nl> + okhttpresponse = internalnetworking . performsimplerequest ( request ) ; <nl> + <nl> + if ( okhttpresponse == null ) { <nl> + anerror anerror = new anerror ( ) ; <nl> + anerror = request . parsenetworkerror ( anerror ) ; <nl> + anerror . seterrordetail ( anconstants . connection_error ) ; <nl> + anerror . seterrorcode ( 0 ) ; <nl> + delivererror ( request , anerror ) ; <nl> return ; <nl> } <nl> - if ( data . code == 304 ) { <nl> - request . finish ( ) ; <nl> + <nl> + if ( request . getresponseas ( ) == response . ok_http_response ) { <nl> + request . deliverokhttpresponse ( okhttpresponse ) ; <nl> return ; <nl> } <nl> - if ( data . code & gt ; = 400 ) { <nl> - anerror anerror = new anerror ( data ) ; <nl> + if ( okhttpresponse . code ( ) & gt ; = 400 ) { <nl> + anerror anerror = new anerror ( okhttpresponse ) ; <nl> anerror = request . parsenetworkerror ( anerror ) ; <nl> - anerror . seterrorcode ( data . code ) ; <nl> + anerror . seterrorcode ( okhttpresponse . code ( ) ) ; <nl> anerror . seterrordetail ( anconstants . response_from_server_error ) ; <nl> delivererror ( request , anerror ) ; <nl> return ; <nl> } <nl> + <nl> + anresponse response = request . parseresponse ( okhttpresponse ) ; <nl> + if ( ! response . issuccess ( ) ) { <nl> 
mmm a / android - networking / src / main / java / com / androidnetworking / internal / internalrunnable . java <nl> ppp b / android - networking / src / main / java / com / androidnetworking / internal / internalrunnable . java <nl> - andata data = null ; <nl> + private void goforuploadrequest ( ) { <nl> + response okhttpresponse = null ; <nl> try { <nl> - data = internalnetworking . performuploadrequest ( request ) ; <nl> - if ( data == null ) { <nl> + okhttpresponse = internalnetworking . performuploadrequest ( request ) ; <nl> + <nl> + if ( okhttpresponse == null ) { <nl> + anerror anerror = new anerror ( ) ; <nl> + anerror = request . parsenetworkerror ( anerror ) ; <nl> + anerror . seterrordetail ( anconstants . connection_error ) ; <nl> + anerror . seterrorcode ( 0 ) ; <nl> + delivererror ( request , anerror ) ; <nl> return ; <nl> } <nl> - if ( data . code == 304 ) { <nl> - request . finish ( ) ; <nl> + <nl> + if ( request . getresponseas ( ) == response . ok_http_response ) { <nl> + request . deliverokhttpresponse ( okhttpresponse ) ; <nl> return ; <nl> } <nl> - if ( data . code & gt ; = 400 ) { <nl> - anerror anerror = new anerror ( data ) ; <nl> + <nl> + if ( okhttpresponse . code ( ) & gt ; = 400 ) { <nl> + anerror anerror = new anerror ( okhttpresponse ) ; <nl> anerror = request . parsenetworkerror ( anerror ) ; <nl> - anerror . seterrorcode ( data . code ) ; <nl> + anerror . seterrorcode ( okhttpresponse . code ( ) ) ; <nl> anerror . seterrordetail ( anconstants . response_from_server_error ) ; <nl> delivererror ( request , anerror ) ; <nl> return ; <nl> } <nl> - anresponse response = request . parseresponse ( data ) ; <nl> + anresponse response = request . parseresponse ( okhttpresponse ) ; <nl> + if ( ! response . issuccess ( ) ) { <nl> + delivererror ( request , response . geterror ( ) ) ; <nl> 
mmm a / ds3_java_cli / src / test / java / com / spectralogic / ds3cli / ds3cli_test . java <nl> ppp b / ds3_java_cli / src / test / java / com / spectralogic / ds3cli / ds3cli_test . java <nl> " } " ; <nl>  <nl> final arguments args = new arguments ( new string [ ] { " ds3_java_cli " , " - e " , " localhost : 8080 " , " - k " , " key ! " , " - a " , " access " , " - c " , " delete_bucket " , " - b " , " bucketname " , " -  - output - format " , " json " } ) ; <nl> - final ds3client client = mock ( ds3client . class ) ; <nl> - final webresponse webresponse = mock ( webresponse . class ) ; <nl> - final headers headers = mock ( headers . class ) ; <nl> - when ( webresponse . getstatuscode ( ) ) . thenreturn ( 204 ) ; <nl> - when ( webresponse . getheaders ( ) ) . thenreturn ( headers ) ; <nl> - <nl> - final deletebucketresponse deletebucketresponse = new deletebucketresponse ( webresponse ) ; <nl> - when ( client . deletebucket ( any ( deletebucketrequest . class ) ) ) . thenreturn ( deletebucketresponse ) ; <nl> - <nl> - final clicommand command = clicommandfactory . getcommandexecutor ( args . getcommand ( ) ) . withprovider ( new ds3providerimpl ( client , null ) , null ) ; <nl> + final clicommand command = clicommandfactory . getcommandexecutor ( args . getcommand ( ) ) ; <nl> command . init ( args ) ; <nl> - final commandresponse result = command . render ( ) ; <nl> - asserttrue ( result . getmessage ( ) . endswith ( expected ) ) ; <nl> + asserttrue ( command instanceof deletebucket ) ; <nl> + final view view = command . getview ( ) ; <nl> + final string result = view . render ( new defaultresult ( " success : deleted bucket 'bucketname ' . " ) ) ; <nl> + asserttrue ( result . endswith ( expected ) ) ; <nl> + } <nl> 
mmm a / test / se / hiflyer / fettle / builder / statemachinebuildertest . java <nl> ppp b / test / se / hiflyer / fettle / builder / statemachinebuildertest . java <nl> machine . fireevent ( " " ) ; <nl>  <nl> - verifyonce ( ) . on ( entryaction ) . perform ( ) ; <nl> - verifynever ( ) . on ( exitaction ) . perform ( ) ; <nl> + verifyonce ( ) . on ( entryaction ) . perform ( any ( states . class ) , any ( states . class ) , any ( string . class ) , arguments . no_args ) ; <nl> + verifynever ( ) . on ( exitaction ) . perform ( any ( states . class ) , any ( states . class ) , any ( string . class ) , arguments . no_args ) ; <nl>  <nl> machine . fireevent ( " " ) ; <nl>  <nl> - verifyonce ( ) . on ( entryaction ) . perform ( ) ; <nl> - verifyonce ( ) . on ( exitaction ) . perform ( ) ; <nl> + verifyonce ( ) . on ( entryaction ) . perform ( any ( states . class ) , any ( states . class ) , any ( string . class ) , arguments . no_args ) ; <nl> + verifyonce ( ) . on ( exitaction ) . perform ( any ( states . class ) , any ( states . class ) , any ( string . class ) , arguments . no_args ) ; <nl> } <nl>  <nl> } <nl> 
mmm a / src / org / jgroups / protocols / pbcast / nakack2 . java <nl> ppp b / src / org / jgroups / protocols / pbcast / nakack2 . java <nl> + * benefit : fewer threads blocked on the same lock , these threads can be returned to the thread pool <nl> + * / <nl> + protected void removeanddeliver ( table & lt ; message & gt ; buf , address sender , boolean loopback , asciistring cluster_name ) { <nl> + atomicinteger adders=buf . getadders ( ) ; <nl> + if ( adders . getandincrement ( ) ! = 0 ) <nl> + return ; <nl> boolean remove_msgs=discard_delivered_msgs & & ! loopback ; <nl> - messagebatch batch=new messagebatch ( max_msg_batch_size ) . dest ( null ) . sender ( sender ) . clustername ( cluster_name ) . multicast ( true ) ; <nl> + messagebatch batch=new messagebatch ( buf . size ( ) ) . dest ( null ) . sender ( sender ) . clustername ( cluster_name ) . multicast ( true ) ; <nl> supplier & lt ; messagebatch & gt ; batch_creator= ( ) - & gt ; batch ; <nl> - while ( true ) { <nl> - batch . reset ( ) ; <nl> - buf . removemany ( processing , remove_msgs , max_msg_batch_size , <nl> - no_dummy_and_no_oob_delivered_msgs_and_no_dont_loopback_msgs , <nl> - batch_creator , batch_accumulator , batch_validator ) ; <nl> - if ( batch . isempty ( ) ) { <nl> - if ( rebroadcasting ) <nl> - checkforrebroadcasts ( ) ; <nl> - return ; <nl> + do { <nl> + try { <nl> + batch . reset ( ) ; <nl> + buf . removemany ( remove_msgs , 0 , no_dummy_and_no_oob_delivered_msgs_and_no_dont_loopback_msgs , <nl> + batch_creator , batch_accumulator ) ; <nl> } <nl> - deliverbatch ( batch ) ; <nl> + catch ( throwable t ) { <nl> + log . error ( " failed removing messages from table for " + sender , t ) ; <nl> + } <nl> + if ( ! batch . isempty ( ) ) <nl> + deliverbatch ( batch ) ; <nl> } <nl> - <nl> + while ( adders . decrementandget ( ) ! = 0 ) ; <nl> + if ( rebroadcasting ) <nl> + checkforrebroadcasts ( ) ; <nl> } <nl> 
mmm a / src / main / java / org / eclipselabs / garbagecat / domain / jdk / g1mixedpauseevent . java <nl> ppp b / src / main / java / org / eclipselabs / garbagecat / domain / jdk / g1mixedpauseevent . java <nl> + if ( logentry . matches ( regex ) ) { <nl> + pattern pattern = pattern . compile ( regex ) ; <nl> matcher matcher = pattern . matcher ( logentry ) ; <nl> if ( matcher . find ( ) ) { <nl> timestamp = jdkmath . convertsecstomillis ( matcher . group ( 1 ) ) . longvalue ( ) ; <nl> - combined = jdkmath . calckilobytes ( integer . parseint ( matcher . group ( 2 ) ) , matcher . group ( 3 ) . charat ( 0 ) ) ; <nl> - combinedend = jdkmath . calckilobytes ( integer . parseint ( matcher . group ( 4 ) ) , matcher . group ( 5 ) . charat ( 0 ) ) ; <nl> - combinedavailable = jdkmath . calckilobytes ( integer . parseint ( matcher . group ( 6 ) ) , <nl> - matcher . group ( 7 ) . charat ( 0 ) ) ; <nl> - duration = jdkmath . convertsecstomillis ( matcher . group ( 8 ) ) . intvalue ( ) ; <nl> + combined = jdkmath . calckilobytes ( integer . parseint ( matcher . group ( 2 ) ) , matcher . group ( 4 ) . charat ( 0 ) ) ; <nl> + combinedend = jdkmath . calckilobytes ( integer . parseint ( matcher . group ( 5 ) ) , matcher . group ( 7 ) . charat ( 0 ) ) ; <nl> + combinedavailable = jdkmath . calckilobytes ( integer . parseint ( matcher . group ( 8 ) ) , <nl> + matcher . group ( 10 ) . charat ( 0 ) ) ; <nl> + duration = jdkmath . convertsecstomillis ( matcher . group ( 11 ) ) . intvalue ( ) ; <nl> } <nl> } else if ( logentry . matches ( regex_preprocessed ) ) { <nl> 
mmm a / nginx - admin - ui / src / main / java / com / jslsolucoes / nginx / admin / repository / impl / upstreamrepositoryimpl . java <nl> ppp b / nginx - admin - ui / src / main / java / com / jslsolucoes / nginx / admin / repository / impl / upstreamrepositoryimpl . java <nl> @ override <nl> public upstream hasequals ( upstream upstream ) { <nl> - try { <nl> - stringbuilder hql = new stringbuilder ( " from upstream where name = : name " ) ; <nl> - if ( upstream . getid ( ) ! = null ) { <nl> - hql . append ( " and id & lt ; & gt ; : id " ) ; <nl> - } <nl> - query query = entitymanager . createquery ( hql . tostring ( ) ) . setparameter ( " name " , upstream . getname ( ) ) ; <nl> - if ( upstream . getid ( ) ! = null ) { <nl> - query . setparameter ( " id " , upstream . getid ( ) ) ; <nl> - } <nl> - return ( upstream ) query . getsingleresult ( ) ; <nl> - } catch ( noresultexception e ) { <nl> - return null ; <nl> + criteria criteria = session . createcriteria ( upstream . class ) ; <nl> + criteria . add ( restrictions . eq ( " name " , upstream . getname ( ) ) ) ; <nl> + if ( upstream . getid ( ) ! = null ) { <nl> + criteria . add ( restrictions . ne ( " id " , upstream . getid ( ) ) ) ; <nl> } <nl> + return ( upstream ) criteria . uniqueresult ( ) ; <nl> } <nl> + <nl> + @ override <nl> 
mmm a / src / test / java / innovimax / quixproc / datamodel / generator / test / testgenerator . java <nl> ppp b / src / test / java / innovimax / quixproc / datamodel / generator / test / testgenerator . java <nl> - } else { <nl> - <nl> - <nl> - for ( atreegenerator . type gtype : enumset . of ( atreegenerator . type . high_node_name_size , <nl> - atreegenerator . type . high_node_name_size , atreegenerator . type . high_node_density , <nl> - atreegenerator . type . high_node_depth ) ) { <nl> - for ( specialtype stype : specialtype . allowedmodifiers ( gtype ) ) { <nl> - for ( variation variation : variation . values ( ) ) { <nl> - agenerator generator = axmlgenerator . instance ( gtype , stype ) ; <nl> - system . out . println ( gtype+ " , " +stype+ " , " +variation ) ; <nl> - inputstream is = generator . getinputstream ( 10 , unit . mbyte , variation ) ; <nl> - quixeventstreamreader xqesr = new quixeventstreamreader ( new streamsource ( is ) ) ; <nl> - validquixtokenstream vqxs = new validquixtokenstream ( xqesr ) ; <nl> - while ( vqxs . hasnext ( ) ) { <nl> - vqxs . next ( ) ; <nl> - } <nl> - } <nl> + public static void main ( string [ ] args ) throws quixexception , ioexception { <nl> + for ( process process : process . values ( ) ) { <nl> + testall ( process , 10 , unit . mbyte ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / src / grepolis / io / loader . java <nl> ppp b / src / grepolis / io / loader . java <nl> - public static void loaddockstroops ( ) { <nl> - bufferedreader reader = null ; <nl> + } <nl>  <nl> - codesource codesource = grepolisbot . class . getprotectiondomain ( ) . getcodesource ( ) ; <nl> - file jarfile = null ; <nl> - try { <nl> - jarfile = new file ( codesource . getlocation ( ) . touri ( ) . getpath ( ) ) ; <nl> - } catch ( urisyntaxexception e ) { <nl> - e . printstacktrace ( ) ; <nl> - } <nl> - string jardir = null ; <nl> - if ( jarfile ! = null ) { <nl> - jardir = jarfile . getparentfile ( ) . getpath ( ) ; <nl> - } <nl> - string filename = jardir + file . separator + " saves " + file . separator + " dockssave . txt " ; <nl> - try { <nl> - reader = new bufferedreader ( new filereader ( filename ) ) ; <nl> - } catch ( exception ignored ) { / *error checked inside of loadaccount with creating an account . * / } <nl> + public static void loaddockstroops ( string directory ) { <nl> + bufferedreader reader = getbufferedreader ( directory , " dockssave . txt " ) ; <nl> string line ; <nl>  <nl> try { <nl> if ( reader ! = null ) { <nl> while ( ( line = reader . readline ( ) ) ! = null ) { <nl> string text [ ] = line . split ( " , " ) ; <nl> - arraylist & lt ; town & gt ; towns = grepolis . grepolisbot . gettowns ( ) ; <nl> + arraylist & lt ; town & gt ; towns ; <nl> + if ( directory . equals ( " saves " ) ) { <nl> + towns = grepolis . grepolisbot . gettowns ( ) ; <nl> + } else { <nl> + towns = queuepanel . gettemplatetowns ( ) ; <nl> + } <nl> town town ; <nl> docks docks = null ; <nl> - for ( string string : text ) { <nl> 
mmm a / library / src / main / java / org / dbtools / android / domain / rxandroidbasemanagerwritable . java <nl> ppp b / library / src / main / java / org / dbtools / android / domain / rxandroidbasemanagerwritable . java <nl> - } <nl> + databasewrapper & lt ; ? super androidbaserecord , ? super dbtoolscontentvalues & lt ; ? & gt ; & gt ; db = getwritabledatabase ( databasename ) ; <nl> + <nl> + int rowsaffectedcount = 0 ; <nl> + <nl> + checkdb ( db ) ; <nl> + boolean success = false ; <nl> + for ( int trycount = 0 ; trycount & lt ; max_try_count & & ! success ; trycount++ ) { <nl> + try { <nl> + rowsaffectedcount = db . update ( gettablename ( ) , contentvalues , where , whereargs ) ; <nl> + success = true ; <nl> + } catch ( exception ex ) { <nl> + ex . printstacktrace ( ) ; <nl> + } <nl> + } <nl> + <nl> + if ( success & & rowsaffectedcount & gt ; 0 ) { <nl> + notifytablelisteners ( false , db , new databasetablechange ( gettablename ( ) , false , true , false ) ) ; <nl> + } <nl>  <nl> - public int update ( @ nonnull string databasename , @ nonnull dbtoolscontentvalues contentvalues , @ nullable string where , @ nullable string [ ] whereargs ) { <nl> - return update ( getwritabledatabase ( databasename ) , contentvalues , where , whereargs ) ; <nl> + return rowsaffectedcount ; <nl> } <nl>  <nl> - public int update ( @ nonnull databasewrapper db , @ nonnull dbtoolscontentvalues contentvalues , @ nullable string where , @ nullable string [ ] whereargs ) { <nl> + public int delete ( @ nullable t e ) { <nl> 
mmm a / openam - federation / openam - federation - library / src / main / java / com / sun / identity / federation / services / termination / fsfedterminationhandler . java <nl> ppp b / openam - federation / openam - federation - library / src / main / java / com / sun / identity / federation / services / termination / fsfedterminationhandler . java <nl> - cookiedomainlist ) ; <nl> + fsutils . debug . message ( " setting age to " + <nl> + ifsconstants . persistent_cookie_age + " age " ) ; <nl> } <nl> - iterator iter = null ; <nl> - if ( cookiedomainlist ! = null ) { <nl> - iter = cookiedomainlist . iterator ( ) ; <nl> - while ( iter ! = null & & iter . hasnext ( ) ) { <nl> - fedcookie = cookieutils . newcookie ( federate_cookie_name , <nl> - cookievalue , <nl> - ifsconstants . persistent_cookie_age , <nl> - " / " , ( string ) iter . next ( ) ) ; <nl> - cookieutils . addcookietoresponse ( response , fedcookie ) ; <nl> - } <nl> - } else { <nl> - fedcookie = cookieutils . newcookie ( federate_cookie_name , <nl> - cookievalue , <nl> - ifsconstants . persistent_cookie_age , <nl> - " / " , null ) ; <nl> - cookieutils . addcookietoresponse ( response , fedcookie ) ; <nl> + set & lt ; string & gt ; domains = systemconfigurationutil . getcookiedomainsforrequest ( request ) ; <nl> + if ( fsutils . debug . messageenabled ( ) ) { <nl> + fsutils . debug . message ( " provider cookie domain list is " + domains ) ; <nl> + } <nl> + for ( string domain : domains ) { <nl> + cookieutils . addcookietoresponse ( response , cookieutils . newcookie ( federate_cookie_name , cookievalue , <nl> + ifsconstants . persistent_cookie_age , " / " , domain ) ) ; <nl> } <nl> } <nl> } catch ( fsaccountmgmtexception e ) { <nl> 
mmm a / hadoop - mini - clusters - hbase / src / test / java / com / github / sakserv / minicluster / impl / hbaselocalclustertest . java <nl> ppp b / hadoop - mini - clusters - hbase / src / test / java / com / github / sakserv / minicluster / impl / hbaselocalclustertest . java <nl> . sethbasewalreplicationenabled ( <nl> boolean . parseboolean ( propertyparser . getproperty ( configvars . hbase_wal_replication_enabled_key ) ) ) <nl> . sethbaseconfiguration ( new configuration ( ) ) <nl> + . activerestgateway ( ) <nl> + . sethbaseresthost ( propertyparser . getproperty ( configvars . hbase_rest_host_key ) ) <nl> + . sethbaserestport ( <nl> + integer . valueof ( propertyparser . getproperty ( configvars . hbase_rest_port_key ) ) ) <nl> + . sethbaserestinfoport ( <nl> + integer . valueof ( propertyparser . getproperty ( configvars . hbase_rest_info_port_key ) ) ) <nl> + . sethbaserestreadonly ( <nl> + boolean . valueof ( propertyparser . getproperty ( configvars . hbase_rest_readonly_key ) ) ) <nl> + . sethbaserestthreadmax ( <nl> + integer . valueof ( propertyparser . getproperty ( configvars . hbase_rest_threadmax_key ) ) ) <nl> + . sethbaserestthreadmin ( <nl> + integer . valueof ( propertyparser . getproperty ( configvars . hbase_rest_threadmin_key ) ) ) <nl> + . build ( ) <nl> . build ( ) ; <nl> } <nl>  <nl> 
mmm a / carbon / src / main / java / carbon / widget / framelayout . java <nl> ppp b / carbon / src / main / java / carbon / widget / framelayout . java <nl> super . onmeasure ( widthmeasurespec , heightmeasurespec ) ; <nl> if ( percentlayouthelper . handlemeasuredstatetoosmall ( ) ) <nl> super . onmeasure ( widthmeasurespec , heightmeasurespec ) ; <nl> - setmeasureddimension ( math . min ( getmeasuredwidth ( ) , maxwidth ) , math . min ( getmeasuredheight ( ) , maxheight ) ) ; <nl> + if ( getmeasuredwidth ( ) & gt ; maxwidth || getmeasuredheight ( ) & gt ; maxheight ) { <nl> + if ( getmeasuredwidth ( ) & gt ; maxwidth ) <nl> + widthmeasurespec = measurespec . makemeasurespec ( maxwidth , measurespec . exactly ) ; <nl> + if ( getmeasuredheight ( ) & gt ; maxheight ) <nl> + heightmeasurespec = measurespec . makemeasurespec ( maxheight , measurespec . exactly ) ; <nl> + super . onmeasure ( widthmeasurespec , heightmeasurespec ) ; <nl> + } <nl> } <nl> - } <nl> 
mmm a / src / main / java / org / warcbase / analysis / graph / extractsitelinks . java <nl> ppp b / src / main / java / org / warcbase / analysis / graph / extractsitelinks . java <nl> job . setnumreducetasks ( reducetasks ) ; /  / no reducers <nl>  <nl> if ( ishdfsinput ) { /  / hdfs input <nl> - fileinputformat . setinputpaths ( job , new path ( hdfspath ) ) ; <nl> + path path = new path ( hdfspath ) ; <nl> + remoteiterator & lt ; locatedfilestatus & gt ; itr = fs . listfiles ( path , true ) ; <nl> + locatedfilestatus filestatus ; <nl> + while ( itr . hasnext ( ) ) { <nl> + filestatus = itr . next ( ) ; <nl> + path p = filestatus . getpath ( ) ; <nl> + if ( ( p . getname ( ) . endswith ( " . warc . gz " ) ) || ( p . getname ( ) . endswith ( " . warc " ) ) ) { <nl> + multipleinputs . addinputpath ( job , p , wacwarcinputformat . class , extractsitelinkswarcmapper . class ) ; <nl> + } else { <nl> + multipleinputs . addinputpath ( job , p , wacarcinputformat . class , extractsitelinksarcmapper . class ) ; <nl> + } <nl> + } <nl>  <nl> - job . setinputformatclass ( wacarcinputformat . class ) ; <nl> job . setmapoutputkeyclass ( intwritable . class ) ; <nl> job . setmapoutputvalueclass ( intwritable . class ) ; <nl> - <nl> - job . setmapperclass ( extractsitelinksmapper . class ) ; <nl> } else { /  / hbase input <nl> throw new unsupportedoperationexception ( " hbase not supported yet ! " ) ; <nl> } <nl> 
mmm a / src / main / java / com / builtbroken / militarybasedecor / core / militarybasedecor . java <nl> ppp b / src / main / java / com / builtbroken / militarybasedecor / core / militarybasedecor . java <nl> + super . preinit ( event ) ; <nl> + getmanager ( ) . settab ( main_tab ) ; <nl> configmanager . initconfig ( ) ; <nl> - <nl> - if ( configmanager . vanilla_enabled ) <nl> - { <nl> - loader . applymodule ( new vanillamodule ( ) ) ; <nl> - } <nl> - <nl> - if ( configmanager . gunpowder_era_enabled ) <nl> - { <nl> - loader . applymodule ( new gunpowdermodule ( ) ) ; <nl> - } <nl> - <nl> - if ( configmanager . world_war_one_enabled ) <nl> - { <nl> - loader . applymodule ( new worldwar1module ( ) ) ; <nl> - } <nl> - <nl> - if ( configmanager . world_war_two_enabled ) <nl> - { <nl> - loader . applymodule ( new worldwar2module ( ) ) ; <nl> - } <nl> - <nl> - if ( configmanager . cold_war_enabled ) <nl> - { <nl> - loader . applymodule ( new coldwarmodule ( ) ) ; <nl> - } <nl> - <nl> - if ( configmanager . future_enabled ) <nl> - { <nl> - loader . applymodule ( new futuremodule ( ) ) ; <nl> - } <nl> - if ( configmanager . blastcraft_enabled ) <nl> - { <nl> - loader . applymodule ( new blastcraft ( ) ) ; <nl> - } <nl> + loader . applymodule ( vanillamodule . class , configmanager . vanilla_enabled ) ; <nl> + loader . applymodule ( gunpowdermodule . class , configmanager . gunpowder_era_enabled ) ; <nl> + loader . applymodule ( worldwar1module . class , configmanager . world_war_one_enabled ) ; <nl> + loader . applymodule ( worldwar2module . class , configmanager . world_war_two_enabled ) ; <nl> + loader . applymodule ( coldwarmodule . class , configmanager . cold_war_enabled ) ; <nl> + loader . applymodule ( blastcraft . class , configmanager . blastcraft_enabled ) ; <nl> } <nl> + <nl> + @ override <nl> 
mmm a / jme3 - terrain - editor / src / com / jme3 / gde / terraineditor / sky / skyboxvisualpanel2 . java <nl> ppp b / jme3 - terrain - editor / src / com / jme3 / gde / terraineditor / sky / skyboxvisualpanel2 . java <nl> component view = editorbottom . getcustomeditor ( ) ; <nl> view . setvisible ( true ) ; <nl> - if ( editorbottom . getvalue ( ) ! = null ) { <nl> - texture tex = ( texture ) editorbottom . getvalue ( ) ; <nl> - string selected = tex . getkey ( ) . getname ( ) ; <nl> - <nl> - if ( selected . tolowercase ( ) . endswith ( " . dds " ) ) { <nl> - if ( ddspreview == null ) { <nl> - ddspreview = new ddspreview ( ( projectassetmanager ) sceneapplication . getapplication ( ) . getassetmanager ( ) ) ; <nl> - } <nl> - ddspreview . requestpreview ( selected , " " , 80 , 80 , bottompic , null ) ; <nl> - <nl> - } else { <nl> - icon newicon = imageutilities . image2icon ( imagetoawt . convert ( tex . getimage ( ) , false , true , 0 ) ) ; <nl> - bottompic . seticon ( newicon ) ; <nl> - } <nl> + if ( editorbottom . getastext ( ) ! = null ) { <nl> + string selected = editorbottom . getastext ( ) ; <nl> + gettexturepreview ( ) . requestpreview ( selected , " " , 80 , 80 , bottompic , null ) ; <nl> } <nl> } /  / gen - last : event_multipletexbottomloadbuttonactionperformed <nl> 
mmm a / http / src / test / java / ro / polak / http / protocolit . java <nl> ppp b / http / src / test / java / ro / polak / http / protocolit . java <nl> @ test <nl> public void shouldreturn400badrequestontoolongmethod ( ) throws ioexception { <nl> - string requestbody = requestbuilder . defaultbuilder ( ) <nl> + requestbuilder requestbuilder = requestbuilder . defaultbuilder ( ) <nl> . method ( " abcabcabcabcabc " , " / " ) <nl> - . withcloseconnection ( ) <nl> - . tostring ( ) ; <nl> + . withcloseconnection ( ) ; <nl>  <nl> - socket socket = null ; <nl> - outputstream out ; <nl> - socket = getsocket ( ) ; <nl> - out = socket . getoutputstream ( ) ; <nl> - out . write ( requestbody . getbytes ( ) ) ; <nl> - bufferedreader in = new bufferedreader ( new inputstreamreader ( socket . getinputstream ( ) ) ) ; <nl> - string line ; <nl> - int numberoflinesread = 0 ; <nl> - while ( ( line = in . readline ( ) ) ! = null ) { <nl> - if ( ++numberoflinesread == 1 ) { <nl> - assertthat ( line , startswith ( " http / 1 . 1 400 " ) ) ; <nl> - break ; <nl> - } <nl> - } <nl> - <nl> - if ( numberoflinesread == 0 ) { <nl> - fail ( " no server response was read " ) ; <nl> - } <nl> - <nl> - socket . close ( ) ; <nl> + expectcode ( requestbuilder , 400 ) ; <nl> } <nl>  <nl> @ test <nl> 
mmm a / src / main / java / net / hasor / rsf / center / server / manager / servicemanager . java <nl> ppp b / src / main / java / net / hasor / rsf / center / server / manager / servicemanager . java <nl> - public result & lt ; boolean & gt ; requestproviders ( interaddress rsfaddress , string registerid , string serviceid ) { <nl> - result & lt ; string & gt ; objectidresult = this . checkandevalobjectid ( rsfaddress , registerid , serviceid ) ; <nl> - string oriobjectkey = null ; <nl> - if ( ! objectidresult . issuccess ( ) ) { <nl> + result & lt ; objectdo & gt ; consumerresult = this . dataadapter . queryobjectbyid ( registerid ) ; <nl> + if ( consumerresult == null || ! consumerresult . issuccess ( ) || consumerresult . getresult ( ) == null ) { <nl> + return buildfailedresult ( consumerresult ) ; <nl> + } <nl> + if ( ! stringutils . equals ( rsfcenterconstants . center_datakey_consumer , consumerresult . getresult ( ) . gettype ( ) ) ) { <nl> resultdo & lt ; boolean & gt ; result = new resultdo & lt ; boolean & gt ; ( ) ; <nl> + result . seterrorinfo ( errorcode . servicetypefailed_error ) ; <nl> result . setsuccess ( false ) ; <nl> - result . setresult ( false ) ; <nl> - result . seterrorinfo ( objectidresult . geterrorinfo ( ) ) ; <nl> return result ; <nl> - } else { <nl> - oriobjectkey = objectidresult . getresult ( ) ; <nl> } <nl> 
mmm a / src / net / rithms / riot / api / leagueapi . java <nl> ppp b / src / net / rithms / riot / api / leagueapi . java <nl> + return dto ; <nl> } <nl>  <nl> public static map & lt ; string , list & lt ; league & gt ; & gt ; getleaguebyteams ( region region , string key , string teamids ) throws riotapiexception { <nl> - string url = region . getendpoint ( ) + version + " league / by - team / " + teamids + " ? api_key= " + key ; <nl> - <nl> - map & lt ; string , list & lt ; league & gt ; & gt ; leagues = null ; <nl> - try { <nl> - leagues = new gson ( ) . fromjson ( request . sendget ( url ) , new typetoken & lt ; map & lt ; string , list & lt ; league & gt ; & gt ; & gt ; ( ) { <nl> - } . gettype ( ) ) ; <nl> - } catch ( jsonsyntaxexception e ) { <nl> - throw new riotapiexception ( riotapiexception . parse_failure ) ; <nl> - } <nl> - if ( leagues == null ) { <nl> - throw new riotapiexception ( riotapiexception . parse_failure ) ; <nl> - } <nl> - <nl> - return leagues ; <nl> + request request = new request ( ) ; <nl> + request . addtourl ( region . getendpoint ( ) , version , " league / by - team / " , teamids , " ? api_key= " , key ) ; <nl> + request . execute ( ) ; <nl> + map & lt ; string , list & lt ; league & gt ; & gt ; dto = request . getdto ( new typetoken & lt ; map & lt ; string , list & lt ; league & gt ; & gt ; & gt ; ( ) { <nl> + } . gettype ( ) ) ; <nl> + return dto ; <nl> + } <nl> 
mmm a / src / org / lwjgl / demo / vulkan / clearscreendemo . java <nl> ppp b / src / org / lwjgl / demo / vulkan / clearscreendemo . java <nl> } <nl>  <nl> private static vkimagememorybarrier . buffer createprepresentbarrier ( long presentimage ) { <nl> - vkimagememorybarrier . buffer imagememorybarrier = vkimagememorybarrier . calloc ( 1 ) ; <nl> - imagememorybarrier . stype ( vk_structure_type_image_memory_barrier ) ; <nl> - imagememorybarrier . pnext ( null ) ; <nl> - imagememorybarrier . srcaccessmask ( vk_access_color_attachment_write_bit ) ; <nl> - imagememorybarrier . dstaccessmask ( 0 ) ; <nl> - imagememorybarrier . oldlayout ( vk_image_layout_color_attachment_optimal ) ; <nl> - imagememorybarrier . newlayout ( vk_image_layout_present_src_khr ) ; <nl> - imagememorybarrier . srcqueuefamilyindex ( vk_queue_family_ignored ) ; <nl> - imagememorybarrier . dstqueuefamilyindex ( vk_queue_family_ignored ) ; <nl> - vkimagesubresourcerange subresourcerange = imagememorybarrier . subresourcerange ( ) ; <nl> - subresourcerange . aspectmask ( vk_image_aspect_color_bit ) ; <nl> - subresourcerange . basemiplevel ( 0 ) ; <nl> - subresourcerange . levelcount ( 1 ) ; <nl> - subresourcerange . basearraylayer ( 0 ) ; <nl> - subresourcerange . layercount ( 1 ) ; <nl> + vkimagememorybarrier . buffer imagememorybarrier = vkimagememorybarrier . calloc ( 1 ) <nl> + . stype ( vk_structure_type_image_memory_barrier ) <nl> + . pnext ( null ) <nl> + . srcaccessmask ( vk_access_color_attachment_write_bit ) <nl> + . dstaccessmask ( 0 ) <nl> + . oldlayout ( vk_image_layout_color_attachment_optimal ) <nl> + . newlayout ( vk_image_layout_present_src_khr ) <nl> + . srcqueuefamilyindex ( vk_queue_family_ignored ) <nl> + . dstqueuefamilyindex ( vk_queue_family_ignored ) ; <nl> + imagememorybarrier . subresourcerange ( ) <nl> + . aspectmask ( vk_image_aspect_color_bit ) <nl> + . basemiplevel ( 0 ) <nl> + . levelcount ( 1 ) <nl> + . basearraylayer ( 0 ) <nl> + . layercount ( 1 ) ; <nl> imagememorybarrier . image ( presentimage ) ; <nl> return imagememorybarrier ; <nl> } <nl> 
mmm a / jdt - patch / e43 / org . eclipse . jdt . core / compiler / org / eclipse / jdt / internal / compiler / ast / membervaluepair . java <nl> ppp b / jdt - patch / e43 / org . eclipse . jdt . core / compiler / org / eclipse / jdt / internal / compiler / ast / membervaluepair . java <nl> - private expression repairclassliteralreference ( expression exp , blockscope scope , typebinding [ ] valuetype ) { <nl> - typebinding vtb = null ; <nl> + private static expression repairclassliteralreference ( expression exp , blockscope scope ) { <nl> if ( exp instanceof singlenamereference ) { <nl> - vtb = exp . resolvetype ( scope ) ; <nl> + if ( exp . resolvetype ( scope ) ! = null ) { <nl> singlenamereference ref = ( singlenamereference ) exp ; <nl> - if ( vtb ! = null & & arrays . equals ( ref . token , vtb . sourcename ( ) ) ) { <nl> return new classliteralaccess ( ref . sourceend , new singletypereference ( ref . token , ( ( long ) ref . sourcestart ) & lt ; & lt ; 32 | ref . sourceend ) ) ; <nl> } <nl> - } else if ( this . value instanceof qualifiednamereference ) { <nl> - vtb = exp . resolvetype ( scope ) ; <nl> + } else if ( exp instanceof qualifiednamereference ) { <nl> + if ( exp . resolvetype ( scope ) ! = null ) { <nl> qualifiednamereference ref = ( qualifiednamereference ) exp ; <nl> - if ( vtb ! = null & & arrays . equals ( ref . tokens [ ref . tokens . length - 1 ] , vtb . sourcename ( ) ) ) { <nl> return new classliteralaccess ( ref . sourceend , new qualifiedtypereference ( ref . tokens , ref . sourcepositions ) ) ; <nl> } <nl> } <nl> - if ( valuetype ! = null ) { <nl> + return exp ; <nl> 
mmm a / src / jwiki / core / caction . java <nl> ppp b / src / jwiki / core / caction . java <nl> + * @ param reason the edit summary . <nl> + * @ return true if we were successful . <nl> + * / <nl> private static boolean unstash ( wiki wiki , string filekey , string title , string text , string reason ) <nl> { <nl> colorlog . info ( wiki , string . format ( " unstashing ' % s ' from temporary archive @ ' % s ' " , title , filekey ) ) ; <nl> - urlbuilder ub = wiki . makeub ( " upload " ) ; <nl> - <nl> - string [ ] es = fstring . massenc ( title , text , reason , wiki . token , filekey ) ; <nl> - string posttext = urlbuilder . chainparams ( " filename " , es [ 0 ] , " text " , es [ 1 ] , " comment " , es [ 2 ] , " ignorewarnings " , " true " , <nl> - " filekey " , es [ 4 ] , " token " , es [ 3 ] ) ; <nl> - try <nl> - { <nl> - return crequest . post ( ub . makeurl ( ) , posttext , wiki . cookiejar , crequest . urlenc ) . resultis ( " success " ) ; <nl> - } <nl> - catch ( ioexception e ) <nl> - { <nl> + reply r = doaction ( wiki , wiki . makeub ( " upload " ) , " filename " , title , " text " , text , " comment " , reason , " token " , <nl> + wiki . token , " filekey " , filekey , " ignorewarnings " , " true " ) ; <nl> + return r ! = null & & r . resultis ( " success " ) ; <nl> + } <nl> + } <nl> 
mmm a / src / java / org / jivesoftware / sparkimpl / plugin / systray / systrayplugin . java <nl> ppp b / src / java / org / jivesoftware / sparkimpl / plugin / systray / systrayplugin . java <nl> @ override <nl> public void stopflashing ( window window ) { <nl> - trayicon . setimage ( availableicon . getimage ( ) ) ; <nl> + presence = workspace . getinstance ( ) . getstatusbar ( ) . getpresence ( ) ; <nl> + if ( presence . getmode ( ) == presence . mode . available ) { <nl> + trayicon . setimage ( availableicon . getimage ( ) ) ; <nl> + } else if ( presence . getmode ( ) == presence . mode . away <nl> + || presence . getmode ( ) == presence . mode . xa ) { <nl> + trayicon . setimage ( awayicon . getimage ( ) ) ; <nl> + } else if ( presence . getmode ( ) == presence . mode . dnd ) { <nl> + trayicon . setimage ( dndicon . getimage ( ) ) ; <nl> + } else { <nl> + trayicon . setimage ( availableicon . getimage ( ) ) ; <nl> + } <nl> newmessage = false ; <nl> chatmessagehandler . clearunreadmessages ( ) ; <nl> - } <nl> 
mmm a / src / main / java / edu / uncc / cs / bridges_vs1 / structure / adtvisualizer . java <nl> ppp b / src / main / java / edu / uncc / cs / bridges_vs1 / structure / adtvisualizer . java <nl> } <nl> } <nl>  <nl> - return " { " <nl> - + " \ " name \ " : \ " edu . uncc . cs . bridges \ " , " <nl> - + " \ " version \ " : \ " 0 . 4 . 0 \ " , " <nl> - + " \ " visual \ " : \ " " +visualizertype+ " \ " , " <nl> - + " \ " nodes \ " : [ " + dataformatter . trimcomma ( nodes ) + " ] , " <nl> - + " \ " links \ " : [ " + dataformatter . trimcomma ( links ) + " ] " <nl> - + " } " ; <nl> + stringbuilder s = new stringbuilder ( ) ; <nl> + <nl> + s . append ( " { " ) . <nl> + append ( " \ " name \ " : \ " edu . uncc . cs . bridges \ " , " ) . <nl> + append ( " \ " version \ " : \ " 0 . 4 . 0 \ " , " ) . <nl> + append ( " \ " visual \ " : \ " " +visualizertype+ " \ " , " ) . <nl> + append ( " \ " nodes \ " : [ " ) . append ( dataformatter . trimcomma ( nodes ) ) . append ( " ] , " ) . <nl> + append ( " \ " links \ " : [ " ) . append ( dataformatter . trimcomma ( links ) ) . append ( " ] " ) . <nl> + append ( " } " ) ; <nl> + if ( this . isvisualizejson ( ) ) <nl> + system . out . println ( s . tostring ( ) ) ; <nl> + return s . tostring ( ) ; <nl> } <nl>  <nl> / ** <nl> 
mmm a / services / core / java / com / android / server / content / contentservice . java <nl> ppp b / services / core / java / com / android / server / content / contentservice . java <nl> final int pid = binder . getcallingpid ( ) ; <nl> final int callinguserhandle = userhandle . getcallinguserid ( ) ; <nl> - <nl> - userhandle = handleincominguser ( uri , pid , uid , <nl> - intent . flag_grant_write_uri_permission , userhandle ) ; <nl> - <nl> - final string msg = localservices . getservice ( activitymanagerinternal . class ) <nl> - . checkcontentprovideraccess ( uri . getauthority ( ) , userhandle ) ; <nl> - if ( msg ! = null ) { <nl> - log . w ( tag , " ignoring notify for " + uri + " from " + uid + " : " + msg ) ; <nl> - return ; <nl> + if ( callinguserhandle ! = userhandle ) { <nl> + if ( checkuripermission ( uri , pid , uid , intent . flag_grant_write_uri_permission , <nl> + userhandle ) ! = packagemanager . permission_granted ) { <nl> + enforcecrossuserpermission ( userhandle , " no permission to notify other users " ) ; <nl> + } <nl> } <nl>  <nl> + if ( userhandle & lt ; 0 ) { <nl> + if ( userhandle == userhandle . user_current ) { <nl> + userhandle = activitymanager . getcurrentuser ( ) ; <nl> + } else if ( userhandle ! = userhandle . user_all ) { <nl> + throw new invalidparameterexception ( " bad user handle for notifychange : " <nl> + + userhandle ) ; <nl> + } <nl> + } <nl> 
mmm a / src / main / java / org / literacyapp / web / content / multimedia / image / imagecreatecontroller . java <nl> ppp b / src / main / java / org / literacyapp / web / content / multimedia / image / imagecreatecontroller . java <nl> image . settimelastupdate ( calendar . getinstance ( ) ) ; <nl> imagedao . create ( image ) ; <nl>  <nl> - contributor contributor = ( contributor ) session . getattribute ( " contributor " ) ; <nl> - <nl> - contentcreationevent contentcreationevent = new contentcreationevent ( ) ; <nl> - contentcreationevent . setcontributor ( contributor ) ; <nl> - contentcreationevent . setcontent ( image ) ; <nl> - contentcreationevent . setcalendar ( calendar . getinstance ( ) ) ; <nl> - contentcreationeventdao . create ( contentcreationevent ) ; <nl> - <nl> - if ( environmentcontextloaderlistener . env == environment . prod ) { <nl> - string text = urlencoder . encode ( <nl> - contributor . getfirstname ( ) + " just added a new image : \ n " + <nl> - " â¢ language : " + image . getlocale ( ) . getlanguage ( ) + " \ n " + <nl> - " â¢ title : \ " " + image . gettitle ( ) + " \ " \ n " + <nl> - " â¢ image format : " + image . getimageformat ( ) + " \ n " + <nl> - " see " ) + " http : /  / literacyapp . org / content / multimedia / image / list " ; <nl> - string iconurl = contributor . getimageurl ( ) ; <nl> - slackapihelper . postmessage ( team . content_creation , text , iconurl , " http : /  / literacyapp . org / image / " + image . getid ( ) + " . " + image . getimageformat ( ) . tostring ( ) . tolowercase ( ) ) ; <nl> - } <nl> - <nl> return " redirect : / content / multimedia / image / list " ; <nl> 
mmm a / src / main / java / ldbc / snb / datagen / hadoop / hadoopmergefriendshipfiles . java <nl> ppp b / src / main / java / ldbc / snb / datagen / hadoop / hadoopmergefriendshipfiles . java <nl> + public void reduce ( tuplekey key , iterable & lt ; person & gt ; valueset , context context ) <nl> + throws ioexception , interruptedexception { <nl> + <nl> + arraylist & lt ; knows & gt ; knows = new arraylist & lt ; knows & gt ; ( ) ; <nl> + person person = null ; <nl> + int index = 0 ; <nl> + for ( person p : valueset ) { <nl> + if ( index == 0 ) { <nl> person = new person ( p ) ; <nl> - } else { <nl> - for ( knows k : p . knows ( ) ) { <nl> - person . knows ( ) . add ( k ) ; <nl> - } <nl> + } <nl> + for ( knows k : p . knows ( ) ) { <nl> + knows . add ( k ) ; <nl> } <nl> index++ ; <nl> + } <nl> + person . knows ( ) . clear ( ) ; <nl> + knows . fullcomparator comparator = new knows . fullcomparator ( ) ; <nl> + collections . sort ( knows , comparator ) ; <nl> + if ( knows . size ( ) & gt ; 0 ) { <nl> + long currentto = knows . get ( 0 ) . to ( ) . accountid ( ) ; <nl> + person . knows ( ) . add ( knows . get ( 0 ) ) ; <nl> + for ( index = 1 ; index & lt ; knows . size ( ) ; ++index ) { <nl> + knows nextknows = knows . get ( index ) ; <nl> + if ( currentto ! = knows . get ( index ) . to ( ) . accountid ( ) ) { <nl> + person . knows ( ) . add ( nextknows ) ; <nl> + currentto = nextknows . to ( ) . accountid ( ) ; <nl> + } else { <nl> + numrepeated++ ; <nl> + } <nl> 
mmm a / src / example / org / deidentifier / arx / examples / example49 . java <nl> ppp b / src / example / org / deidentifier / arx / examples / example49 . java <nl> system . out . println ( " - solution : " + arrays . tostring ( node . gettransformation ( ) ) ) ; <nl> system . out . println ( " * optimal : " + result . getlattice ( ) . iscomplete ( ) ) ; <nl> system . out . println ( " * time needed : " + result . gettime ( ) + " [ ms ] " ) ; <nl> - system . out . println ( " * minimal reduction in publisher benefit : " + result . getconfiguration ( ) . getqualitymodel ( ) . createinstanceoflowestscore ( ) ) ; <nl> - system . out . println ( " * maximal reduction in publisher benefit : " + result . getconfiguration ( ) . getqualitymodel ( ) . createinstanceofhighestscore ( ) ) ; <nl> - system . out . println ( " * reduction in publisher benefit : " + node . getlowestscore ( ) + " ( " + <nl> - node . getlowestscore ( ) . relativeto ( result . getconfiguration ( ) . getqualitymodel ( ) . createinstanceoflowestscore ( ) , <nl> - result . getconfiguration ( ) . getqualitymodel ( ) . createinstanceofhighestscore ( ) ) * 100 + " % ) " ) ; <nl> + for ( qualitymetadata & lt ; ? & gt ; metadata : node . getlowestscore ( ) . getmetadata ( ) ) { <nl> + system . out . println ( " * " + metadata . getparameter ( ) + " : " + metadata . getvalue ( ) ) ; <nl> + } <nl> system . out . println ( " * suppressed records : " + handle . getstatistics ( ) . getequivalenceclassstatistics ( ) . getnumberofoutlyingtuples ( ) ) ; <nl>  <nl> - } <nl> 
mmm a / spark / src / main / java / edu / berkeley / cs / succinct / streams / succinctfilestream . java <nl> ppp b / spark / src / main / java / edu / berkeley / cs / succinct / streams / succinctfilestream . java <nl> - int m = buf . length ; <nl> - long c1 , c2 ; <nl> + int m = buf . length ; <nl> + long c1 , c2 ; <nl>  <nl> - if ( alphabetmap . containskey ( buf [ m - 1 ] ) ) { <nl> - range . first = alphabetmap . get ( buf [ m - 1 ] ) . first ; <nl> - byte nextbyte = alphabetmap . get ( buf [ m - 1 ] ) . second + 1 == getalphabetsize ( ) ? <nl> - succinctcore . eoa : <nl> - alphabet [ alphabetmap . get ( buf [ m - 1 ] ) . second + 1 ] ; <nl> - range . second = alphabetmap . get ( nextbyte ) . first - 1 ; <nl> - } else { <nl> - return new range ( 0l , - 1l ) ; <nl> - } <nl> + int pos = findcharacter ( buf [ m - 1 ] ) ; <nl> + if ( pos & gt ; = 0 ) { <nl> + range . first = columnoffsets . get ( pos ) ; <nl> + range . second = <nl> + ( ( pos + 1 ) == getalphabetsize ( ) ? getoriginalsize ( ) : columnoffsets . get ( pos + 1 ) ) - 1 ; <nl> + } else { <nl> + return new range ( 0l , - 1l ) ; <nl> + } <nl> 
mmm a / jeta / src / main / java / org / brooth / jeta / metasitory / criteria . java <nl> ppp b / jeta / src / main / java / org / brooth / jeta / metasitory / criteria . java <nl> criteria criteria = ( criteria ) o ; <nl> - return objects . equal ( mastereq , criteria . mastereq ) & & <nl> - objects . equal ( mastereqdeep , criteria . mastereqdeep ) & & <nl> - objects . equal ( usesany , criteria . usesany ) & & <nl> - objects . equal ( usesall , criteria . usesall ) ; <nl> + <nl> + if ( mastereq ! = null ? ! mastereq . equals ( criteria . mastereq ) : criteria . mastereq ! = null ) <nl> + return false ; <nl> + if ( mastereqdeep ! = null ? ! mastereqdeep . equals ( criteria . mastereqdeep ) : criteria . mastereqdeep ! = null ) <nl> + return false ; <nl> + if ( usesany ! = null ? ! usesany . equals ( criteria . usesany ) : criteria . usesany ! = null ) <nl> + return false ; <nl> + return usesall ! = null ? usesall . equals ( criteria . usesall ) : criteria . usesall == null ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / nd4j - backends / nd4j - backend - impls / nd4j - cuda / src / main / java / org / nd4j / linalg / jcublas / ops / executioner / cudaexecutioner . java <nl> ppp b / nd4j - backends / nd4j - backend - impls / nd4j - cuda / src / main / java / org / nd4j / linalg / jcublas / ops / executioner / cudaexecutioner . java <nl> } <nl>  <nl> indarray ret = null ; <nl> - if ( op . zerodouble ( ) & gt ; - 0 . 01f & & op . zerodouble ( ) & lt ; 0 . 01f ) { <nl> + if ( 0 . 0 + math . abs ( op . zerodouble ( ) ) & lt ; = nd4j . eps_threshold ) { <nl> ret = nd4j . zeros ( retshape ) ; <nl> } else { <nl> - ret = nd4j . valuearrayof ( retshape , op . zerodouble ( ) ) ; <nl> + if ( op . x ( ) . data ( ) . datatype ( ) == databuffer . type . double ) <nl> + ret = nd4j . valuearrayof ( retshape , op . zerodouble ( ) ) ; <nl> + else if ( op . x ( ) . data ( ) . datatype ( ) == databuffer . type . float ) <nl> + ret = nd4j . valuearrayof ( retshape , op . zerofloat ( ) ) ; <nl> + else if ( op . x ( ) . data ( ) . datatype ( ) == databuffer . type . half ) <nl> + ret = nd4j . valuearrayof ( retshape , op . zerohalf ( ) ) ; <nl> + } <nl> + <nl> + op . setz ( ret ) ; <nl> 
mmm a / src / main / java / ivorius / ivtoolkit / rendering / grid / cubemesh . java <nl> ppp b / src / main / java / ivorius / ivtoolkit / rendering / grid / cubemesh . java <nl> + renderer . pos ( x , y1 , z2 ) . tex ( icon . getmaxu ( ) , icon . getminv ( ) ) . endvertex ( ) ; <nl> + } <nl> + <nl> public static void rendersouth ( double x1 , double y1 , double x2 , double y2 , double z , icon icon ) <nl> { <nl> worldrenderer renderer = tessellator . getinstance ( ) . getworldrenderer ( ) ; <nl> - renderer . addvertexwithuv ( x1 , y1 , z , icon . getminu ( ) , icon . getminv ( ) ) ; <nl> - renderer . addvertexwithuv ( x2 , y1 , z , icon . getminu ( ) , icon . getmaxv ( ) ) ; <nl> - renderer . addvertexwithuv ( x2 , y2 , z , icon . getmaxu ( ) , icon . getmaxv ( ) ) ; <nl> - renderer . addvertexwithuv ( x1 , y2 , z , icon . getmaxu ( ) , icon . getminv ( ) ) ; <nl> + renderer . pos ( x1 , y1 , z ) . tex ( icon . getminu ( ) , icon . getminv ( ) ) . endvertex ( ) ; <nl> + renderer . pos ( x2 , y1 , z ) . tex ( icon . getminu ( ) , icon . getmaxv ( ) ) . endvertex ( ) ; <nl> + renderer . pos ( x2 , y2 , z ) . tex ( icon . getmaxu ( ) , icon . getmaxv ( ) ) . endvertex ( ) ; <nl> + renderer . pos ( x1 , y2 , z ) . tex ( icon . getmaxu ( ) , icon . getminv ( ) ) . endvertex ( ) ; <nl> } <nl>  <nl> public static void renderwest ( double z1 , double y1 , double z2 , double y2 , double x , icon icon ) <nl> 
mmm a / src / net / rithms / riot / api / statsapi . java <nl> ppp b / src / net / rithms / riot / api / statsapi . java <nl> private static final string version = " / v1 . 3 / " ; <nl>  <nl> public static playerstatssummarylist getplayerstatssummary ( region region , season season , string key , long summonerid ) throws riotapiexception { <nl> - string url = region . getendpoint ( ) + version + " stats / by - summoner / " + summonerid + " / summary ? api_key= " + key ; <nl> + request request = new request ( ) ; <nl> + request . addtourl ( region . getendpoint ( ) , version , " stats / by - summoner / " , summonerid , " / summary ? api_key= " , key ) ; <nl> if ( season ! = null ) { <nl> - url += " & season= " + season ; <nl> + request . addtourl ( " & season= " , season ) ; <nl> } <nl> - <nl> - playerstatssummarylist summarylist = null ; <nl> - try { <nl> - summarylist = new gson ( ) . fromjson ( request . sendget ( url ) , playerstatssummarylist . class ) ; <nl> - } catch ( jsonsyntaxexception e ) { <nl> - throw new riotapiexception ( riotapiexception . parse_failure ) ; <nl> - } <nl> - if ( summarylist == null ) { <nl> - throw new riotapiexception ( riotapiexception . parse_failure ) ; <nl> - } <nl> - <nl> - return summarylist ; <nl> + request . execute ( ) ; <nl> + playerstatssummarylist dto = request . getdto ( playerstatssummarylist . class ) ; <nl> + return dto ; <nl> + } <nl> 
mmm a / src / main / java / com / pantherman594 / gssentials / command / general / slapcommand . java <nl> ppp b / src / main / java / com / pantherman594 / gssentials / command / general / slapcommand . java <nl> @ override <nl> public iterable & lt ; string & gt ; ontabcomplete ( commandsender sender , string [ ] args ) { <nl> - if ( args . length & gt ; 1 || args . length == 0 ) { <nl> - return immutableset . of ( ) ; <nl> - } <nl> - <nl> - set & lt ; string & gt ; matches = new hashset & lt ; & gt ; ( ) ; <nl> - string search = args [ 0 ] . tolowercase ( ) ; <nl> - for ( proxiedplayer player : proxyserver . getinstance ( ) . getplayers ( ) ) { <nl> - if ( ! player . getname ( ) . equals ( sender . getname ( ) ) ) { <nl> - if ( player . getname ( ) . tolowercase ( ) . startswith ( search ) & & ! playerdata . getdata ( player . getuniqueid ( ) ) . ishidden ( ) ) { <nl> - matches . add ( player . getname ( ) ) ; <nl> - } <nl> - } <nl> - } <nl> - return matches ; <nl> + return args . length == 1 ? tabplayers ( sender , args [ 0 ] ) : immutableset . & lt ; string & gt ; of ( ) ; <nl> } <nl> } <nl> 
mmm a / source / net / malisis / doors / door / movement / spinningarounddoormovement . java <nl> ppp b / source / net / malisis / doors / door / movement / spinningarounddoormovement . java <nl> @ override <nl> public axisalignedbb getboundingbox ( doortileentity tileentity , boolean topblock , boundingboxtype type ) <nl> { <nl> - int dir = tileentity . getdirection ( ) ; <nl> - boolean opened = tileentity . isopened ( ) ; <nl> - <nl> - if ( opened & & type ! = boundingboxtype . raytrace ) <nl> + if ( tileentity . isopened ( ) & & type ! = boundingboxtype . raytrace ) <nl> return null ; <nl>  <nl> - float x = 0 ; <nl> - float y = 0 ; <nl> - float z = 0 ; <nl> - float x = 1 ; <nl> - float y = 1 ; <nl> - float z = 1 ; <nl> - <nl> - if ( dir == dir_north ) <nl> - z = door_width ; <nl> - if ( dir == dir_south ) <nl> - z = 1 - door_width ; <nl> - if ( dir == dir_west ) <nl> - x = door_width ; <nl> - if ( dir == dir_east ) <nl> - x = 1 - door_width ; <nl> - <nl> + axisalignedbb aabb = axisalignedbb . getboundingbox ( 0 , 0 , 0 , 1 , 1 , door_width ) ; <nl> if ( type == boundingboxtype . selection ) <nl> { <nl> if ( ! topblock ) <nl> - y++ ; <nl> + aabb . maxy++ ; <nl> else <nl> - y -  - ; <nl> + aabb . miny -  - ; <nl> } <nl>  <nl> - return axisalignedbb . getboundingbox ( x , y , z , x , y , z ) ; <nl> + return aabb ; <nl> } <nl>  <nl> @ override <nl> 
mmm a / jwe / callout / src / main / java / com / apigee / callout / jwe / jweencryptorcallout . java <nl> ppp b / jwe / callout / src / main / java / com / apigee / callout / jwe / jweencryptorcallout . java <nl> private string resolvepropertyvalue ( string spec , messagecontext msgctxt ) { <nl> - if ( spec . startswith ( " { " ) & & spec . endswith ( " } " ) ) { <nl> - string varname = spec . substring ( 1 , spec . length ( ) - 1 ) ; <nl> - string value = msgctxt . getvariable ( varname ) ; <nl> - return value ; <nl> + if ( spec . indexof ( ' { ' ) & gt ; - 1 & & spec . indexof ( ' } ' ) & gt ; - 1 ) { <nl> + templatestring ts = new templatestring ( spec ) ; <nl> + map & lt ; string , string & gt ; valuesmap = new hashmap & lt ; string , string & gt ; ( ) ; <nl> + for ( string s : ts . variablenames ) { <nl> + valuesmap . put ( s , ( string ) msgctxt . getvariable ( s ) ) ; <nl> + } <nl> + strsubstitutor sub = new strsubstitutor ( valuesmap ) ; <nl> + string resolvedstring = sub . replace ( ts . template ) ; <nl> + return resolvedstring ; <nl> } <nl> return spec ; <nl> } <nl> 
mmm a / library / src / test / java / org / chalup / microorm / tests / basictypestest . java <nl> ppp b / library / src / test / java / org / chalup / microorm / tests / basictypestest . java <nl> @ test <nl> public void shouldunpackboxedintfieldsfromcursor ( ) throws exception { <nl> - cursor c = mock ( cursor . class ) ; <nl> - <nl> - when ( c . getcolumnindex ( boxedintegerdao . integer_column ) ) . thenreturn ( 0 ) ; <nl> - when ( c . getcolumnindexorthrow ( boxedintegerdao . integer_column ) ) . thenreturn ( 0 ) ; <nl> - when ( c . isnull ( 0 ) ) . thenreturn ( boolean . false ) ; <nl> - when ( c . getint ( 0 ) ) . thenreturn ( boxedintegerdao . test_int ) ; <nl> - <nl> - when ( c . getcolumnindex ( boxedintegerdao . null_integer_column ) ) . thenreturn ( 1 ) ; <nl> - when ( c . getcolumnindexorthrow ( boxedintegerdao . null_integer_column ) ) . thenreturn ( 1 ) ; <nl> - when ( c . isnull ( 1 ) ) . thenreturn ( boolean . true ) ; <nl> + cursor c = testcursorbuilder <nl> + . cursor ( boxedintegerdao . integer_column , boxedintegerdao . null_integer_column ) <nl> + . addrow ( boxedintegerdao . test_int , null ) ; <nl>  <nl> boxedintegerdao boxedintegerdao = testsubject . fromcursor ( c , boxedintegerdao . class ) ; <nl> assertthat ( boxedintegerdao . mint ) . isequalto ( boxedintegerdao . test_int ) ; <nl> 
mmm a / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / messaging / coprocessor / hbase10cdh550 / messagetableregionobserver . java <nl> ppp b / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / messaging / coprocessor / hbase10cdh550 / messagetableregionobserver . java <nl> log . info ( " precompact , filter using messagedatafilter " ) ; <nl> transactionvisibilitystate txvisibilitystate = txstatecache . getlateststate ( ) ; <nl>  <nl> - if ( pruneenable == null ) { <nl> - cconfiguration cconf = topicmetadatacache . getcconfiguration ( ) ; <nl> - if ( cconf ! = null ) { <nl> - pruneenable = cconf . getboolean ( txconstants . transactionpruning . prune_enable , <nl> - txconstants . transactionpruning . default_prune_enable ) ; <nl> - if ( boolean . true . equals ( pruneenable ) ) { <nl> - string prunetable = cconf . get ( txconstants . transactionpruning . prune_state_table , <nl> - txconstants . transactionpruning . default_prune_state_table ) ; <nl> - long pruneflushinterval = timeunit . seconds . tomillis ( <nl> - cconf . getlong ( txconstants . transactionpruning . prune_flush_interval , <nl> - txconstants . transactionpruning . default_prune_flush_interval ) ) ; <nl> - compactionstate = new compactionstate ( c . getenvironment ( ) , tablename . valueof ( prunetable ) , pruneflushinterval ) ; <nl> - log . debug ( " automatic invalid list pruning is enabled . compaction state will be recorded in table " + <nl> - prunetable ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( boolean . true . equals ( pruneenable ) ) { <nl> + reloadprunestate ( c . getenvironment ( ) ) ; <nl> + if ( compactionstate ! = null ) { <nl> compactionstate . record ( request , txvisibilitystate ) ; <nl> - } <nl> 
mmm a / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / client / perspectives / droolsauthoringperspective . java <nl> ppp b / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / client / perspectives / droolsauthoringperspective . java <nl> } <nl> } ) <nl> . endmenu ( ) <nl> - . newtoplevelmenu ( constants . explore ( ) ) <nl> - . menus ( ) <nl> - . menu ( constants . inboxincomingchanges ( ) ) <nl> - . respondswith ( new command ( ) { <nl> - @ override <nl> - public void execute ( ) { <nl> - placemanager . goto ( " inbox " ) ; <nl> - } <nl> - } ) <nl> - . endmenu ( ) <nl> - . menu ( constants . inboxrecentlyedited ( ) ) <nl> - . respondswith ( new command ( ) { <nl> - @ override <nl> - public void execute ( ) { <nl> - placerequest p = new defaultplacerequest ( " inbox " ) ; <nl> - p . addparameter ( " inboxname " , inboxpresenter . recent_edited_id ) ; <nl> - placemanager . goto ( p ) ; <nl> - } <nl> - } ) <nl> - . endmenu ( ) <nl> - . menu ( constants . inboxrecentlyopened ( ) ) <nl> - . respondswith ( new command ( ) { <nl> - @ override <nl> - public void execute ( ) { <nl> - placerequest p = new defaultplacerequest ( " inbox " ) ; <nl> - p . addparameter ( " inboxname " , inboxpresenter . recent_viewed_id ) ; <nl> - placemanager . goto ( p ) ; <nl> - } <nl> - } ) <nl> - . endmenu ( ) <nl> - . endmenus ( ) <nl> - . endmenu ( ) <nl> . newtoplevelmenu ( constants . newitem ( ) ) <nl> . withitems ( newresourcesmenu . getmenuitems ( ) ) <nl> . endmenu ( ) <nl> 
mmm a / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / queue / coprocessor / hbase10cdh550 / hbasequeueregionobserver . java <nl> ppp b / cdap - hbase - compat - 1 . 0 - cdh5 . 5 . 0 / src / main / java / co / cask / cdap / data2 / transaction / queue / coprocessor / hbase10cdh550 / hbasequeueregionobserver . java <nl> - } <nl> - <nl> log . info ( " precompact , creates evictioninternalscanner " ) ; <nl> - consumerconfigcache consumerconfigcache = getconfigcache ( e . getenvironment ( ) ) ; <nl> transactionvisibilitystate txvisibilitystate = txstatecache . getlateststate ( ) ; <nl>  <nl> - if ( pruneenable == null ) { <nl> - cconfiguration cconf = consumerconfigcache . getcconf ( ) ; <nl> - if ( cconf ! = null ) { <nl> - pruneenable = cconf . getboolean ( txconstants . transactionpruning . prune_enable , <nl> - txconstants . transactionpruning . default_prune_enable ) ; <nl> - if ( boolean . true . equals ( pruneenable ) ) { <nl> - string prunetable = cconf . get ( txconstants . transactionpruning . prune_state_table , <nl> - txconstants . transactionpruning . default_prune_state_table ) ; <nl> - long pruneflushinterval = timeunit . seconds . tomillis ( <nl> - cconf . getlong ( txconstants . transactionpruning . prune_flush_interval , <nl> - txconstants . transactionpruning . default_prune_flush_interval ) ) ; <nl> - compactionstate = new compactionstate ( e . getenvironment ( ) , tablename . valueof ( prunetable ) , pruneflushinterval ) ; <nl> - log . debug ( " automatic invalid list pruning is enabled . compaction state will be recorded in table " + <nl> - prunetable ) ; <nl> - } <nl> - } <nl> - } <nl> - <nl> - if ( boolean . true . equals ( pruneenable ) ) { <nl> + reloadprunestate ( e . getenvironment ( ) ) ; <nl> + if ( compactionstate ! = null ) { <nl> compactionstate . record ( request , txvisibilitystate ) ; <nl> - } <nl> 
mmm a / wsagent / che - core - api - project / src / main / java / org / eclipse / che / api / project / server / projectservice . java <nl> ppp b / wsagent / che - core - api - project / src / main / java / org / eclipse / che / api / project / server / projectservice . java <nl> + return projectservicelinksinjector . injectfilelinks ( itemreference , getservicecontext ( ) ) ; <nl> } <nl>  <nl> private itemreference injectfolderlinks ( itemreference itemreference ) { <nl> - final uribuilder uribuilder = getservicecontext ( ) . getserviceuribuilder ( ) ; <nl> - final list & lt ; link & gt ; links = new arraylist & lt ; & gt ; ( ) ; <nl> - final string relpath = itemreference . getpath ( ) . substring ( 1 ) ; <nl> - <nl> - links . add ( createlink ( get , <nl> - uribuilder . clone ( ) <nl> - . path ( projectservice . class , " getchildren " ) <nl> - . build ( new string [ ] { relpath } , false ) <nl> - . tostring ( ) , <nl> - application_json , <nl> - link_rel_children ) ) ; <nl> - links . add ( createlink ( get , <nl> - uribuilder . clone ( ) <nl> - . path ( projectservice . class , " gettree " ) <nl> - . build ( new string [ ] { relpath } , false ) <nl> - . tostring ( ) , <nl> - application_json , <nl> - link_rel_tree ) ) ; <nl> - links . add ( createlink ( delete , <nl> - uribuilder . clone ( ) <nl> - . path ( projectservice . class , " delete " ) <nl> - . build ( new string [ ] { relpath } , false ) <nl> - . tostring ( ) , <nl> - link_rel_delete ) ) ; <nl> - <nl> - return itemreference . withlinks ( links ) ; <nl> + return projectservicelinksinjector . injectfolderlinks ( itemreference , getservicecontext ( ) ) ; <nl> } <nl>  <nl> private projectconfigdto injectprojectlinks ( projectconfigdto projectconfig ) { <nl> 
mmm a / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / backend / server / appsetup . java <nl> ppp b / kie - drools - wb / kie - drools - wb - webapp / src / main / java / org / kie / workbench / drools / backend / server / appsetup . java <nl> } <nl>  <nl> - list & lt ; configgroup & gt ; globalconfiggroups = configurationservice . getconfiguration ( configtype . global ) ; <nl> - boolean globalsettingsdefined = false ; <nl> - for ( configgroup globalconfiggroup : globalconfiggroups ) { <nl> - if ( global_settings . equals ( globalconfiggroup . getname ( ) ) ) { <nl> - globalsettingsdefined = true ; <nl> + final configitem & lt ; string & gt ; supportruntimedeployconfigitem = new configitem & lt ; & gt ; ( ) ; <nl> + supportruntimedeployconfigitem . setname ( " support . runtime . deploy " ) ; <nl> + supportruntimedeployconfigitem . setvalue ( " false " ) ; <nl> + setupconfigurationgroup ( configtype . global , <nl> + global_settings , <nl> + getglobalconfiguration ( ) , <nl> + supportruntimedeployconfigitem ) ; <nl>  <nl> - configitem & lt ; string & gt ; runtimedeployconfig = globalconfiggroup . getconfigitem ( " support . runtime . deploy " ) ; <nl> - if ( runtimedeployconfig == null ) { <nl> - globalconfiggroup . addconfigitem ( configurationfactory . newconfigitem ( " support . runtime . deploy " , " false " ) ) ; <nl> - configurationservice . updateconfiguration ( globalconfiggroup ) ; <nl> - } else if ( ! runtimedeployconfig . getvalue ( ) . equalsignorecase ( " false " ) ) { <nl> - runtimedeployconfig . setvalue ( " false " ) ; <nl> - configurationservice . updateconfiguration ( globalconfiggroup ) ; <nl> - } <nl> - break ; <nl> - } <nl> - } <nl> - if ( ! globalsettingsdefined ) { <nl> - configurationservice . addconfiguration ( getglobalconfiguration ( ) ) ; <nl> - } <nl> - <nl> + setupconfigurationgroup ( configtype . editor , <nl> 
mmm a / src / main / java / org / sqlite / rs . java <nl> ppp b / src / main / java / org / sqlite / rs . java <nl> } <nl>  <nl> public date getdate ( int col , calendar cal ) throws sqlexception { <nl> - if ( db . column_type ( stmt . pointer , markcol ( col ) ) == sqlite_null ) <nl> + int data_type = db . column_type ( stmt . pointer , markcol ( col ) ) ; <nl> + if ( data_type == sqlite_null ) <nl> return null ; <nl> if ( cal == null ) <nl> return getdate ( col ) ; <nl> - cal . settimeinmillis ( db . column_long ( stmt . pointer , markcol ( col ) ) ) ; <nl> - return new date ( cal . gettime ( ) . gettime ( ) ) ; <nl> + if ( data_type == sqlite_integer ) { <nl> + cal . settimeinmillis ( db . column_long ( stmt . pointer , markcol ( col ) ) * date_int_multiplier ) ; <nl> + return new date ( cal . gettime ( ) . gettime ( ) ) ; <nl> + } <nl> + if ( data_type == sqlite_text ) { <nl> + try { <nl> + dateformat df2 = ( dateformat ) df . clone ( ) ; <nl> + df2 . setcalendar ( cal ) ; <nl> + return new java . sql . date ( df2 . parse ( db . column_text ( stmt . pointer , markcol ( col ) ) ) . gettime ( ) ) ; <nl> + } catch ( exception e ) { <nl> + return null ; <nl> + } <nl> + } <nl> + if ( data_type == sqlite_float ) { <nl> + return new date ( juliandatetocalendar ( db . column_double ( stmt . pointer , markcol ( col ) ) , cal ) . gettimeinmillis ( ) ) ; <nl> + } <nl> + return null ; <nl> } <nl> + <nl> + public date getdate ( string col ) throws sqlexception { <nl> 
mmm a / src / main / java / hellfirepvp / astralsorcery / client / gui / container / guialtardiscovery . java <nl> ppp b / src / main / java / hellfirepvp / astralsorcery / client / gui / container / guialtardiscovery . java <nl> tuple & lt ; double , double & gt ; uvoffset = spritestarlight . getuvoffset ( t ) ; <nl> drawrect ( guileft + 6 , guitop + 69 , ( int ) ( 165 * percfilled ) , 10 , <nl> uvoffset . key , uvoffset . value , <nl> - spritestarlight . getulength ( ) * percfilled , spritestarlight . getvlength ( ) * percfilled ) ; <nl> - } <nl> + spritestarlight . getulength ( ) * percfilled , spritestarlight . getvlength ( ) ) ; <nl> + <nl> + abstractaltarrecipe aar = findcraftablerecipe ( true ) ; <nl> + if ( aar ! = null ) { <nl> + int req = aar . getpassivestarlightrequired ( ) ; <nl> + int has = containeraltarbase . tilealtar . getstarlightstored ( ) ; <nl> + if ( has & lt ; req ) { <nl> + int max = containeraltarbase . tilealtar . getmaxstarlightstorage ( ) ; <nl> + float percreq = ( float ) req / ( float ) max ; <nl> + int from = ( int ) ( 165 * percfilled ) ; <nl> + int to = ( int ) ( 165 * percreq ) ; <nl> + gl11 . glcolor4f ( 0 . 2f , 0 . 5f , 1 . 0f , 0 . 4f ) ; <nl>  <nl> - gl11 . glcolor4f ( 1 . 0f , 1 . 0f , 1 . 0f , 1 . 0f ) ; <nl> + drawrect ( guileft + 6 + from , guitop + 69 , to , 10 , <nl> + uvoffset . key + spritestarlight . getulength ( ) * percfilled , uvoffset . value , <nl> + spritestarlight . getulength ( ) * percreq , spritestarlight . getvlength ( ) ) ; <nl> + } <nl> + } <nl> + } <nl> 
mmm a / library - extensions / src / main / java / com / mikepenz / fastadapter_extensions / items / singlelineitem . java <nl> ppp b / library - extensions / src / main / java / com / mikepenz / fastadapter_extensions / items / singlelineitem . java <nl> public void bindview ( viewholder holder , list payloads ) { <nl> super . bindview ( holder , payloads ) ; <nl> mname . applyto ( holder . name ) ; <nl> - if ( mavatar ! = null ) { <nl> - if ( holder . avatar . getvisibility ( ) == view . gone ) { <nl> - holder . avatar . setvisibility ( view . visible ) ; <nl> - } <nl> - mavatar . applyto ( holder . avatar ) ; <nl> - } else if ( holder . avatar . getvisibility ( ) == view . visible ) { <nl> - holder . avatar . setvisibility ( view . gone ) ; <nl> - } <nl> - if ( micon ! = null ) { <nl> - if ( holder . icon . getvisibility ( ) == view . gone ) { <nl> - holder . icon . setvisibility ( view . visible ) ; <nl> - } <nl> - micon . applyto ( holder . icon ) ; <nl> - } else if ( holder . icon . getvisibility ( ) == view . visible ) { <nl> - holder . icon . setvisibility ( view . gone ) ; <nl> - } <nl> + imageholder . applytoorsetinvisible ( mavatar , holder . avatar ) ; <nl> + imageholder . applytoorsetinvisible ( micon , holder . icon ) ; <nl> } <nl> + <nl> + @ override <nl> 
mmm a / bukkit / src / main / java / com / boydti / fawe / bukkit / v1_9 / bukkitqueue_1_9_r1 . java <nl> ppp b / bukkit / src / main / java / com / boydti / fawe / bukkit / v1_9 / bukkitqueue_1_9_r1 . java <nl> @ override <nl> public void refreshchunk ( fawechunk fc ) { <nl> bukkitchunk_1_9 fs = ( bukkitchunk_1_9 ) fc ; <nl> - ensurechunkloaded ( fc . getx ( ) , fc . getz ( ) ) ; <nl> - chunk chunk = fs . getchunk ( ) ; <nl> - if ( ! chunk . isloaded ( ) ) { <nl> - return ; <nl> - } <nl> - net . minecraft . server . v1_9_r2 . chunk nmschunk = ( ( craftchunk ) chunk ) . gethandle ( ) ; <nl> - worldserver w = ( worldserver ) nmschunk . getworld ( ) ; <nl> - playerchunkmap chunkmap = w . getplayerchunkmap ( ) ; <nl> - playerchunk playerchunk = chunkmap . getchunk ( nmschunk . locx , nmschunk . locz ) ; <nl> - if ( playerchunk == null ) { <nl> - return ; <nl> - } <nl> - if ( playerchunk . c . isempty ( ) ) { <nl> + if ( ! ischunkloaded ( fc . getx ( ) , fc . getz ( ) ) ) { <nl> return ; <nl> } <nl> - int mask = fc . getbitmask ( ) ; <nl> - if ( mask == 0 || mask == 65535 & & hasentities ( nmschunk ) ) { <nl> - packetplayoutmapchunk packet = new packetplayoutmapchunk ( nmschunk , 65280 ) ; <nl> - for ( entityplayer player : playerchunk . c ) { <nl> - player . playerconnection . sendpacket ( packet ) ; <nl> - } <nl> - mask = 255 ; <nl> - } <nl> - packetplayoutmapchunk packet = new packetplayoutmapchunk ( nmschunk , mask ) ; <nl> - for ( entityplayer player : playerchunk . c ) { <nl> - player . playerconnection . sendpacket ( packet ) ; <nl> - } <nl> + chunk chunk = fs . getchunk ( ) ; <nl> + sendchunk ( chunk , fs . getbitmask ( ) ) ; <nl> } <nl> + <nl> + public void sendchunk ( chunk chunk , int mask ) { <nl> 
mmm a / carbon / src / main / java / carbon / widget / checkbox . java <nl> ppp b / carbon / src / main / java / carbon / widget / checkbox . java <nl> - } <nl> + * <nl> + * @ param d the drawable to use as the button graphic <nl> + * / <nl> + public void setbuttondrawable ( checkabledrawable d ) { <nl> + if ( drawable ! = d ) { <nl> + if ( drawable ! = null ) { <nl> + drawable . setcallback ( null ) ; <nl> + unscheduledrawable ( drawable ) ; <nl> + } <nl>  <nl> - public void setrippledrawable ( rippledrawable newripple ) { <nl> - if ( rippledrawable ! = null ) { <nl> - rippledrawable . setcallback ( null ) ; <nl> - if ( rippledrawable . getstyle ( ) == rippledrawable . style . background ) <nl> - super . setbackgrounddrawable ( rippledrawable . getbackground ( ) ) ; <nl> - } <nl> + drawable = d ; <nl>  <nl> - if ( newripple ! = null ) { <nl> - newripple . setcallback ( this ) ; <nl> - newripple . setbounds ( 0 , 0 , getwidth ( ) , getheight ( ) ) ; <nl> - if ( newripple . getstyle ( ) == rippledrawable . style . background ) <nl> - super . setbackgrounddrawable ( ( drawable ) newripple ) ; <nl> + if ( d ! = null ) { <nl> + d . setcallback ( this ) ; <nl> + if ( d . isstateful ( ) ) { <nl> + d . setstate ( getdrawablestate ( ) ) ; <nl> + } <nl> + d . setvisible ( getvisibility ( ) == visible , false ) ; <nl> + setminheight ( d . getintrinsicheight ( ) ) ; <nl> + applybuttontint ( ) ; <nl> + } <nl> } <nl> - <nl> - rippledrawable = newripple ; <nl> + } <nl> 
mmm a / client / src / main / java / net / luxvacuos / voxel / client / core / states / spworldstate . java <nl> ppp b / client / src / main / java / net / luxvacuos / voxel / client / core / states / spworldstate . java <nl> - c = bufferutils . createfloatbuffer ( 3 ) ; <nl> - window window = clientinternalsubsystem . getinstance ( ) . getgamewindow ( ) ; <nl> + matrix4d [ ] shadowprojectionmatrix = new matrix4d [ 4 ] ; <nl>  <nl> - matrix4d shadowprojectionmatrix = maths . orthographic ( - clientvariables . shadowmapdrawdistance , <nl> + shadowprojectionmatrix [ 0 ] = maths . orthographic ( - clientvariables . shadowmapdrawdistance / 32 , <nl> + clientvariables . shadowmapdrawdistance / 32 , - clientvariables . shadowmapdrawdistance / 32 , <nl> + clientvariables . shadowmapdrawdistance / 32 , - clientvariables . shadowmapdrawdistance , <nl> + clientvariables . shadowmapdrawdistance , false ) ; <nl> + shadowprojectionmatrix [ 1 ] = maths . orthographic ( - clientvariables . shadowmapdrawdistance / 16 , <nl> + clientvariables . shadowmapdrawdistance / 16 , - clientvariables . shadowmapdrawdistance / 16 , <nl> + clientvariables . shadowmapdrawdistance / 16 , - clientvariables . shadowmapdrawdistance , <nl> + clientvariables . shadowmapdrawdistance , false ) ; <nl> + shadowprojectionmatrix [ 2 ] = maths . orthographic ( - clientvariables . shadowmapdrawdistance / 4 , <nl> + clientvariables . shadowmapdrawdistance / 4 , - clientvariables . shadowmapdrawdistance / 4 , <nl> + clientvariables . shadowmapdrawdistance / 4 , - clientvariables . shadowmapdrawdistance , <nl> + clientvariables . shadowmapdrawdistance , false ) ; <nl> + shadowprojectionmatrix [ 3 ] = maths . orthographic ( - clientvariables . shadowmapdrawdistance , <nl> clientvariables . shadowmapdrawdistance , - clientvariables . shadowmapdrawdistance , <nl> clientvariables . shadowmapdrawdistance , - clientvariables . shadowmapdrawdistance , <nl> clientvariables . shadowmapdrawdistance , false ) ; <nl> 
mmm a / frontend - maven - plugin / src / main / java / com / github / eirslett / maven / plugins / frontend / mojo / gruntmojo . java <nl> ppp b / frontend - maven - plugin / src / main / java / com / github / eirslett / maven / plugins / frontend / mojo / gruntmojo . java <nl> } <nl>  <nl> private boolean shouldexecute ( ) { <nl> - if ( skip ) { <nl> - return false ; <nl> + if ( triggerfiles == null || triggerfiles . isempty ( ) ) { <nl> + triggerfiles = arrays . aslist ( new file ( workingdirectory , " gruntfile . js " ) ) ; <nl> } <nl>  <nl> - if ( buildcontext == null || ! buildcontext . isincremental ( ) ) { <nl> - return true ; <nl> - } <nl> - <nl> - if ( triggerfiles ! = null ) { <nl> - for ( int i = 0 ; i & lt ; triggerfiles . length ; i++ ) { <nl> - if ( buildcontext . hasdelta ( triggerfiles [ i ] ) ) { <nl> - return true ; <nl> - } <nl> - } <nl> - } else { <nl> - if ( buildcontext . hasdelta ( new file ( workingdirectory , " gruntfile . js " ) ) ) { <nl> - return true ; <nl> - } <nl> - } <nl> - <nl> - if ( srcdir == null ) { <nl> - getlog ( ) . info ( " grunt goal does n't have srcdir set : not checking for modified files " ) ; <nl> - return true ; <nl> - } <nl> - <nl> - scanner scanner = buildcontext . newscanner ( srcdir ) ; <nl> - scanner . scan ( ) ; <nl> - string [ ] includedfiles = scanner . getincludedfiles ( ) ; <nl> - return ( includedfiles ! = null & & includedfiles . length & gt ; 0 ) ; <nl> + return mojoutils . shouldexecute ( buildcontext , triggerfiles , srcdir ) ; <nl> } <nl>  <nl> } <nl> 
